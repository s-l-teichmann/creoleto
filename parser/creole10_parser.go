// Generated from Creole10.g4 by ANTLR 4.7.

package parser // Creole10

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 26, 960,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 3, 2, 3,
	2, 3, 3, 5, 3, 224, 10, 3, 3, 3, 3, 3, 3, 3, 3, 4, 7, 4, 230, 10, 4, 12,
	4, 14, 4, 233, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 240, 10, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 249, 10, 5, 3, 5, 5, 5, 252,
	10, 5, 5, 5, 254, 10, 5, 3, 6, 3, 6, 3, 6, 7, 6, 259, 10, 6, 12, 6, 14,
	6, 262, 11, 6, 3, 6, 3, 6, 6, 6, 266, 10, 6, 13, 6, 14, 6, 267, 3, 7, 3,
	7, 7, 7, 272, 10, 7, 12, 7, 14, 7, 275, 11, 7, 3, 7, 3, 7, 3, 8, 3, 8,
	3, 8, 5, 8, 282, 10, 8, 3, 9, 3, 9, 3, 9, 5, 9, 287, 10, 9, 3, 9, 5, 9,
	290, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 295, 10, 9, 3, 9, 5, 9, 298, 10, 9,
	5, 9, 300, 10, 9, 3, 10, 5, 10, 303, 10, 10, 3, 10, 7, 10, 306, 10, 10,
	12, 10, 14, 10, 309, 11, 10, 3, 10, 5, 10, 312, 10, 10, 3, 11, 3, 11, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 321, 10, 11, 3, 12, 3, 12, 3, 13,
	5, 13, 326, 10, 13, 3, 13, 7, 13, 329, 10, 13, 12, 13, 14, 13, 332, 11,
	13, 3, 13, 5, 13, 335, 10, 13, 3, 14, 3, 14, 3, 14, 5, 14, 340, 10, 14,
	3, 14, 5, 14, 343, 10, 14, 3, 15, 3, 15, 3, 15, 5, 15, 348, 10, 15, 3,
	15, 5, 15, 351, 10, 15, 3, 16, 5, 16, 354, 10, 16, 3, 16, 5, 16, 357, 10,
	16, 3, 16, 5, 16, 360, 10, 16, 3, 17, 3, 17, 3, 17, 5, 17, 365, 10, 17,
	6, 17, 367, 10, 17, 13, 17, 14, 17, 368, 3, 18, 3, 18, 3, 18, 3, 19, 3,
	19, 5, 19, 376, 10, 19, 3, 20, 3, 20, 3, 20, 5, 20, 381, 10, 20, 3, 21,
	3, 21, 5, 21, 385, 10, 21, 3, 22, 3, 22, 3, 22, 6, 22, 390, 10, 22, 13,
	22, 14, 22, 391, 3, 23, 3, 23, 5, 23, 396, 10, 23, 3, 24, 3, 24, 3, 24,
	6, 24, 401, 10, 24, 13, 24, 14, 24, 402, 3, 25, 3, 25, 3, 25, 5, 25, 408,
	10, 25, 3, 25, 5, 25, 411, 10, 25, 3, 25, 3, 25, 3, 26, 3, 26, 3, 26, 5,
	26, 418, 10, 26, 3, 26, 3, 26, 6, 26, 422, 10, 26, 13, 26, 14, 26, 423,
	5, 26, 426, 10, 26, 3, 27, 6, 27, 429, 10, 27, 13, 27, 14, 27, 430, 3,
	27, 5, 27, 434, 10, 27, 3, 28, 3, 28, 3, 28, 3, 29, 6, 29, 440, 10, 29,
	13, 29, 14, 29, 441, 3, 29, 5, 29, 445, 10, 29, 3, 30, 3, 30, 3, 30, 3,
	31, 7, 31, 451, 10, 31, 12, 31, 14, 31, 454, 11, 31, 3, 31, 3, 31, 3, 31,
	3, 32, 3, 32, 5, 32, 461, 10, 32, 3, 33, 7, 33, 464, 10, 33, 12, 33, 14,
	33, 467, 11, 33, 3, 34, 3, 34, 3, 34, 3, 34, 5, 34, 473, 10, 34, 3, 35,
	3, 35, 3, 35, 3, 35, 7, 35, 479, 10, 35, 12, 35, 14, 35, 482, 11, 35, 3,
	35, 5, 35, 485, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 491, 10, 35,
	12, 35, 14, 35, 494, 11, 35, 3, 35, 5, 35, 497, 10, 35, 5, 35, 499, 10,
	35, 3, 36, 3, 36, 5, 36, 503, 10, 36, 3, 36, 5, 36, 506, 10, 36, 3, 37,
	3, 37, 3, 37, 5, 37, 511, 10, 37, 3, 37, 6, 37, 514, 10, 37, 13, 37, 14,
	37, 515, 5, 37, 518, 10, 37, 3, 38, 3, 38, 3, 38, 5, 38, 523, 10, 38, 3,
	38, 6, 38, 526, 10, 38, 13, 38, 14, 38, 527, 5, 38, 530, 10, 38, 3, 39,
	6, 39, 533, 10, 39, 13, 39, 14, 39, 534, 3, 40, 6, 40, 538, 10, 40, 13,
	40, 14, 40, 539, 3, 41, 6, 41, 543, 10, 41, 13, 41, 14, 41, 544, 3, 41,
	5, 41, 548, 10, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 5, 42, 555, 10,
	42, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 45, 6, 45, 564, 10, 45,
	13, 45, 14, 45, 565, 3, 45, 5, 45, 569, 10, 45, 3, 46, 3, 46, 3, 46, 3,
	46, 5, 46, 575, 10, 46, 3, 47, 3, 47, 5, 47, 579, 10, 47, 3, 47, 5, 47,
	582, 10, 47, 3, 47, 3, 47, 5, 47, 586, 10, 47, 3, 47, 5, 47, 589, 10, 47,
	5, 47, 591, 10, 47, 3, 48, 3, 48, 3, 48, 6, 48, 596, 10, 48, 13, 48, 14,
	48, 597, 3, 48, 5, 48, 601, 10, 48, 3, 49, 6, 49, 604, 10, 49, 13, 49,
	14, 49, 605, 3, 49, 5, 49, 609, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 5,
	50, 615, 10, 50, 5, 50, 617, 10, 50, 3, 51, 3, 51, 3, 51, 5, 51, 622, 10,
	51, 3, 51, 5, 51, 625, 10, 51, 3, 52, 5, 52, 628, 10, 52, 3, 52, 5, 52,
	631, 10, 52, 3, 53, 6, 53, 634, 10, 53, 13, 53, 14, 53, 635, 3, 54, 3,
	54, 3, 54, 3, 54, 5, 54, 642, 10, 54, 3, 55, 3, 55, 5, 55, 646, 10, 55,
	3, 56, 3, 56, 3, 56, 6, 56, 651, 10, 56, 13, 56, 14, 56, 652, 3, 57, 3,
	57, 7, 57, 657, 10, 57, 12, 57, 14, 57, 660, 11, 57, 3, 57, 3, 57, 3, 57,
	3, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 60, 3, 60, 7, 60, 672, 10, 60, 12,
	60, 14, 60, 675, 11, 60, 3, 60, 3, 60, 3, 61, 3, 61, 5, 61, 681, 10, 61,
	3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 690, 10, 62, 3,
	62, 3, 62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 5, 63, 699, 10, 63, 3, 64,
	3, 64, 3, 64, 3, 65, 6, 65, 705, 10, 65, 13, 65, 14, 65, 706, 3, 66, 3,
	66, 3, 66, 3, 66, 6, 66, 713, 10, 66, 13, 66, 14, 66, 714, 3, 67, 3, 67,
	3, 67, 3, 67, 6, 67, 721, 10, 67, 13, 67, 14, 67, 722, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 6, 67, 731, 10, 67, 13, 67, 14, 67, 732, 3, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 6, 67, 740, 10, 67, 13, 67, 14, 67, 741, 3,
	67, 3, 67, 5, 67, 746, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68,
	753, 10, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 760, 10, 69, 3,
	70, 3, 70, 3, 70, 6, 70, 765, 10, 70, 13, 70, 14, 70, 766, 3, 70, 3, 70,
	3, 71, 3, 71, 3, 71, 6, 71, 774, 10, 71, 13, 71, 14, 71, 775, 3, 72, 6,
	72, 779, 10, 72, 13, 72, 14, 72, 780, 3, 73, 3, 73, 3, 73, 5, 73, 786,
	10, 73, 3, 73, 3, 73, 3, 74, 6, 74, 791, 10, 74, 13, 74, 14, 74, 792, 3,
	75, 3, 75, 6, 75, 797, 10, 75, 13, 75, 14, 75, 798, 3, 76, 3, 76, 3, 76,
	3, 76, 6, 76, 805, 10, 76, 13, 76, 14, 76, 806, 3, 76, 3, 76, 3, 76, 3,
	76, 3, 76, 3, 76, 6, 76, 815, 10, 76, 13, 76, 14, 76, 816, 3, 76, 3, 76,
	3, 76, 5, 76, 822, 10, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 829,
	10, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 836, 10, 78, 3, 79, 3,
	79, 3, 79, 6, 79, 841, 10, 79, 13, 79, 14, 79, 842, 3, 79, 3, 79, 3, 80,
	3, 80, 6, 80, 849, 10, 80, 13, 80, 14, 80, 850, 3, 81, 3, 81, 3, 81, 3,
	81, 3, 81, 3, 81, 3, 82, 3, 82, 6, 82, 861, 10, 82, 13, 82, 14, 82, 862,
	3, 83, 3, 83, 7, 83, 867, 10, 83, 12, 83, 14, 83, 870, 11, 83, 3, 84, 3,
	84, 3, 84, 3, 84, 3, 84, 5, 84, 877, 10, 84, 3, 85, 6, 85, 880, 10, 85,
	13, 85, 14, 85, 881, 3, 85, 5, 85, 885, 10, 85, 3, 86, 3, 86, 6, 86, 889,
	10, 86, 13, 86, 14, 86, 890, 3, 87, 3, 87, 3, 88, 3, 88, 5, 88, 897, 10,
	88, 3, 88, 5, 88, 900, 10, 88, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 91,
	3, 91, 3, 92, 3, 92, 3, 93, 3, 93, 3, 94, 3, 94, 3, 95, 3, 95, 5, 95, 917,
	10, 95, 3, 95, 5, 95, 920, 10, 95, 3, 96, 3, 96, 5, 96, 924, 10, 96, 3,
	97, 3, 97, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 5, 99, 933, 10, 99, 3, 100,
	3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 103,
	3, 103, 3, 104, 3, 104, 3, 105, 3, 105, 3, 106, 3, 106, 3, 107, 3, 107,
	3, 108, 3, 108, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 2, 2, 111, 2, 4,
	6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 2, 14, 10, 3, 6, 6, 8, 8, 11, 12,
	14, 14, 16, 16, 18, 21, 23, 23, 25, 25, 10, 3, 6, 6, 8, 8, 11, 12, 14,
	14, 16, 16, 18, 18, 23, 23, 25, 25, 5, 3, 6, 6, 8, 8, 19, 19, 11, 3, 6,
	6, 8, 8, 11, 12, 14, 14, 16, 16, 18, 18, 20, 20, 23, 23, 25, 25, 3, 3,
	7, 7, 4, 3, 8, 8, 13, 13, 5, 3, 8, 8, 15, 15, 20, 20, 9, 3, 6, 6, 8, 8,
	11, 12, 14, 16, 18, 18, 23, 23, 25, 25, 5, 3, 8, 8, 17, 17, 20, 20, 8,
	3, 8, 8, 11, 12, 14, 14, 16, 18, 23, 23, 25, 25, 5, 3, 6, 6, 8, 9, 25,
	25, 4, 3, 6, 6, 25, 25, 2, 1004, 2, 220, 3, 2, 2, 2, 4, 223, 3, 2, 2, 2,
	6, 231, 3, 2, 2, 2, 8, 253, 3, 2, 2, 2, 10, 265, 3, 2, 2, 2, 12, 269, 3,
	2, 2, 2, 14, 281, 3, 2, 2, 2, 16, 299, 3, 2, 2, 2, 18, 311, 3, 2, 2, 2,
	20, 320, 3, 2, 2, 2, 22, 322, 3, 2, 2, 2, 24, 334, 3, 2, 2, 2, 26, 342,
	3, 2, 2, 2, 28, 350, 3, 2, 2, 2, 30, 359, 3, 2, 2, 2, 32, 366, 3, 2, 2,
	2, 34, 370, 3, 2, 2, 2, 36, 375, 3, 2, 2, 2, 38, 380, 3, 2, 2, 2, 40, 384,
	3, 2, 2, 2, 42, 389, 3, 2, 2, 2, 44, 395, 3, 2, 2, 2, 46, 400, 3, 2, 2,
	2, 48, 404, 3, 2, 2, 2, 50, 425, 3, 2, 2, 2, 52, 428, 3, 2, 2, 2, 54, 435,
	3, 2, 2, 2, 56, 439, 3, 2, 2, 2, 58, 446, 3, 2, 2, 2, 60, 452, 3, 2, 2,
	2, 62, 460, 3, 2, 2, 2, 64, 465, 3, 2, 2, 2, 66, 472, 3, 2, 2, 2, 68, 498,
	3, 2, 2, 2, 70, 505, 3, 2, 2, 2, 72, 517, 3, 2, 2, 2, 74, 529, 3, 2, 2,
	2, 76, 532, 3, 2, 2, 2, 78, 537, 3, 2, 2, 2, 80, 542, 3, 2, 2, 2, 82, 554,
	3, 2, 2, 2, 84, 556, 3, 2, 2, 2, 86, 559, 3, 2, 2, 2, 88, 563, 3, 2, 2,
	2, 90, 574, 3, 2, 2, 2, 92, 590, 3, 2, 2, 2, 94, 600, 3, 2, 2, 2, 96, 608,
	3, 2, 2, 2, 98, 616, 3, 2, 2, 2, 100, 624, 3, 2, 2, 2, 102, 630, 3, 2,
	2, 2, 104, 633, 3, 2, 2, 2, 106, 641, 3, 2, 2, 2, 108, 645, 3, 2, 2, 2,
	110, 650, 3, 2, 2, 2, 112, 654, 3, 2, 2, 2, 114, 664, 3, 2, 2, 2, 116,
	667, 3, 2, 2, 2, 118, 669, 3, 2, 2, 2, 120, 678, 3, 2, 2, 2, 122, 684,
	3, 2, 2, 2, 124, 698, 3, 2, 2, 2, 126, 700, 3, 2, 2, 2, 128, 704, 3, 2,
	2, 2, 130, 712, 3, 2, 2, 2, 132, 745, 3, 2, 2, 2, 134, 752, 3, 2, 2, 2,
	136, 759, 3, 2, 2, 2, 138, 764, 3, 2, 2, 2, 140, 773, 3, 2, 2, 2, 142,
	778, 3, 2, 2, 2, 144, 782, 3, 2, 2, 2, 146, 790, 3, 2, 2, 2, 148, 794,
	3, 2, 2, 2, 150, 821, 3, 2, 2, 2, 152, 828, 3, 2, 2, 2, 154, 835, 3, 2,
	2, 2, 156, 840, 3, 2, 2, 2, 158, 848, 3, 2, 2, 2, 160, 852, 3, 2, 2, 2,
	162, 860, 3, 2, 2, 2, 164, 868, 3, 2, 2, 2, 166, 876, 3, 2, 2, 2, 168,
	884, 3, 2, 2, 2, 170, 888, 3, 2, 2, 2, 172, 892, 3, 2, 2, 2, 174, 899,
	3, 2, 2, 2, 176, 901, 3, 2, 2, 2, 178, 903, 3, 2, 2, 2, 180, 906, 3, 2,
	2, 2, 182, 908, 3, 2, 2, 2, 184, 910, 3, 2, 2, 2, 186, 912, 3, 2, 2, 2,
	188, 919, 3, 2, 2, 2, 190, 923, 3, 2, 2, 2, 192, 925, 3, 2, 2, 2, 194,
	927, 3, 2, 2, 2, 196, 932, 3, 2, 2, 2, 198, 934, 3, 2, 2, 2, 200, 936,
	3, 2, 2, 2, 202, 938, 3, 2, 2, 2, 204, 943, 3, 2, 2, 2, 206, 945, 3, 2,
	2, 2, 208, 947, 3, 2, 2, 2, 210, 949, 3, 2, 2, 2, 212, 951, 3, 2, 2, 2,
	214, 953, 3, 2, 2, 2, 216, 955, 3, 2, 2, 2, 218, 957, 3, 2, 2, 2, 220,
	221, 5, 4, 3, 2, 221, 3, 3, 2, 2, 2, 222, 224, 5, 170, 86, 2, 223, 222,
	3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224, 225, 3, 2, 2, 2, 225, 226, 5, 6,
	4, 2, 226, 227, 7, 2, 2, 3, 227, 5, 3, 2, 2, 2, 228, 230, 5, 8, 5, 2, 229,
	228, 3, 2, 2, 2, 230, 233, 3, 2, 2, 2, 231, 229, 3, 2, 2, 2, 231, 232,
	3, 2, 2, 2, 232, 7, 3, 2, 2, 2, 233, 231, 3, 2, 2, 2, 234, 254, 5, 112,
	57, 2, 235, 236, 5, 172, 87, 2, 236, 237, 5, 168, 85, 2, 237, 254, 3, 2,
	2, 2, 238, 240, 5, 172, 87, 2, 239, 238, 3, 2, 2, 2, 239, 240, 3, 2, 2,
	2, 240, 248, 3, 2, 2, 2, 241, 249, 5, 48, 25, 2, 242, 243, 6, 5, 2, 2,
	243, 249, 5, 120, 61, 2, 244, 249, 5, 56, 29, 2, 245, 249, 5, 52, 27, 2,
	246, 249, 5, 78, 40, 2, 247, 249, 5, 10, 6, 2, 248, 241, 3, 2, 2, 2, 248,
	242, 3, 2, 2, 2, 248, 244, 3, 2, 2, 2, 248, 245, 3, 2, 2, 2, 248, 246,
	3, 2, 2, 2, 248, 247, 3, 2, 2, 2, 249, 251, 3, 2, 2, 2, 250, 252, 5, 168,
	85, 2, 251, 250, 3, 2, 2, 2, 251, 252, 3, 2, 2, 2, 252, 254, 3, 2, 2, 2,
	253, 234, 3, 2, 2, 2, 253, 235, 3, 2, 2, 2, 253, 239, 3, 2, 2, 2, 254,
	9, 3, 2, 2, 2, 255, 266, 5, 12, 7, 2, 256, 260, 5, 118, 60, 2, 257, 259,
	5, 20, 11, 2, 258, 257, 3, 2, 2, 2, 259, 262, 3, 2, 2, 2, 260, 258, 3,
	2, 2, 2, 260, 261, 3, 2, 2, 2, 261, 263, 3, 2, 2, 2, 262, 260, 3, 2, 2,
	2, 263, 264, 5, 174, 88, 2, 264, 266, 3, 2, 2, 2, 265, 255, 3, 2, 2, 2,
	265, 256, 3, 2, 2, 2, 266, 267, 3, 2, 2, 2, 267, 265, 3, 2, 2, 2, 267,
	268, 3, 2, 2, 2, 268, 11, 3, 2, 2, 2, 269, 273, 5, 14, 8, 2, 270, 272,
	5, 20, 11, 2, 271, 270, 3, 2, 2, 2, 272, 275, 3, 2, 2, 2, 273, 271, 3,
	2, 2, 2, 273, 274, 3, 2, 2, 2, 274, 276, 3, 2, 2, 2, 275, 273, 3, 2, 2,
	2, 276, 277, 5, 174, 88, 2, 277, 13, 3, 2, 2, 2, 278, 279, 6, 8, 3, 2,
	279, 282, 5, 16, 9, 2, 280, 282, 5, 40, 21, 2, 281, 278, 3, 2, 2, 2, 281,
	280, 3, 2, 2, 2, 282, 15, 3, 2, 2, 2, 283, 284, 5, 180, 91, 2, 284, 289,
	5, 24, 13, 2, 285, 287, 7, 8, 2, 2, 286, 285, 3, 2, 2, 2, 286, 287, 3,
	2, 2, 2, 287, 288, 3, 2, 2, 2, 288, 290, 5, 180, 91, 2, 289, 286, 3, 2,
	2, 2, 289, 290, 3, 2, 2, 2, 290, 300, 3, 2, 2, 2, 291, 292, 5, 178, 90,
	2, 292, 297, 5, 18, 10, 2, 293, 295, 7, 8, 2, 2, 294, 293, 3, 2, 2, 2,
	294, 295, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 298, 5, 178, 90, 2, 297,
	294, 3, 2, 2, 2, 297, 298, 3, 2, 2, 2, 298, 300, 3, 2, 2, 2, 299, 283,
	3, 2, 2, 2, 299, 291, 3, 2, 2, 2, 300, 17, 3, 2, 2, 2, 301, 303, 5, 22,
	12, 2, 302, 301, 3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 307, 3, 2, 2, 2,
	304, 306, 5, 26, 14, 2, 305, 304, 3, 2, 2, 2, 306, 309, 3, 2, 2, 2, 307,
	305, 3, 2, 2, 2, 307, 308, 3, 2, 2, 2, 308, 312, 3, 2, 2, 2, 309, 307,
	3, 2, 2, 2, 310, 312, 7, 2, 2, 3, 311, 302, 3, 2, 2, 2, 311, 310, 3, 2,
	2, 2, 312, 19, 3, 2, 2, 2, 313, 314, 5, 70, 36, 2, 314, 315, 5, 44, 23,
	2, 315, 321, 3, 2, 2, 2, 316, 317, 5, 44, 23, 2, 317, 318, 5, 70, 36, 2,
	318, 321, 3, 2, 2, 2, 319, 321, 5, 16, 9, 2, 320, 313, 3, 2, 2, 2, 320,
	316, 3, 2, 2, 2, 320, 319, 3, 2, 2, 2, 321, 21, 3, 2, 2, 2, 322, 323, 7,
	8, 2, 2, 323, 23, 3, 2, 2, 2, 324, 326, 5, 22, 12, 2, 325, 324, 3, 2, 2,
	2, 325, 326, 3, 2, 2, 2, 326, 330, 3, 2, 2, 2, 327, 329, 5, 28, 15, 2,
	328, 327, 3, 2, 2, 2, 329, 332, 3, 2, 2, 2, 330, 328, 3, 2, 2, 2, 330,
	331, 3, 2, 2, 2, 331, 335, 3, 2, 2, 2, 332, 330, 3, 2, 2, 2, 333, 335,
	7, 2, 2, 3, 334, 325, 3, 2, 2, 2, 334, 333, 3, 2, 2, 2, 335, 25, 3, 2,
	2, 2, 336, 337, 5, 180, 91, 2, 337, 339, 5, 30, 16, 2, 338, 340, 5, 180,
	91, 2, 339, 338, 3, 2, 2, 2, 339, 340, 3, 2, 2, 2, 340, 343, 3, 2, 2, 2,
	341, 343, 5, 32, 17, 2, 342, 336, 3, 2, 2, 2, 342, 341, 3, 2, 2, 2, 343,
	27, 3, 2, 2, 2, 344, 345, 5, 178, 90, 2, 345, 347, 5, 30, 16, 2, 346, 348,
	5, 178, 90, 2, 347, 346, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 351, 3,
	2, 2, 2, 349, 351, 5, 32, 17, 2, 350, 344, 3, 2, 2, 2, 350, 349, 3, 2,
	2, 2, 351, 29, 3, 2, 2, 2, 352, 354, 5, 22, 12, 2, 353, 352, 3, 2, 2, 2,
	353, 354, 3, 2, 2, 2, 354, 356, 3, 2, 2, 2, 355, 357, 5, 32, 17, 2, 356,
	355, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357, 360, 3, 2, 2, 2, 358, 360,
	7, 2, 2, 3, 359, 353, 3, 2, 2, 2, 359, 358, 3, 2, 2, 2, 360, 31, 3, 2,
	2, 2, 361, 362, 5, 70, 36, 2, 362, 364, 5, 44, 23, 2, 363, 365, 5, 34,
	18, 2, 364, 363, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 367, 3, 2, 2, 2,
	366, 361, 3, 2, 2, 2, 367, 368, 3, 2, 2, 2, 368, 366, 3, 2, 2, 2, 368,
	369, 3, 2, 2, 2, 369, 33, 3, 2, 2, 2, 370, 371, 6, 18, 4, 2, 371, 372,
	5, 174, 88, 2, 372, 35, 3, 2, 2, 2, 373, 376, 5, 38, 20, 2, 374, 376, 5,
	118, 60, 2, 375, 373, 3, 2, 2, 2, 375, 374, 3, 2, 2, 2, 376, 37, 3, 2,
	2, 2, 377, 381, 5, 122, 62, 2, 378, 381, 5, 144, 73, 2, 379, 381, 5, 160,
	81, 2, 380, 377, 3, 2, 2, 2, 380, 378, 3, 2, 2, 2, 380, 379, 3, 2, 2, 2,
	381, 39, 3, 2, 2, 2, 382, 385, 5, 42, 22, 2, 383, 385, 5, 38, 20, 2, 384,
	382, 3, 2, 2, 2, 384, 383, 3, 2, 2, 2, 385, 41, 3, 2, 2, 2, 386, 390, 10,
	2, 2, 2, 387, 390, 5, 218, 110, 2, 388, 390, 5, 166, 84, 2, 389, 386, 3,
	2, 2, 2, 389, 387, 3, 2, 2, 2, 389, 388, 3, 2, 2, 2, 390, 391, 3, 2, 2,
	2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 43, 3, 2, 2, 2, 393,
	396, 5, 46, 24, 2, 394, 396, 5, 36, 19, 2, 395, 393, 3, 2, 2, 2, 395, 394,
	3, 2, 2, 2, 396, 45, 3, 2, 2, 2, 397, 401, 10, 3, 2, 2, 398, 401, 5, 218,
	110, 2, 399, 401, 5, 166, 84, 2, 400, 397, 3, 2, 2, 2, 400, 398, 3, 2,
	2, 2, 400, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402, 400, 3, 2, 2, 2,
	402, 403, 3, 2, 2, 2, 403, 47, 3, 2, 2, 2, 404, 405, 5, 182, 92, 2, 405,
	407, 5, 50, 26, 2, 406, 408, 5, 182, 92, 2, 407, 406, 3, 2, 2, 2, 407,
	408, 3, 2, 2, 2, 408, 410, 3, 2, 2, 2, 409, 411, 5, 172, 87, 2, 410, 409,
	3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411, 412, 3, 2, 2, 2, 412, 413, 5, 168,
	85, 2, 413, 49, 3, 2, 2, 2, 414, 415, 5, 182, 92, 2, 415, 417, 5, 50, 26,
	2, 416, 418, 5, 182, 92, 2, 417, 416, 3, 2, 2, 2, 417, 418, 3, 2, 2, 2,
	418, 426, 3, 2, 2, 2, 419, 422, 10, 4, 2, 2, 420, 422, 5, 166, 84, 2, 421,
	419, 3, 2, 2, 2, 421, 420, 3, 2, 2, 2, 422, 423, 3, 2, 2, 2, 423, 421,
	3, 2, 2, 2, 423, 424, 3, 2, 2, 2, 424, 426, 3, 2, 2, 2, 425, 414, 3, 2,
	2, 2, 425, 421, 3, 2, 2, 2, 426, 51, 3, 2, 2, 2, 427, 429, 5, 54, 28, 2,
	428, 427, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 428, 3, 2, 2, 2, 430,
	431, 3, 2, 2, 2, 431, 433, 3, 2, 2, 2, 432, 434, 5, 190, 96, 2, 433, 432,
	3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 53, 3, 2, 2, 2, 435, 436, 5, 184,
	93, 2, 436, 437, 5, 60, 31, 2, 437, 55, 3, 2, 2, 2, 438, 440, 5, 58, 30,
	2, 439, 438, 3, 2, 2, 2, 440, 441, 3, 2, 2, 2, 441, 439, 3, 2, 2, 2, 441,
	442, 3, 2, 2, 2, 442, 444, 3, 2, 2, 2, 443, 445, 5, 190, 96, 2, 444, 443,
	3, 2, 2, 2, 444, 445, 3, 2, 2, 2, 445, 57, 3, 2, 2, 2, 446, 447, 5, 186,
	94, 2, 447, 448, 5, 60, 31, 2, 448, 59, 3, 2, 2, 2, 449, 451, 5, 62, 32,
	2, 450, 449, 3, 2, 2, 2, 451, 454, 3, 2, 2, 2, 452, 450, 3, 2, 2, 2, 452,
	453, 3, 2, 2, 2, 453, 455, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 455, 456,
	5, 64, 33, 2, 456, 457, 5, 188, 95, 2, 457, 61, 3, 2, 2, 2, 458, 461, 5,
	184, 93, 2, 459, 461, 5, 186, 94, 2, 460, 458, 3, 2, 2, 2, 460, 459, 3,
	2, 2, 2, 461, 63, 3, 2, 2, 2, 462, 464, 5, 66, 34, 2, 463, 462, 3, 2, 2,
	2, 464, 467, 3, 2, 2, 2, 465, 463, 3, 2, 2, 2, 465, 466, 3, 2, 2, 2, 466,
	65, 3, 2, 2, 2, 467, 465, 3, 2, 2, 2, 468, 469, 5, 44, 23, 2, 469, 470,
	5, 70, 36, 2, 470, 473, 3, 2, 2, 2, 471, 473, 5, 68, 35, 2, 472, 468, 3,
	2, 2, 2, 472, 471, 3, 2, 2, 2, 473, 67, 3, 2, 2, 2, 474, 480, 5, 178, 90,
	2, 475, 476, 5, 70, 36, 2, 476, 477, 5, 72, 37, 2, 477, 479, 3, 2, 2, 2,
	478, 475, 3, 2, 2, 2, 479, 482, 3, 2, 2, 2, 480, 478, 3, 2, 2, 2, 480,
	481, 3, 2, 2, 2, 481, 484, 3, 2, 2, 2, 482, 480, 3, 2, 2, 2, 483, 485,
	5, 178, 90, 2, 484, 483, 3, 2, 2, 2, 484, 485, 3, 2, 2, 2, 485, 499, 3,
	2, 2, 2, 486, 492, 5, 180, 91, 2, 487, 488, 5, 70, 36, 2, 488, 489, 5,
	74, 38, 2, 489, 491, 3, 2, 2, 2, 490, 487, 3, 2, 2, 2, 491, 494, 3, 2,
	2, 2, 492, 490, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 496, 3, 2, 2, 2,
	494, 492, 3, 2, 2, 2, 495, 497, 5, 180, 91, 2, 496, 495, 3, 2, 2, 2, 496,
	497, 3, 2, 2, 2, 497, 499, 3, 2, 2, 2, 498, 474, 3, 2, 2, 2, 498, 486,
	3, 2, 2, 2, 499, 69, 3, 2, 2, 2, 500, 502, 6, 36, 5, 2, 501, 503, 7, 23,
	2, 2, 502, 501, 3, 2, 2, 2, 502, 503, 3, 2, 2, 2, 503, 506, 3, 2, 2, 2,
	504, 506, 3, 2, 2, 2, 505, 500, 3, 2, 2, 2, 505, 504, 3, 2, 2, 2, 506,
	71, 3, 2, 2, 2, 507, 508, 5, 180, 91, 2, 508, 510, 5, 76, 39, 2, 509, 511,
	5, 180, 91, 2, 510, 509, 3, 2, 2, 2, 510, 511, 3, 2, 2, 2, 511, 518, 3,
	2, 2, 2, 512, 514, 5, 44, 23, 2, 513, 512, 3, 2, 2, 2, 514, 515, 3, 2,
	2, 2, 515, 513, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 518, 3, 2, 2, 2,
	517, 507, 3, 2, 2, 2, 517, 513, 3, 2, 2, 2, 518, 73, 3, 2, 2, 2, 519, 520,
	5, 178, 90, 2, 520, 522, 5, 76, 39, 2, 521, 523, 5, 178, 90, 2, 522, 521,
	3, 2, 2, 2, 522, 523, 3, 2, 2, 2, 523, 530, 3, 2, 2, 2, 524, 526, 5, 44,
	23, 2, 525, 524, 3, 2, 2, 2, 526, 527, 3, 2, 2, 2, 527, 525, 3, 2, 2, 2,
	527, 528, 3, 2, 2, 2, 528, 530, 3, 2, 2, 2, 529, 519, 3, 2, 2, 2, 529,
	525, 3, 2, 2, 2, 530, 75, 3, 2, 2, 2, 531, 533, 5, 44, 23, 2, 532, 531,
	3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 532, 3, 2, 2, 2, 534, 535, 3, 2,
	2, 2, 535, 77, 3, 2, 2, 2, 536, 538, 5, 80, 41, 2, 537, 536, 3, 2, 2, 2,
	538, 539, 3, 2, 2, 2, 539, 537, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540,
	79, 3, 2, 2, 2, 541, 543, 5, 82, 42, 2, 542, 541, 3, 2, 2, 2, 543, 544,
	3, 2, 2, 2, 544, 542, 3, 2, 2, 2, 544, 545, 3, 2, 2, 2, 545, 547, 3, 2,
	2, 2, 546, 548, 5, 192, 97, 2, 547, 546, 3, 2, 2, 2, 547, 548, 3, 2, 2,
	2, 548, 549, 3, 2, 2, 2, 549, 550, 5, 196, 99, 2, 550, 81, 3, 2, 2, 2,
	551, 552, 6, 42, 6, 2, 552, 555, 5, 84, 43, 2, 553, 555, 5, 86, 44, 2,
	554, 551, 3, 2, 2, 2, 554, 553, 3, 2, 2, 2, 555, 83, 3, 2, 2, 2, 556, 557,
	5, 194, 98, 2, 557, 558, 5, 88, 45, 2, 558, 85, 3, 2, 2, 2, 559, 560, 5,
	192, 97, 2, 560, 561, 5, 88, 45, 2, 561, 87, 3, 2, 2, 2, 562, 564, 5, 90,
	46, 2, 563, 562, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 563, 3, 2, 2, 2,
	565, 566, 3, 2, 2, 2, 566, 568, 3, 2, 2, 2, 567, 569, 7, 23, 2, 2, 568,
	567, 3, 2, 2, 2, 568, 569, 3, 2, 2, 2, 569, 89, 3, 2, 2, 2, 570, 575, 5,
	92, 47, 2, 571, 572, 5, 70, 36, 2, 572, 573, 5, 108, 55, 2, 573, 575, 3,
	2, 2, 2, 574, 570, 3, 2, 2, 2, 574, 571, 3, 2, 2, 2, 575, 91, 3, 2, 2,
	2, 576, 578, 5, 180, 91, 2, 577, 579, 5, 96, 49, 2, 578, 577, 3, 2, 2,
	2, 578, 579, 3, 2, 2, 2, 579, 581, 3, 2, 2, 2, 580, 582, 5, 180, 91, 2,
	581, 580, 3, 2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 591, 3, 2, 2, 2, 583,
	585, 5, 178, 90, 2, 584, 586, 5, 94, 48, 2, 585, 584, 3, 2, 2, 2, 585,
	586, 3, 2, 2, 2, 586, 588, 3, 2, 2, 2, 587, 589, 5, 178, 90, 2, 588, 587,
	3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 591, 3, 2, 2, 2, 590, 576, 3, 2,
	2, 2, 590, 583, 3, 2, 2, 2, 591, 93, 3, 2, 2, 2, 592, 593, 5, 70, 36, 2,
	593, 594, 5, 98, 50, 2, 594, 596, 3, 2, 2, 2, 595, 592, 3, 2, 2, 2, 596,
	597, 3, 2, 2, 2, 597, 595, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598, 601,
	3, 2, 2, 2, 599, 601, 7, 2, 2, 3, 600, 595, 3, 2, 2, 2, 600, 599, 3, 2,
	2, 2, 601, 95, 3, 2, 2, 2, 602, 604, 5, 100, 51, 2, 603, 602, 3, 2, 2,
	2, 604, 605, 3, 2, 2, 2, 605, 603, 3, 2, 2, 2, 605, 606, 3, 2, 2, 2, 606,
	609, 3, 2, 2, 2, 607, 609, 7, 2, 2, 3, 608, 603, 3, 2, 2, 2, 608, 607,
	3, 2, 2, 2, 609, 97, 3, 2, 2, 2, 610, 617, 5, 104, 53, 2, 611, 612, 5,
	180, 91, 2, 612, 614, 5, 102, 52, 2, 613, 615, 5, 180, 91, 2, 614, 613,
	3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 615, 617, 3, 2, 2, 2, 616, 610, 3, 2,
	2, 2, 616, 611, 3, 2, 2, 2, 617, 99, 3, 2, 2, 2, 618, 619, 5, 178, 90,
	2, 619, 621, 5, 102, 52, 2, 620, 622, 5, 178, 90, 2, 621, 620, 3, 2, 2,
	2, 621, 622, 3, 2, 2, 2, 622, 625, 3, 2, 2, 2, 623, 625, 5, 104, 53, 2,
	624, 618, 3, 2, 2, 2, 624, 623, 3, 2, 2, 2, 625, 101, 3, 2, 2, 2, 626,
	628, 5, 104, 53, 2, 627, 626, 3, 2, 2, 2, 627, 628, 3, 2, 2, 2, 628, 631,
	3, 2, 2, 2, 629, 631, 7, 2, 2, 3, 630, 627, 3, 2, 2, 2, 630, 629, 3, 2,
	2, 2, 631, 103, 3, 2, 2, 2, 632, 634, 5, 108, 55, 2, 633, 632, 3, 2, 2,
	2, 634, 635, 3, 2, 2, 2, 635, 633, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636,
	105, 3, 2, 2, 2, 637, 642, 5, 122, 62, 2, 638, 642, 5, 144, 73, 2, 639,
	642, 5, 160, 81, 2, 640, 642, 5, 118, 60, 2, 641, 637, 3, 2, 2, 2, 641,
	638, 3, 2, 2, 2, 641, 639, 3, 2, 2, 2, 641, 640, 3, 2, 2, 2, 642, 107,
	3, 2, 2, 2, 643, 646, 5, 110, 56, 2, 644, 646, 5, 106, 54, 2, 645, 643,
	3, 2, 2, 2, 645, 644, 3, 2, 2, 2, 646, 109, 3, 2, 2, 2, 647, 651, 10, 5,
	2, 2, 648, 651, 5, 218, 110, 2, 649, 651, 5, 166, 84, 2, 650, 647, 3, 2,
	2, 2, 650, 648, 3, 2, 2, 2, 650, 649, 3, 2, 2, 2, 651, 652, 3, 2, 2, 2,
	652, 650, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 111, 3, 2, 2, 2, 654,
	658, 5, 114, 58, 2, 655, 657, 10, 6, 2, 2, 656, 655, 3, 2, 2, 2, 657, 660,
	3, 2, 2, 2, 658, 656, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659, 661, 3, 2,
	2, 2, 660, 658, 3, 2, 2, 2, 661, 662, 5, 116, 59, 2, 662, 663, 5, 168,
	85, 2, 663, 113, 3, 2, 2, 2, 664, 665, 5, 198, 100, 2, 665, 666, 5, 176,
	89, 2, 666, 115, 3, 2, 2, 2, 667, 668, 7, 7, 2, 2, 668, 117, 3, 2, 2, 2,
	669, 673, 5, 198, 100, 2, 670, 672, 10, 7, 2, 2, 671, 670, 3, 2, 2, 2,
	672, 675, 3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 673, 674, 3, 2, 2, 2, 674,
	676, 3, 2, 2, 2, 675, 673, 3, 2, 2, 2, 676, 677, 5, 200, 101, 2, 677, 119,
	3, 2, 2, 2, 678, 680, 5, 202, 102, 2, 679, 681, 5, 172, 87, 2, 680, 679,
	3, 2, 2, 2, 680, 681, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 682, 683, 5, 168,
	85, 2, 683, 121, 3, 2, 2, 2, 684, 685, 5, 204, 103, 2, 685, 689, 5, 124,
	63, 2, 686, 687, 5, 208, 105, 2, 687, 688, 5, 130, 66, 2, 688, 690, 3,
	2, 2, 2, 689, 686, 3, 2, 2, 2, 689, 690, 3, 2, 2, 2, 690, 691, 3, 2, 2,
	2, 691, 692, 5, 206, 104, 2, 692, 123, 3, 2, 2, 2, 693, 694, 5, 126, 64,
	2, 694, 695, 7, 3, 2, 2, 695, 696, 5, 128, 65, 2, 696, 699, 3, 2, 2, 2,
	697, 699, 5, 142, 72, 2, 698, 693, 3, 2, 2, 2, 698, 697, 3, 2, 2, 2, 699,
	125, 3, 2, 2, 2, 700, 701, 7, 4, 2, 2, 701, 702, 7, 5, 2, 2, 702, 127,
	3, 2, 2, 2, 703, 705, 10, 8, 2, 2, 704, 703, 3, 2, 2, 2, 705, 706, 3, 2,
	2, 2, 706, 704, 3, 2, 2, 2, 706, 707, 3, 2, 2, 2, 707, 129, 3, 2, 2, 2,
	708, 709, 5, 70, 36, 2, 709, 710, 5, 132, 67, 2, 710, 713, 3, 2, 2, 2,
	711, 713, 5, 144, 73, 2, 712, 708, 3, 2, 2, 2, 712, 711, 3, 2, 2, 2, 713,
	714, 3, 2, 2, 2, 714, 712, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 131,
	3, 2, 2, 2, 716, 720, 5, 178, 90, 2, 717, 718, 5, 70, 36, 2, 718, 719,
	5, 134, 68, 2, 719, 721, 3, 2, 2, 2, 720, 717, 3, 2, 2, 2, 721, 722, 3,
	2, 2, 2, 722, 720, 3, 2, 2, 2, 722, 723, 3, 2, 2, 2, 723, 724, 3, 2, 2,
	2, 724, 725, 5, 178, 90, 2, 725, 746, 3, 2, 2, 2, 726, 730, 5, 180, 91,
	2, 727, 728, 5, 70, 36, 2, 728, 729, 5, 136, 69, 2, 729, 731, 3, 2, 2,
	2, 730, 727, 3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 730, 3, 2, 2, 2, 732,
	733, 3, 2, 2, 2, 733, 734, 3, 2, 2, 2, 734, 735, 5, 180, 91, 2, 735, 746,
	3, 2, 2, 2, 736, 737, 5, 70, 36, 2, 737, 738, 5, 140, 71, 2, 738, 740,
	3, 2, 2, 2, 739, 736, 3, 2, 2, 2, 740, 741, 3, 2, 2, 2, 741, 739, 3, 2,
	2, 2, 741, 742, 3, 2, 2, 2, 742, 743, 3, 2, 2, 2, 743, 744, 5, 70, 36,
	2, 744, 746, 3, 2, 2, 2, 745, 716, 3, 2, 2, 2, 745, 726, 3, 2, 2, 2, 745,
	739, 3, 2, 2, 2, 746, 133, 3, 2, 2, 2, 747, 748, 5, 180, 91, 2, 748, 749,
	5, 138, 70, 2, 749, 750, 5, 180, 91, 2, 750, 753, 3, 2, 2, 2, 751, 753,
	5, 140, 71, 2, 752, 747, 3, 2, 2, 2, 752, 751, 3, 2, 2, 2, 753, 135, 3,
	2, 2, 2, 754, 755, 5, 178, 90, 2, 755, 756, 5, 138, 70, 2, 756, 757, 5,
	178, 90, 2, 757, 760, 3, 2, 2, 2, 758, 760, 5, 140, 71, 2, 759, 754, 3,
	2, 2, 2, 759, 758, 3, 2, 2, 2, 760, 137, 3, 2, 2, 2, 761, 762, 5, 70, 36,
	2, 762, 763, 5, 140, 71, 2, 763, 765, 3, 2, 2, 2, 764, 761, 3, 2, 2, 2,
	765, 766, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766, 767, 3, 2, 2, 2, 767,
	768, 3, 2, 2, 2, 768, 769, 5, 70, 36, 2, 769, 139, 3, 2, 2, 2, 770, 774,
	10, 9, 2, 2, 771, 774, 5, 218, 110, 2, 772, 774, 5, 166, 84, 2, 773, 770,
	3, 2, 2, 2, 773, 771, 3, 2, 2, 2, 773, 772, 3, 2, 2, 2, 774, 775, 3, 2,
	2, 2, 775, 773, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 141, 3, 2, 2, 2,
	777, 779, 10, 8, 2, 2, 778, 777, 3, 2, 2, 2, 779, 780, 3, 2, 2, 2, 780,
	778, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 143, 3, 2, 2, 2, 782, 783,
	5, 210, 106, 2, 783, 785, 5, 146, 74, 2, 784, 786, 5, 148, 75, 2, 785,
	784, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 787, 3, 2, 2, 2, 787, 788,
	5, 212, 107, 2, 788, 145, 3, 2, 2, 2, 789, 791, 10, 10, 2, 2, 790, 789,
	3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 790, 3, 2, 2, 2, 792, 793, 3, 2,
	2, 2, 793, 147, 3, 2, 2, 2, 794, 796, 5, 214, 108, 2, 795, 797, 5, 150,
	76, 2, 796, 795, 3, 2, 2, 2, 797, 798, 3, 2, 2, 2, 798, 796, 3, 2, 2, 2,
	798, 799, 3, 2, 2, 2, 799, 149, 3, 2, 2, 2, 800, 804, 5, 178, 90, 2, 801,
	802, 5, 70, 36, 2, 802, 803, 5, 152, 77, 2, 803, 805, 3, 2, 2, 2, 804,
	801, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806, 804, 3, 2, 2, 2, 806, 807,
	3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 809, 5, 178, 90, 2, 809, 822, 3,
	2, 2, 2, 810, 814, 5, 180, 91, 2, 811, 812, 5, 70, 36, 2, 812, 813, 5,
	154, 78, 2, 813, 815, 3, 2, 2, 2, 814, 811, 3, 2, 2, 2, 815, 816, 3, 2,
	2, 2, 816, 814, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2, 817, 818, 3, 2, 2, 2,
	818, 819, 5, 180, 91, 2, 819, 822, 3, 2, 2, 2, 820, 822, 5, 158, 80, 2,
	821, 800, 3, 2, 2, 2, 821, 810, 3, 2, 2, 2, 821, 820, 3, 2, 2, 2, 822,
	151, 3, 2, 2, 2, 823, 824, 5, 180, 91, 2, 824, 825, 5, 138, 70, 2, 825,
	826, 5, 180, 91, 2, 826, 829, 3, 2, 2, 2, 827, 829, 5, 158, 80, 2, 828,
	823, 3, 2, 2, 2, 828, 827, 3, 2, 2, 2, 829, 153, 3, 2, 2, 2, 830, 831,
	5, 178, 90, 2, 831, 832, 5, 138, 70, 2, 832, 833, 5, 178, 90, 2, 833, 836,
	3, 2, 2, 2, 834, 836, 5, 158, 80, 2, 835, 830, 3, 2, 2, 2, 835, 834, 3,
	2, 2, 2, 836, 155, 3, 2, 2, 2, 837, 838, 5, 70, 36, 2, 838, 839, 5, 158,
	80, 2, 839, 841, 3, 2, 2, 2, 840, 837, 3, 2, 2, 2, 841, 842, 3, 2, 2, 2,
	842, 840, 3, 2, 2, 2, 842, 843, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844,
	845, 5, 70, 36, 2, 845, 157, 3, 2, 2, 2, 846, 849, 10, 11, 2, 2, 847, 849,
	5, 218, 110, 2, 848, 846, 3, 2, 2, 2, 848, 847, 3, 2, 2, 2, 849, 850, 3,
	2, 2, 2, 850, 848, 3, 2, 2, 2, 850, 851, 3, 2, 2, 2, 851, 159, 3, 2, 2,
	2, 852, 853, 5, 216, 109, 2, 853, 854, 5, 162, 82, 2, 854, 855, 5, 172,
	87, 2, 855, 856, 5, 164, 83, 2, 856, 857, 5, 216, 109, 2, 857, 161, 3,
	2, 2, 2, 858, 861, 10, 12, 2, 2, 859, 861, 5, 166, 84, 2, 860, 858, 3,
	2, 2, 2, 860, 859, 3, 2, 2, 2, 861, 862, 3, 2, 2, 2, 862, 860, 3, 2, 2,
	2, 862, 863, 3, 2, 2, 2, 863, 163, 3, 2, 2, 2, 864, 867, 10, 13, 2, 2,
	865, 867, 5, 166, 84, 2, 866, 864, 3, 2, 2, 2, 866, 865, 3, 2, 2, 2, 867,
	870, 3, 2, 2, 2, 868, 866, 3, 2, 2, 2, 868, 869, 3, 2, 2, 2, 869, 165,
	3, 2, 2, 2, 870, 868, 3, 2, 2, 2, 871, 872, 7, 6, 2, 2, 872, 873, 7, 23,
	2, 2, 873, 877, 7, 23, 2, 2, 874, 875, 7, 6, 2, 2, 875, 877, 11, 2, 2,
	2, 876, 871, 3, 2, 2, 2, 876, 874, 3, 2, 2, 2, 877, 167, 3, 2, 2, 2, 878,
	880, 5, 176, 89, 2, 879, 878, 3, 2, 2, 2, 880, 881, 3, 2, 2, 2, 881, 879,
	3, 2, 2, 2, 881, 882, 3, 2, 2, 2, 882, 885, 3, 2, 2, 2, 883, 885, 7, 2,
	2, 3, 884, 879, 3, 2, 2, 2, 884, 883, 3, 2, 2, 2, 885, 169, 3, 2, 2, 2,
	886, 889, 5, 172, 87, 2, 887, 889, 5, 176, 89, 2, 888, 886, 3, 2, 2, 2,
	888, 887, 3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 888, 3, 2, 2, 2, 890,
	891, 3, 2, 2, 2, 891, 171, 3, 2, 2, 2, 892, 893, 7, 9, 2, 2, 893, 173,
	3, 2, 2, 2, 894, 896, 5, 176, 89, 2, 895, 897, 5, 172, 87, 2, 896, 895,
	3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 900, 3, 2, 2, 2, 898, 900, 7, 2,
	2, 3, 899, 894, 3, 2, 2, 2, 899, 898, 3, 2, 2, 2, 900, 175, 3, 2, 2, 2,
	901, 902, 7, 8, 2, 2, 902, 177, 3, 2, 2, 2, 903, 904, 7, 23, 2, 2, 904,
	905, 7, 23, 2, 2, 905, 179, 3, 2, 2, 2, 906, 907, 7, 11, 2, 2, 907, 181,
	3, 2, 2, 2, 908, 909, 7, 19, 2, 2, 909, 183, 3, 2, 2, 2, 910, 911, 7, 21,
	2, 2, 911, 185, 3, 2, 2, 2, 912, 913, 7, 23, 2, 2, 913, 187, 3, 2, 2, 2,
	914, 916, 5, 176, 89, 2, 915, 917, 5, 172, 87, 2, 916, 915, 3, 2, 2, 2,
	916, 917, 3, 2, 2, 2, 917, 920, 3, 2, 2, 2, 918, 920, 7, 2, 2, 3, 919,
	914, 3, 2, 2, 2, 919, 918, 3, 2, 2, 2, 920, 189, 3, 2, 2, 2, 921, 924,
	5, 176, 89, 2, 922, 924, 7, 2, 2, 3, 923, 921, 3, 2, 2, 2, 923, 922, 3,
	2, 2, 2, 924, 191, 3, 2, 2, 2, 925, 926, 7, 20, 2, 2, 926, 193, 3, 2, 2,
	2, 927, 928, 7, 20, 2, 2, 928, 929, 7, 19, 2, 2, 929, 195, 3, 2, 2, 2,
	930, 933, 5, 176, 89, 2, 931, 933, 7, 2, 2, 3, 932, 930, 3, 2, 2, 2, 932,
	931, 3, 2, 2, 2, 933, 197, 3, 2, 2, 2, 934, 935, 7, 12, 2, 2, 935, 199,
	3, 2, 2, 2, 936, 937, 7, 13, 2, 2, 937, 201, 3, 2, 2, 2, 938, 939, 7, 22,
	2, 2, 939, 940, 7, 22, 2, 2, 940, 941, 7, 22, 2, 2, 941, 942, 7, 22, 2,
	2, 942, 203, 3, 2, 2, 2, 943, 944, 7, 14, 2, 2, 944, 205, 3, 2, 2, 2, 945,
	946, 7, 15, 2, 2, 946, 207, 3, 2, 2, 2, 947, 948, 7, 20, 2, 2, 948, 209,
	3, 2, 2, 2, 949, 950, 7, 16, 2, 2, 950, 211, 3, 2, 2, 2, 951, 952, 7, 17,
	2, 2, 952, 213, 3, 2, 2, 2, 953, 954, 7, 20, 2, 2, 954, 215, 3, 2, 2, 2,
	955, 956, 7, 25, 2, 2, 956, 217, 3, 2, 2, 2, 957, 958, 7, 18, 2, 2, 958,
	219, 3, 2, 2, 2, 141, 223, 231, 239, 248, 251, 253, 260, 265, 267, 273,
	281, 286, 289, 294, 297, 299, 302, 307, 311, 320, 325, 330, 334, 339, 342,
	347, 350, 353, 356, 359, 364, 368, 375, 380, 384, 389, 391, 395, 400, 402,
	407, 410, 417, 421, 423, 425, 430, 433, 441, 444, 452, 460, 465, 472, 480,
	484, 492, 496, 498, 502, 505, 510, 515, 517, 522, 527, 529, 534, 539, 544,
	547, 554, 565, 568, 574, 578, 581, 585, 588, 590, 597, 600, 605, 608, 614,
	616, 621, 624, 627, 630, 635, 641, 645, 650, 652, 658, 673, 680, 689, 698,
	706, 712, 714, 722, 732, 741, 745, 752, 759, 766, 773, 775, 780, 785, 792,
	798, 806, 816, 821, 828, 835, 842, 848, 850, 860, 862, 866, 868, 876, 881,
	884, 888, 890, 896, 899, 916, 919, 923, 932,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "':'", "'C'", "'2'", "'~'", "", "", "", "", "'//'", "'{{{'", "'}}}'",
	"'[['", "']]'", "'{{'", "'}}'", "'\\\\'", "'='", "'|'", "'#'", "'-'", "'*'",
	"'/'", "'@@'",
}
var symbolicNames = []string{
	"", "", "", "", "ESCAPE", "NOWIKI_BLOCK_CLOSE", "NEWLINE", "BLANKS", "COLON_SLASH",
	"ITAL", "NOWIKI_OPEN", "NOWIKI_CLOSE", "LINK_OPEN", "LINK_CLOSE", "IMAGE_OPEN",
	"IMAGE_CLOSE", "FORCED_LINEBREAK", "EQUAL", "PIPE", "POUND", "DASH", "STAR",
	"SLASH", "EXTENSION", "INSIGNIFICANT_CHAR",
}

var ruleNames = []string{
	"start", "wikipage", "paragraphs", "paragraph", "text_paragraph", "text_line",
	"text_firstelement", "text_formattedelement", "text_boldcontent", "text_element",
	"nachmarkup", "text_italcontent", "text_boldcontentpart", "text_italcontentpart",
	"text_bolditalcontent", "text_formattedcontent", "text_lineseparator1",
	"text_inlineelement", "text_first_inlineelement", "text_first_unformattedelement",
	"text_first_unformatted", "text_unformattedelement", "text_unformatted",
	"heading", "heading_content", "list_ord", "list_ordelem", "list_unord",
	"list_unordelem", "list_elem", "list_elem_markup", "list_elemcontent",
	"list_elemcontentpart", "list_formatted_elem", "onestar", "list_boldcontentpart",
	"list_italcontentpart", "list_bolditalcontent", "table", "table_row", "table_cell",
	"table_headercell", "table_normalcell", "table_cellcontent", "table_cellcontentpart",
	"table_formattedelement", "table_boldcontent", "table_italcontent", "table_boldcontentpart",
	"table_italcontentpart", "table_bolditalcontent", "table_formattedcontent",
	"table_inlineelement", "table_unformattedelement", "table_unformatted",
	"nowiki_block", "nowikiblock_open_markup", "nowikiblock_close_markup",
	"nowiki_inline", "horizontalrule", "link", "link_address", "link_interwiki_uri",
	"link_interwiki_pagename", "link_description", "link_descriptionpart",
	"link_bold_descriptionpart", "link_ital_descriptionpart", "link_boldital_description",
	"link_descriptiontext", "link_uri", "image", "image_uri", "image_alternative",
	"image_alternativepart", "image_bold_alternativepart", "image_ital_alternativepart",
	"image_boldital_alternative", "image_alternativetext", "extension", "extension_handler",
	"extension_statement", "escaped", "paragraph_separator", "whitespaces",
	"blanks", "text_lineseparator", "newline", "bold_markup", "ital_markup",
	"heading_markup", "list_ordelem_markup", "list_unordelem_markup", "list_elemseparator",
	"end_of_list", "table_cell_markup", "table_headercell_markup", "table_rowseparator",
	"nowiki_open_markup", "nowiki_close_markup", "horizontalrule_markup", "link_open_markup",
	"link_close_markup", "link_description_markup", "image_open_markup", "image_close_markup",
	"image_alternative_markup", "extension_markup", "forced_linebreak",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Creole10Parser struct {
	*antlr.BaseParser
}

func NewCreole10Parser(input antlr.TokenStream) *Creole10Parser {
	this := new(Creole10Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Creole10.g4"

	return this
}

// Creole10Parser tokens.
const (
	Creole10ParserEOF                = antlr.TokenEOF
	Creole10ParserT__0               = 1
	Creole10ParserT__1               = 2
	Creole10ParserT__2               = 3
	Creole10ParserESCAPE             = 4
	Creole10ParserNOWIKI_BLOCK_CLOSE = 5
	Creole10ParserNEWLINE            = 6
	Creole10ParserBLANKS             = 7
	Creole10ParserCOLON_SLASH        = 8
	Creole10ParserITAL               = 9
	Creole10ParserNOWIKI_OPEN        = 10
	Creole10ParserNOWIKI_CLOSE       = 11
	Creole10ParserLINK_OPEN          = 12
	Creole10ParserLINK_CLOSE         = 13
	Creole10ParserIMAGE_OPEN         = 14
	Creole10ParserIMAGE_CLOSE        = 15
	Creole10ParserFORCED_LINEBREAK   = 16
	Creole10ParserEQUAL              = 17
	Creole10ParserPIPE               = 18
	Creole10ParserPOUND              = 19
	Creole10ParserDASH               = 20
	Creole10ParserSTAR               = 21
	Creole10ParserSLASH              = 22
	Creole10ParserEXTENSION          = 23
	Creole10ParserINSIGNIFICANT_CHAR = 24
)

// Creole10Parser rules.
const (
	Creole10ParserRULE_start                         = 0
	Creole10ParserRULE_wikipage                      = 1
	Creole10ParserRULE_paragraphs                    = 2
	Creole10ParserRULE_paragraph                     = 3
	Creole10ParserRULE_text_paragraph                = 4
	Creole10ParserRULE_text_line                     = 5
	Creole10ParserRULE_text_firstelement             = 6
	Creole10ParserRULE_text_formattedelement         = 7
	Creole10ParserRULE_text_boldcontent              = 8
	Creole10ParserRULE_text_element                  = 9
	Creole10ParserRULE_nachmarkup                    = 10
	Creole10ParserRULE_text_italcontent              = 11
	Creole10ParserRULE_text_boldcontentpart          = 12
	Creole10ParserRULE_text_italcontentpart          = 13
	Creole10ParserRULE_text_bolditalcontent          = 14
	Creole10ParserRULE_text_formattedcontent         = 15
	Creole10ParserRULE_text_lineseparator1           = 16
	Creole10ParserRULE_text_inlineelement            = 17
	Creole10ParserRULE_text_first_inlineelement      = 18
	Creole10ParserRULE_text_first_unformattedelement = 19
	Creole10ParserRULE_text_first_unformatted        = 20
	Creole10ParserRULE_text_unformattedelement       = 21
	Creole10ParserRULE_text_unformatted              = 22
	Creole10ParserRULE_heading                       = 23
	Creole10ParserRULE_heading_content               = 24
	Creole10ParserRULE_list_ord                      = 25
	Creole10ParserRULE_list_ordelem                  = 26
	Creole10ParserRULE_list_unord                    = 27
	Creole10ParserRULE_list_unordelem                = 28
	Creole10ParserRULE_list_elem                     = 29
	Creole10ParserRULE_list_elem_markup              = 30
	Creole10ParserRULE_list_elemcontent              = 31
	Creole10ParserRULE_list_elemcontentpart          = 32
	Creole10ParserRULE_list_formatted_elem           = 33
	Creole10ParserRULE_onestar                       = 34
	Creole10ParserRULE_list_boldcontentpart          = 35
	Creole10ParserRULE_list_italcontentpart          = 36
	Creole10ParserRULE_list_bolditalcontent          = 37
	Creole10ParserRULE_table                         = 38
	Creole10ParserRULE_table_row                     = 39
	Creole10ParserRULE_table_cell                    = 40
	Creole10ParserRULE_table_headercell              = 41
	Creole10ParserRULE_table_normalcell              = 42
	Creole10ParserRULE_table_cellcontent             = 43
	Creole10ParserRULE_table_cellcontentpart         = 44
	Creole10ParserRULE_table_formattedelement        = 45
	Creole10ParserRULE_table_boldcontent             = 46
	Creole10ParserRULE_table_italcontent             = 47
	Creole10ParserRULE_table_boldcontentpart         = 48
	Creole10ParserRULE_table_italcontentpart         = 49
	Creole10ParserRULE_table_bolditalcontent         = 50
	Creole10ParserRULE_table_formattedcontent        = 51
	Creole10ParserRULE_table_inlineelement           = 52
	Creole10ParserRULE_table_unformattedelement      = 53
	Creole10ParserRULE_table_unformatted             = 54
	Creole10ParserRULE_nowiki_block                  = 55
	Creole10ParserRULE_nowikiblock_open_markup       = 56
	Creole10ParserRULE_nowikiblock_close_markup      = 57
	Creole10ParserRULE_nowiki_inline                 = 58
	Creole10ParserRULE_horizontalrule                = 59
	Creole10ParserRULE_link                          = 60
	Creole10ParserRULE_link_address                  = 61
	Creole10ParserRULE_link_interwiki_uri            = 62
	Creole10ParserRULE_link_interwiki_pagename       = 63
	Creole10ParserRULE_link_description              = 64
	Creole10ParserRULE_link_descriptionpart          = 65
	Creole10ParserRULE_link_bold_descriptionpart     = 66
	Creole10ParserRULE_link_ital_descriptionpart     = 67
	Creole10ParserRULE_link_boldital_description     = 68
	Creole10ParserRULE_link_descriptiontext          = 69
	Creole10ParserRULE_link_uri                      = 70
	Creole10ParserRULE_image                         = 71
	Creole10ParserRULE_image_uri                     = 72
	Creole10ParserRULE_image_alternative             = 73
	Creole10ParserRULE_image_alternativepart         = 74
	Creole10ParserRULE_image_bold_alternativepart    = 75
	Creole10ParserRULE_image_ital_alternativepart    = 76
	Creole10ParserRULE_image_boldital_alternative    = 77
	Creole10ParserRULE_image_alternativetext         = 78
	Creole10ParserRULE_extension                     = 79
	Creole10ParserRULE_extension_handler             = 80
	Creole10ParserRULE_extension_statement           = 81
	Creole10ParserRULE_escaped                       = 82
	Creole10ParserRULE_paragraph_separator           = 83
	Creole10ParserRULE_whitespaces                   = 84
	Creole10ParserRULE_blanks                        = 85
	Creole10ParserRULE_text_lineseparator            = 86
	Creole10ParserRULE_newline                       = 87
	Creole10ParserRULE_bold_markup                   = 88
	Creole10ParserRULE_ital_markup                   = 89
	Creole10ParserRULE_heading_markup                = 90
	Creole10ParserRULE_list_ordelem_markup           = 91
	Creole10ParserRULE_list_unordelem_markup         = 92
	Creole10ParserRULE_list_elemseparator            = 93
	Creole10ParserRULE_end_of_list                   = 94
	Creole10ParserRULE_table_cell_markup             = 95
	Creole10ParserRULE_table_headercell_markup       = 96
	Creole10ParserRULE_table_rowseparator            = 97
	Creole10ParserRULE_nowiki_open_markup            = 98
	Creole10ParserRULE_nowiki_close_markup           = 99
	Creole10ParserRULE_horizontalrule_markup         = 100
	Creole10ParserRULE_link_open_markup              = 101
	Creole10ParserRULE_link_close_markup             = 102
	Creole10ParserRULE_link_description_markup       = 103
	Creole10ParserRULE_image_open_markup             = 104
	Creole10ParserRULE_image_close_markup            = 105
	Creole10ParserRULE_image_alternative_markup      = 106
	Creole10ParserRULE_extension_markup              = 107
	Creole10ParserRULE_forced_linebreak              = 108
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Wikipage() IWikipageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWikipageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWikipageContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitStart(s)
	}
}

func (p *Creole10Parser) Start() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Creole10ParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.Wikipage()
	}

	return localctx
}

// IWikipageContext is an interface to support dynamic dispatch.
type IWikipageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWikipageContext differentiates from other interfaces.
	IsWikipageContext()
}

type WikipageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWikipageContext() *WikipageContext {
	var p = new(WikipageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_wikipage
	return p
}

func (*WikipageContext) IsWikipageContext() {}

func NewWikipageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WikipageContext {
	var p = new(WikipageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_wikipage

	return p
}

func (s *WikipageContext) GetParser() antlr.Parser { return s.parser }

func (s *WikipageContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *WikipageContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *WikipageContext) Whitespaces() IWhitespacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhitespacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhitespacesContext)
}

func (s *WikipageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WikipageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WikipageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterWikipage(s)
	}
}

func (s *WikipageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitWikipage(s)
	}
}

func (p *Creole10Parser) Wikipage() (localctx IWikipageContext) {
	localctx = NewWikipageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Creole10ParserRULE_wikipage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(221)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(220)
			p.Whitespaces()
		}

	}
	{
		p.SetState(223)
		p.Paragraphs()
	}
	{
		p.SetState(224)
		p.Match(Creole10ParserEOF)
	}

	return localctx
}

// IParagraphsContext is an interface to support dynamic dispatch.
type IParagraphsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphsContext differentiates from other interfaces.
	IsParagraphsContext()
}

type ParagraphsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphsContext() *ParagraphsContext {
	var p = new(ParagraphsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_paragraphs
	return p
}

func (*ParagraphsContext) IsParagraphsContext() {}

func NewParagraphsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphsContext {
	var p = new(ParagraphsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_paragraphs

	return p
}

func (s *ParagraphsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphsContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *ParagraphsContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ParagraphsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterParagraphs(s)
	}
}

func (s *ParagraphsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitParagraphs(s)
	}
}

func (p *Creole10Parser) Paragraphs() (localctx IParagraphsContext) {
	localctx = NewParagraphsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Creole10ParserRULE_paragraphs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(226)
				p.Paragraph()
			}

		}
		p.SetState(231)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}

	return localctx
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_paragraph
	return p
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) Nowiki_block() INowiki_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_blockContext)
}

func (s *ParagraphContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *ParagraphContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *ParagraphContext) Heading() IHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeadingContext)
}

func (s *ParagraphContext) Horizontalrule() IHorizontalruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHorizontalruleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHorizontalruleContext)
}

func (s *ParagraphContext) List_unord() IList_unordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_unordContext)
}

func (s *ParagraphContext) List_ord() IList_ordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ordContext)
}

func (s *ParagraphContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *ParagraphContext) Text_paragraph() IText_paragraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_paragraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_paragraphContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (p *Creole10Parser) Paragraph() (localctx IParagraphContext) {
	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Creole10ParserRULE_paragraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(232)
			p.Nowiki_block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(233)
			p.Blanks()
		}
		{
			p.SetState(234)
			p.Paragraph_separator()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(237)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(236)
				p.Blanks()
			}

		}
		p.SetState(246)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(239)
				p.Heading()
			}

		case 2:
			p.SetState(240)

			if !(p.GetInputStream().LA(1) == Creole10ParserDASH && p.GetInputStream().LA(2) == Creole10ParserDASH && p.GetInputStream().LA(3) == Creole10ParserDASH && p.GetInputStream().LA(4) == Creole10ParserDASH) {
				panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(1)==Creole10ParserDASH && p.GetInputStream().LA(2)==Creole10ParserDASH && p.GetInputStream().LA(3)==Creole10ParserDASH && p.GetInputStream().LA(4)==Creole10ParserDASH", ""))
			}
			{
				p.SetState(241)
				p.Horizontalrule()
			}

		case 3:
			{
				p.SetState(242)
				p.List_unord()
			}

		case 4:
			{
				p.SetState(243)
				p.List_ord()
			}

		case 5:
			{
				p.SetState(244)
				p.Table()
			}

		case 6:
			{
				p.SetState(245)
				p.Text_paragraph()
			}

		}
		p.SetState(249)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(248)
				p.Paragraph_separator()
			}

		}

	}

	return localctx
}

// IText_paragraphContext is an interface to support dynamic dispatch.
type IText_paragraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_paragraphContext differentiates from other interfaces.
	IsText_paragraphContext()
}

type Text_paragraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_paragraphContext() *Text_paragraphContext {
	var p = new(Text_paragraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_paragraph
	return p
}

func (*Text_paragraphContext) IsText_paragraphContext() {}

func NewText_paragraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_paragraphContext {
	var p = new(Text_paragraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_paragraph

	return p
}

func (s *Text_paragraphContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_paragraphContext) AllText_line() []IText_lineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_lineContext)(nil)).Elem())
	var tst = make([]IText_lineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_lineContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Text_line(i int) IText_lineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_lineContext)
}

func (s *Text_paragraphContext) AllNowiki_inline() []INowiki_inlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem())
	var tst = make([]INowiki_inlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INowiki_inlineContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Nowiki_inline(i int) INowiki_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INowiki_inlineContext)
}

func (s *Text_paragraphContext) AllText_lineseparator() []IText_lineseparatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem())
	var tst = make([]IText_lineseparatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_lineseparatorContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Text_lineseparator(i int) IText_lineseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparatorContext)
}

func (s *Text_paragraphContext) AllText_element() []IText_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_elementContext)(nil)).Elem())
	var tst = make([]IText_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_elementContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Text_element(i int) IText_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_elementContext)
}

func (s *Text_paragraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_paragraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_paragraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_paragraph(s)
	}
}

func (s *Text_paragraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_paragraph(s)
	}
}

func (p *Creole10Parser) Text_paragraph() (localctx IText_paragraphContext) {
	localctx = NewText_paragraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Creole10ParserRULE_text_paragraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(263)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(253)
					p.Text_line()
				}

			case 2:
				{
					p.SetState(254)
					p.Nowiki_inline()
				}
				p.SetState(258)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(255)
							p.Text_element()
						}

					}
					p.SetState(260)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
				}

				{
					p.SetState(261)
					p.Text_lineseparator()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IText_lineContext is an interface to support dynamic dispatch.
type IText_lineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_lineContext differentiates from other interfaces.
	IsText_lineContext()
}

type Text_lineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_lineContext() *Text_lineContext {
	var p = new(Text_lineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_line
	return p
}

func (*Text_lineContext) IsText_lineContext() {}

func NewText_lineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_lineContext {
	var p = new(Text_lineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_line

	return p
}

func (s *Text_lineContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_lineContext) Text_firstelement() IText_firstelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_firstelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_firstelementContext)
}

func (s *Text_lineContext) Text_lineseparator() IText_lineseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparatorContext)
}

func (s *Text_lineContext) AllText_element() []IText_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_elementContext)(nil)).Elem())
	var tst = make([]IText_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_elementContext)
		}
	}

	return tst
}

func (s *Text_lineContext) Text_element(i int) IText_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_elementContext)
}

func (s *Text_lineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_lineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_lineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_line(s)
	}
}

func (s *Text_lineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_line(s)
	}
}

func (p *Creole10Parser) Text_line() (localctx IText_lineContext) {
	localctx = NewText_lineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Creole10ParserRULE_text_line)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Text_firstelement()
	}
	p.SetState(271)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(268)
				p.Text_element()
			}

		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}

	{
		p.SetState(274)
		p.Text_lineseparator()
	}

	return localctx
}

// IText_firstelementContext is an interface to support dynamic dispatch.
type IText_firstelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_firstelementContext differentiates from other interfaces.
	IsText_firstelementContext()
}

type Text_firstelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_firstelementContext() *Text_firstelementContext {
	var p = new(Text_firstelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_firstelement
	return p
}

func (*Text_firstelementContext) IsText_firstelementContext() {}

func NewText_firstelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_firstelementContext {
	var p = new(Text_firstelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_firstelement

	return p
}

func (s *Text_firstelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_firstelementContext) Text_formattedelement() IText_formattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedelementContext)
}

func (s *Text_firstelementContext) Text_first_unformattedelement() IText_first_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_unformattedelementContext)
}

func (s *Text_firstelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_firstelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_firstelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_firstelement(s)
	}
}

func (s *Text_firstelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_firstelement(s)
	}
}

func (p *Creole10Parser) Text_firstelement() (localctx IText_firstelementContext) {
	localctx = NewText_firstelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Creole10ParserRULE_text_firstelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(276)

		if !(p.GetInputStream().LA(1) != Creole10ParserSTAR || (p.GetInputStream().LA(1) == Creole10ParserSTAR && p.GetInputStream().LA(2) == Creole10ParserSTAR)) {
			panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(1) != Creole10ParserSTAR || (p.GetInputStream().LA(1) == Creole10ParserSTAR && p.GetInputStream().LA(2) == Creole10ParserSTAR)", ""))
		}
		{
			p.SetState(277)
			p.Text_formattedelement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(278)
			p.Text_first_unformattedelement()
		}

	}

	return localctx
}

// IText_formattedelementContext is an interface to support dynamic dispatch.
type IText_formattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_formattedelementContext differentiates from other interfaces.
	IsText_formattedelementContext()
}

type Text_formattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_formattedelementContext() *Text_formattedelementContext {
	var p = new(Text_formattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_formattedelement
	return p
}

func (*Text_formattedelementContext) IsText_formattedelementContext() {}

func NewText_formattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_formattedelementContext {
	var p = new(Text_formattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_formattedelement

	return p
}

func (s *Text_formattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_formattedelementContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Text_formattedelementContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Text_formattedelementContext) Text_italcontent() IText_italcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_italcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_italcontentContext)
}

func (s *Text_formattedelementContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, 0)
}

func (s *Text_formattedelementContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Text_formattedelementContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Text_formattedelementContext) Text_boldcontent() IText_boldcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_boldcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_boldcontentContext)
}

func (s *Text_formattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_formattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_formattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_formattedelement(s)
	}
}

func (s *Text_formattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_formattedelement(s)
	}
}

func (p *Creole10Parser) Text_formattedelement() (localctx IText_formattedelementContext) {
	localctx = NewText_formattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Creole10ParserRULE_text_formattedelement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(281)
			p.Ital_markup()
		}
		{
			p.SetState(282)
			p.Text_italcontent()
		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
			p.SetState(284)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Creole10ParserNEWLINE {
				{
					p.SetState(283)
					p.Match(Creole10ParserNEWLINE)
				}

			}
			{
				p.SetState(286)
				p.Ital_markup()
			}

		}

	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(289)
			p.Bold_markup()
		}
		{
			p.SetState(290)
			p.Text_boldcontent()
		}
		p.SetState(295)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			p.SetState(292)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Creole10ParserNEWLINE {
				{
					p.SetState(291)
					p.Match(Creole10ParserNEWLINE)
				}

			}
			{
				p.SetState(294)
				p.Bold_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_boldcontentContext is an interface to support dynamic dispatch.
type IText_boldcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_boldcontentContext differentiates from other interfaces.
	IsText_boldcontentContext()
}

type Text_boldcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_boldcontentContext() *Text_boldcontentContext {
	var p = new(Text_boldcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_boldcontent
	return p
}

func (*Text_boldcontentContext) IsText_boldcontentContext() {}

func NewText_boldcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_boldcontentContext {
	var p = new(Text_boldcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_boldcontent

	return p
}

func (s *Text_boldcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_boldcontentContext) Nachmarkup() INachmarkupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INachmarkupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INachmarkupContext)
}

func (s *Text_boldcontentContext) AllText_boldcontentpart() []IText_boldcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_boldcontentpartContext)(nil)).Elem())
	var tst = make([]IText_boldcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_boldcontentpartContext)
		}
	}

	return tst
}

func (s *Text_boldcontentContext) Text_boldcontentpart(i int) IText_boldcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_boldcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_boldcontentpartContext)
}

func (s *Text_boldcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_boldcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_boldcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_boldcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_boldcontent(s)
	}
}

func (s *Text_boldcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_boldcontent(s)
	}
}

func (p *Creole10Parser) Text_boldcontent() (localctx IText_boldcontentContext) {
	localctx = NewText_boldcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Creole10ParserRULE_text_boldcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(300)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(299)
				p.Nachmarkup()
			}

		}
		p.SetState(305)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(302)
					p.Text_boldcontentpart()
				}

			}
			p.SetState(307)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(308)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// IText_elementContext is an interface to support dynamic dispatch.
type IText_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_elementContext differentiates from other interfaces.
	IsText_elementContext()
}

type Text_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_elementContext() *Text_elementContext {
	var p = new(Text_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_element
	return p
}

func (*Text_elementContext) IsText_elementContext() {}

func NewText_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_elementContext {
	var p = new(Text_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_element

	return p
}

func (s *Text_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_elementContext) Onestar() IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Text_elementContext) Text_unformattedelement() IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *Text_elementContext) Text_formattedelement() IText_formattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedelementContext)
}

func (s *Text_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_element(s)
	}
}

func (s *Text_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_element(s)
	}
}

func (p *Creole10Parser) Text_element() (localctx IText_elementContext) {
	localctx = NewText_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Creole10ParserRULE_text_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(311)
			p.Onestar()
		}
		{
			p.SetState(312)
			p.Text_unformattedelement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(314)
			p.Text_unformattedelement()
		}
		{
			p.SetState(315)
			p.Onestar()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(317)
			p.Text_formattedelement()
		}

	}

	return localctx
}

// INachmarkupContext is an interface to support dynamic dispatch.
type INachmarkupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNachmarkupContext differentiates from other interfaces.
	IsNachmarkupContext()
}

type NachmarkupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNachmarkupContext() *NachmarkupContext {
	var p = new(NachmarkupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nachmarkup
	return p
}

func (*NachmarkupContext) IsNachmarkupContext() {}

func NewNachmarkupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NachmarkupContext {
	var p = new(NachmarkupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nachmarkup

	return p
}

func (s *NachmarkupContext) GetParser() antlr.Parser { return s.parser }

func (s *NachmarkupContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, 0)
}

func (s *NachmarkupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NachmarkupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NachmarkupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNachmarkup(s)
	}
}

func (s *NachmarkupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNachmarkup(s)
	}
}

func (p *Creole10Parser) Nachmarkup() (localctx INachmarkupContext) {
	localctx = NewNachmarkupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Creole10ParserRULE_nachmarkup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(320)
		p.Match(Creole10ParserNEWLINE)
	}

	return localctx
}

// IText_italcontentContext is an interface to support dynamic dispatch.
type IText_italcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_italcontentContext differentiates from other interfaces.
	IsText_italcontentContext()
}

type Text_italcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_italcontentContext() *Text_italcontentContext {
	var p = new(Text_italcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_italcontent
	return p
}

func (*Text_italcontentContext) IsText_italcontentContext() {}

func NewText_italcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_italcontentContext {
	var p = new(Text_italcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_italcontent

	return p
}

func (s *Text_italcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_italcontentContext) Nachmarkup() INachmarkupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INachmarkupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INachmarkupContext)
}

func (s *Text_italcontentContext) AllText_italcontentpart() []IText_italcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_italcontentpartContext)(nil)).Elem())
	var tst = make([]IText_italcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_italcontentpartContext)
		}
	}

	return tst
}

func (s *Text_italcontentContext) Text_italcontentpart(i int) IText_italcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_italcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_italcontentpartContext)
}

func (s *Text_italcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_italcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_italcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_italcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_italcontent(s)
	}
}

func (s *Text_italcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_italcontent(s)
	}
}

func (p *Creole10Parser) Text_italcontent() (localctx IText_italcontentContext) {
	localctx = NewText_italcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Creole10ParserRULE_text_italcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(322)
				p.Nachmarkup()
			}

		}
		p.SetState(328)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(325)
					p.Text_italcontentpart()
				}

			}
			p.SetState(330)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(331)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// IText_boldcontentpartContext is an interface to support dynamic dispatch.
type IText_boldcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_boldcontentpartContext differentiates from other interfaces.
	IsText_boldcontentpartContext()
}

type Text_boldcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_boldcontentpartContext() *Text_boldcontentpartContext {
	var p = new(Text_boldcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_boldcontentpart
	return p
}

func (*Text_boldcontentpartContext) IsText_boldcontentpartContext() {}

func NewText_boldcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_boldcontentpartContext {
	var p = new(Text_boldcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_boldcontentpart

	return p
}

func (s *Text_boldcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_boldcontentpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Text_boldcontentpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Text_boldcontentpartContext) Text_bolditalcontent() IText_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_bolditalcontentContext)
}

func (s *Text_boldcontentpartContext) Text_formattedcontent() IText_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedcontentContext)
}

func (s *Text_boldcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_boldcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_boldcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_boldcontentpart(s)
	}
}

func (s *Text_boldcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_boldcontentpart(s)
	}
}

func (p *Creole10Parser) Text_boldcontentpart() (localctx IText_boldcontentpartContext) {
	localctx = NewText_boldcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Creole10ParserRULE_text_boldcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(334)
			p.Ital_markup()
		}
		{
			p.SetState(335)
			p.Text_bolditalcontent()
		}
		p.SetState(337)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(336)
				p.Ital_markup()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(339)
			p.Text_formattedcontent()
		}

	}

	return localctx
}

// IText_italcontentpartContext is an interface to support dynamic dispatch.
type IText_italcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_italcontentpartContext differentiates from other interfaces.
	IsText_italcontentpartContext()
}

type Text_italcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_italcontentpartContext() *Text_italcontentpartContext {
	var p = new(Text_italcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_italcontentpart
	return p
}

func (*Text_italcontentpartContext) IsText_italcontentpartContext() {}

func NewText_italcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_italcontentpartContext {
	var p = new(Text_italcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_italcontentpart

	return p
}

func (s *Text_italcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_italcontentpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Text_italcontentpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Text_italcontentpartContext) Text_bolditalcontent() IText_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_bolditalcontentContext)
}

func (s *Text_italcontentpartContext) Text_formattedcontent() IText_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedcontentContext)
}

func (s *Text_italcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_italcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_italcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_italcontentpart(s)
	}
}

func (s *Text_italcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_italcontentpart(s)
	}
}

func (p *Creole10Parser) Text_italcontentpart() (localctx IText_italcontentpartContext) {
	localctx = NewText_italcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Creole10ParserRULE_text_italcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(342)
			p.Bold_markup()
		}
		{
			p.SetState(343)
			p.Text_bolditalcontent()
		}
		p.SetState(345)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(344)
				p.Bold_markup()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(347)
			p.Text_formattedcontent()
		}

	}

	return localctx
}

// IText_bolditalcontentContext is an interface to support dynamic dispatch.
type IText_bolditalcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_bolditalcontentContext differentiates from other interfaces.
	IsText_bolditalcontentContext()
}

type Text_bolditalcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_bolditalcontentContext() *Text_bolditalcontentContext {
	var p = new(Text_bolditalcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_bolditalcontent
	return p
}

func (*Text_bolditalcontentContext) IsText_bolditalcontentContext() {}

func NewText_bolditalcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_bolditalcontentContext {
	var p = new(Text_bolditalcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_bolditalcontent

	return p
}

func (s *Text_bolditalcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_bolditalcontentContext) Nachmarkup() INachmarkupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INachmarkupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INachmarkupContext)
}

func (s *Text_bolditalcontentContext) Text_formattedcontent() IText_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedcontentContext)
}

func (s *Text_bolditalcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_bolditalcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_bolditalcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_bolditalcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_bolditalcontent(s)
	}
}

func (s *Text_bolditalcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_bolditalcontent(s)
	}
}

func (p *Creole10Parser) Text_bolditalcontent() (localctx IText_bolditalcontentContext) {
	localctx = NewText_bolditalcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Creole10ParserRULE_text_bolditalcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(351)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(350)
				p.Nachmarkup()
			}

		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(353)
				p.Text_formattedcontent()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(356)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// IText_formattedcontentContext is an interface to support dynamic dispatch.
type IText_formattedcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_formattedcontentContext differentiates from other interfaces.
	IsText_formattedcontentContext()
}

type Text_formattedcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_formattedcontentContext() *Text_formattedcontentContext {
	var p = new(Text_formattedcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_formattedcontent
	return p
}

func (*Text_formattedcontentContext) IsText_formattedcontentContext() {}

func NewText_formattedcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_formattedcontentContext {
	var p = new(Text_formattedcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_formattedcontent

	return p
}

func (s *Text_formattedcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_formattedcontentContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Text_formattedcontentContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Text_formattedcontentContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *Text_formattedcontentContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *Text_formattedcontentContext) AllText_lineseparator1() []IText_lineseparator1Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_lineseparator1Context)(nil)).Elem())
	var tst = make([]IText_lineseparator1Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_lineseparator1Context)
		}
	}

	return tst
}

func (s *Text_formattedcontentContext) Text_lineseparator1(i int) IText_lineseparator1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparator1Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparator1Context)
}

func (s *Text_formattedcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_formattedcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_formattedcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_formattedcontent(s)
	}
}

func (s *Text_formattedcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_formattedcontent(s)
	}
}

func (p *Creole10Parser) Text_formattedcontent() (localctx IText_formattedcontentContext) {
	localctx = NewText_formattedcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Creole10ParserRULE_text_formattedcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(359)
				p.Onestar()
			}
			{
				p.SetState(360)
				p.Text_unformattedelement()
			}
			p.SetState(362)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(361)
					p.Text_lineseparator1()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IText_lineseparator1Context is an interface to support dynamic dispatch.
type IText_lineseparator1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_lineseparator1Context differentiates from other interfaces.
	IsText_lineseparator1Context()
}

type Text_lineseparator1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_lineseparator1Context() *Text_lineseparator1Context {
	var p = new(Text_lineseparator1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_lineseparator1
	return p
}

func (*Text_lineseparator1Context) IsText_lineseparator1Context() {}

func NewText_lineseparator1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_lineseparator1Context {
	var p = new(Text_lineseparator1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_lineseparator1

	return p
}

func (s *Text_lineseparator1Context) GetParser() antlr.Parser { return s.parser }

func (s *Text_lineseparator1Context) Text_lineseparator() IText_lineseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparatorContext)
}

func (s *Text_lineseparator1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_lineseparator1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_lineseparator1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_lineseparator1(s)
	}
}

func (s *Text_lineseparator1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_lineseparator1(s)
	}
}

func (p *Creole10Parser) Text_lineseparator1() (localctx IText_lineseparator1Context) {
	localctx = NewText_lineseparator1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Creole10ParserRULE_text_lineseparator1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(368)

	if !(p.GetInputStream().LA(2) != Creole10ParserDASH && p.GetInputStream().LA(2) != Creole10ParserPOUND && p.GetInputStream().LA(2) != Creole10ParserEQUAL && p.GetInputStream().LA(2) != Creole10ParserNEWLINE) {
		panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(2) != Creole10ParserDASH && p.GetInputStream().LA(2) != Creole10ParserPOUND && p.GetInputStream().LA(2) != Creole10ParserEQUAL && p.GetInputStream().LA(2) != Creole10ParserNEWLINE", ""))
	}
	{
		p.SetState(369)
		p.Text_lineseparator()
	}

	return localctx
}

// IText_inlineelementContext is an interface to support dynamic dispatch.
type IText_inlineelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_inlineelementContext differentiates from other interfaces.
	IsText_inlineelementContext()
}

type Text_inlineelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_inlineelementContext() *Text_inlineelementContext {
	var p = new(Text_inlineelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_inlineelement
	return p
}

func (*Text_inlineelementContext) IsText_inlineelementContext() {}

func NewText_inlineelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_inlineelementContext {
	var p = new(Text_inlineelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_inlineelement

	return p
}

func (s *Text_inlineelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_inlineelementContext) Text_first_inlineelement() IText_first_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_inlineelementContext)
}

func (s *Text_inlineelementContext) Nowiki_inline() INowiki_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_inlineContext)
}

func (s *Text_inlineelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_inlineelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_inlineelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_inlineelement(s)
	}
}

func (s *Text_inlineelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_inlineelement(s)
	}
}

func (p *Creole10Parser) Text_inlineelement() (localctx IText_inlineelementContext) {
	localctx = NewText_inlineelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Creole10ParserRULE_text_inlineelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(373)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(371)
			p.Text_first_inlineelement()
		}

	case Creole10ParserNOWIKI_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(372)
			p.Nowiki_inline()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_first_inlineelementContext is an interface to support dynamic dispatch.
type IText_first_inlineelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_first_inlineelementContext differentiates from other interfaces.
	IsText_first_inlineelementContext()
}

type Text_first_inlineelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_first_inlineelementContext() *Text_first_inlineelementContext {
	var p = new(Text_first_inlineelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_first_inlineelement
	return p
}

func (*Text_first_inlineelementContext) IsText_first_inlineelementContext() {}

func NewText_first_inlineelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_first_inlineelementContext {
	var p = new(Text_first_inlineelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_first_inlineelement

	return p
}

func (s *Text_first_inlineelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_first_inlineelementContext) Link() ILinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkContext)
}

func (s *Text_first_inlineelementContext) Image() IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *Text_first_inlineelementContext) Extension() IExtensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionContext)
}

func (s *Text_first_inlineelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_first_inlineelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_first_inlineelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_first_inlineelement(s)
	}
}

func (s *Text_first_inlineelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_first_inlineelement(s)
	}
}

func (p *Creole10Parser) Text_first_inlineelement() (localctx IText_first_inlineelementContext) {
	localctx = NewText_first_inlineelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Creole10ParserRULE_text_first_inlineelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(378)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserLINK_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(375)
			p.Link()
		}

	case Creole10ParserIMAGE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(376)
			p.Image()
		}

	case Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(377)
			p.Extension()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_first_unformattedelementContext is an interface to support dynamic dispatch.
type IText_first_unformattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_first_unformattedelementContext differentiates from other interfaces.
	IsText_first_unformattedelementContext()
}

type Text_first_unformattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_first_unformattedelementContext() *Text_first_unformattedelementContext {
	var p = new(Text_first_unformattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_first_unformattedelement
	return p
}

func (*Text_first_unformattedelementContext) IsText_first_unformattedelementContext() {}

func NewText_first_unformattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_first_unformattedelementContext {
	var p = new(Text_first_unformattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_first_unformattedelement

	return p
}

func (s *Text_first_unformattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_first_unformattedelementContext) Text_first_unformatted() IText_first_unformattedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_unformattedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_unformattedContext)
}

func (s *Text_first_unformattedelementContext) Text_first_inlineelement() IText_first_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_inlineelementContext)
}

func (s *Text_first_unformattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_first_unformattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_first_unformattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_first_unformattedelement(s)
	}
}

func (s *Text_first_unformattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_first_unformattedelement(s)
	}
}

func (p *Creole10Parser) Text_first_unformattedelement() (localctx IText_first_unformattedelementContext) {
	localctx = NewText_first_unformattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Creole10ParserRULE_text_first_unformattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(382)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(380)
			p.Text_first_unformatted()
		}

	case Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(381)
			p.Text_first_inlineelement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_first_unformattedContext is an interface to support dynamic dispatch.
type IText_first_unformattedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_first_unformattedContext differentiates from other interfaces.
	IsText_first_unformattedContext()
}

type Text_first_unformattedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_first_unformattedContext() *Text_first_unformattedContext {
	var p = new(Text_first_unformattedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_first_unformatted
	return p
}

func (*Text_first_unformattedContext) IsText_first_unformattedContext() {}

func NewText_first_unformattedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_first_unformattedContext {
	var p = new(Text_first_unformattedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_first_unformatted

	return p
}

func (s *Text_first_unformattedContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_first_unformattedContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Text_first_unformattedContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Text_first_unformattedContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Text_first_unformattedContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Text_first_unformattedContext) AllPOUND() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPOUND)
}

func (s *Text_first_unformattedContext) POUND(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPOUND, i)
}

func (s *Text_first_unformattedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Text_first_unformattedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Text_first_unformattedContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEQUAL)
}

func (s *Text_first_unformattedContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, i)
}

func (s *Text_first_unformattedContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Text_first_unformattedContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Text_first_unformattedContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Text_first_unformattedContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Text_first_unformattedContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Text_first_unformattedContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Text_first_unformattedContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Text_first_unformattedContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Text_first_unformattedContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Text_first_unformattedContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Text_first_unformattedContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Text_first_unformattedContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Text_first_unformattedContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Text_first_unformattedContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Text_first_unformattedContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Text_first_unformattedContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Text_first_unformattedContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Text_first_unformattedContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Text_first_unformattedContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Text_first_unformattedContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Text_first_unformattedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_first_unformattedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_first_unformattedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_first_unformatted(s)
	}
}

func (s *Text_first_unformattedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_first_unformatted(s)
	}
}

func (p *Creole10Parser) Text_first_unformatted() (localctx IText_first_unformattedContext) {
	localctx = NewText_first_unformattedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Creole10ParserRULE_text_first_unformatted)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(387)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(387)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(384)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserEQUAL - -1))|(1<<(Creole10ParserPIPE - -1))|(1<<(Creole10ParserPOUND - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(385)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(386)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(389)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}

	return localctx
}

// IText_unformattedelementContext is an interface to support dynamic dispatch.
type IText_unformattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_unformattedelementContext differentiates from other interfaces.
	IsText_unformattedelementContext()
}

type Text_unformattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_unformattedelementContext() *Text_unformattedelementContext {
	var p = new(Text_unformattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_unformattedelement
	return p
}

func (*Text_unformattedelementContext) IsText_unformattedelementContext() {}

func NewText_unformattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_unformattedelementContext {
	var p = new(Text_unformattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_unformattedelement

	return p
}

func (s *Text_unformattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_unformattedelementContext) Text_unformatted() IText_unformattedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedContext)
}

func (s *Text_unformattedelementContext) Text_inlineelement() IText_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_inlineelementContext)
}

func (s *Text_unformattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_unformattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_unformattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_unformattedelement(s)
	}
}

func (s *Text_unformattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_unformattedelement(s)
	}
}

func (p *Creole10Parser) Text_unformattedelement() (localctx IText_unformattedelementContext) {
	localctx = NewText_unformattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Creole10ParserRULE_text_unformattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(393)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(391)
			p.Text_unformatted()
		}

	case Creole10ParserNOWIKI_OPEN, Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(392)
			p.Text_inlineelement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_unformattedContext is an interface to support dynamic dispatch.
type IText_unformattedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_unformattedContext differentiates from other interfaces.
	IsText_unformattedContext()
}

type Text_unformattedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_unformattedContext() *Text_unformattedContext {
	var p = new(Text_unformattedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_unformatted
	return p
}

func (*Text_unformattedContext) IsText_unformattedContext() {}

func NewText_unformattedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_unformattedContext {
	var p = new(Text_unformattedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_unformatted

	return p
}

func (s *Text_unformattedContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_unformattedContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Text_unformattedContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Text_unformattedContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Text_unformattedContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Text_unformattedContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Text_unformattedContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Text_unformattedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Text_unformattedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Text_unformattedContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Text_unformattedContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Text_unformattedContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Text_unformattedContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Text_unformattedContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Text_unformattedContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Text_unformattedContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Text_unformattedContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Text_unformattedContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Text_unformattedContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Text_unformattedContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Text_unformattedContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Text_unformattedContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Text_unformattedContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Text_unformattedContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Text_unformattedContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Text_unformattedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_unformattedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_unformattedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_unformatted(s)
	}
}

func (s *Text_unformattedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_unformatted(s)
	}
}

func (p *Creole10Parser) Text_unformatted() (localctx IText_unformattedContext) {
	localctx = NewText_unformattedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Creole10ParserRULE_text_unformatted)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(398)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(395)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(396)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(397)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// IHeadingContext is an interface to support dynamic dispatch.
type IHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeadingContext differentiates from other interfaces.
	IsHeadingContext()
}

type HeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeadingContext() *HeadingContext {
	var p = new(HeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_heading
	return p
}

func (*HeadingContext) IsHeadingContext() {}

func NewHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HeadingContext {
	var p = new(HeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_heading

	return p
}

func (s *HeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *HeadingContext) AllHeading_markup() []IHeading_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem())
	var tst = make([]IHeading_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHeading_markupContext)
		}
	}

	return tst
}

func (s *HeadingContext) Heading_markup(i int) IHeading_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHeading_markupContext)
}

func (s *HeadingContext) Heading_content() IHeading_contentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_contentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeading_contentContext)
}

func (s *HeadingContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *HeadingContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *HeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHeading(s)
	}
}

func (s *HeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHeading(s)
	}
}

func (p *Creole10Parser) Heading() (localctx IHeadingContext) {
	localctx = NewHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Creole10ParserRULE_heading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Heading_markup()
	}
	{
		p.SetState(403)
		p.Heading_content()
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserEQUAL {
		{
			p.SetState(404)
			p.Heading_markup()
		}

	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserBLANKS {
		{
			p.SetState(407)
			p.Blanks()
		}

	}
	{
		p.SetState(410)
		p.Paragraph_separator()
	}

	return localctx
}

// IHeading_contentContext is an interface to support dynamic dispatch.
type IHeading_contentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeading_contentContext differentiates from other interfaces.
	IsHeading_contentContext()
}

type Heading_contentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeading_contentContext() *Heading_contentContext {
	var p = new(Heading_contentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_heading_content
	return p
}

func (*Heading_contentContext) IsHeading_contentContext() {}

func NewHeading_contentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Heading_contentContext {
	var p = new(Heading_contentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_heading_content

	return p
}

func (s *Heading_contentContext) GetParser() antlr.Parser { return s.parser }

func (s *Heading_contentContext) AllHeading_markup() []IHeading_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem())
	var tst = make([]IHeading_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHeading_markupContext)
		}
	}

	return tst
}

func (s *Heading_contentContext) Heading_markup(i int) IHeading_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHeading_markupContext)
}

func (s *Heading_contentContext) Heading_content() IHeading_contentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_contentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeading_contentContext)
}

func (s *Heading_contentContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Heading_contentContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Heading_contentContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEQUAL)
}

func (s *Heading_contentContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, i)
}

func (s *Heading_contentContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Heading_contentContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Heading_contentContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Heading_contentContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Heading_contentContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Heading_contentContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Heading_contentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Heading_contentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Heading_contentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHeading_content(s)
	}
}

func (s *Heading_contentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHeading_content(s)
	}
}

func (p *Creole10Parser) Heading_content() (localctx IHeading_contentContext) {
	localctx = NewHeading_contentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Creole10ParserRULE_heading_content)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(423)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserEQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(412)
			p.Heading_markup()
		}
		{
			p.SetState(413)
			p.Heading_content()
		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(414)
				p.Heading_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(419)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
					p.SetState(417)
					_la = p.GetTokenStream().LA(1)

					if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserEQUAL - -1)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}

				case Creole10ParserESCAPE:
					{
						p.SetState(418)
						p.Escaped()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(421)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_ordContext is an interface to support dynamic dispatch.
type IList_ordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ordContext differentiates from other interfaces.
	IsList_ordContext()
}

type List_ordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ordContext() *List_ordContext {
	var p = new(List_ordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_ord
	return p
}

func (*List_ordContext) IsList_ordContext() {}

func NewList_ordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ordContext {
	var p = new(List_ordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_ord

	return p
}

func (s *List_ordContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ordContext) AllList_ordelem() []IList_ordelemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_ordelemContext)(nil)).Elem())
	var tst = make([]IList_ordelemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_ordelemContext)
		}
	}

	return tst
}

func (s *List_ordContext) List_ordelem(i int) IList_ordelemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordelemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_ordelemContext)
}

func (s *List_ordContext) End_of_list() IEnd_of_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnd_of_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnd_of_listContext)
}

func (s *List_ordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_ordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_ord(s)
	}
}

func (s *List_ordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_ord(s)
	}
}

func (p *Creole10Parser) List_ord() (localctx IList_ordContext) {
	localctx = NewList_ordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Creole10ParserRULE_list_ord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(425)
				p.List_ordelem()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(430)
			p.End_of_list()
		}

	}

	return localctx
}

// IList_ordelemContext is an interface to support dynamic dispatch.
type IList_ordelemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ordelemContext differentiates from other interfaces.
	IsList_ordelemContext()
}

type List_ordelemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ordelemContext() *List_ordelemContext {
	var p = new(List_ordelemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_ordelem
	return p
}

func (*List_ordelemContext) IsList_ordelemContext() {}

func NewList_ordelemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ordelemContext {
	var p = new(List_ordelemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_ordelem

	return p
}

func (s *List_ordelemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ordelemContext) List_ordelem_markup() IList_ordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ordelem_markupContext)
}

func (s *List_ordelemContext) List_elem() IList_elemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemContext)
}

func (s *List_ordelemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ordelemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_ordelemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_ordelem(s)
	}
}

func (s *List_ordelemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_ordelem(s)
	}
}

func (p *Creole10Parser) List_ordelem() (localctx IList_ordelemContext) {
	localctx = NewList_ordelemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Creole10ParserRULE_list_ordelem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.List_ordelem_markup()
	}
	{
		p.SetState(434)
		p.List_elem()
	}

	return localctx
}

// IList_unordContext is an interface to support dynamic dispatch.
type IList_unordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_unordContext differentiates from other interfaces.
	IsList_unordContext()
}

type List_unordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_unordContext() *List_unordContext {
	var p = new(List_unordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_unord
	return p
}

func (*List_unordContext) IsList_unordContext() {}

func NewList_unordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_unordContext {
	var p = new(List_unordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_unord

	return p
}

func (s *List_unordContext) GetParser() antlr.Parser { return s.parser }

func (s *List_unordContext) AllList_unordelem() []IList_unordelemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_unordelemContext)(nil)).Elem())
	var tst = make([]IList_unordelemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_unordelemContext)
		}
	}

	return tst
}

func (s *List_unordContext) List_unordelem(i int) IList_unordelemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordelemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_unordelemContext)
}

func (s *List_unordContext) End_of_list() IEnd_of_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnd_of_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnd_of_listContext)
}

func (s *List_unordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_unordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_unordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_unord(s)
	}
}

func (s *List_unordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_unord(s)
	}
}

func (p *Creole10Parser) List_unord() (localctx IList_unordContext) {
	localctx = NewList_unordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Creole10ParserRULE_list_unord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(436)
				p.List_unordelem()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(441)
			p.End_of_list()
		}

	}

	return localctx
}

// IList_unordelemContext is an interface to support dynamic dispatch.
type IList_unordelemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_unordelemContext differentiates from other interfaces.
	IsList_unordelemContext()
}

type List_unordelemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_unordelemContext() *List_unordelemContext {
	var p = new(List_unordelemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_unordelem
	return p
}

func (*List_unordelemContext) IsList_unordelemContext() {}

func NewList_unordelemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_unordelemContext {
	var p = new(List_unordelemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_unordelem

	return p
}

func (s *List_unordelemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_unordelemContext) List_unordelem_markup() IList_unordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_unordelem_markupContext)
}

func (s *List_unordelemContext) List_elem() IList_elemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemContext)
}

func (s *List_unordelemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_unordelemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_unordelemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_unordelem(s)
	}
}

func (s *List_unordelemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_unordelem(s)
	}
}

func (p *Creole10Parser) List_unordelem() (localctx IList_unordelemContext) {
	localctx = NewList_unordelemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Creole10ParserRULE_list_unordelem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.List_unordelem_markup()
	}
	{
		p.SetState(445)
		p.List_elem()
	}

	return localctx
}

// IList_elemContext is an interface to support dynamic dispatch.
type IList_elemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemContext differentiates from other interfaces.
	IsList_elemContext()
}

type List_elemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemContext() *List_elemContext {
	var p = new(List_elemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elem
	return p
}

func (*List_elemContext) IsList_elemContext() {}

func NewList_elemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemContext {
	var p = new(List_elemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elem

	return p
}

func (s *List_elemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemContext) List_elemcontent() IList_elemcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemcontentContext)
}

func (s *List_elemContext) List_elemseparator() IList_elemseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemseparatorContext)
}

func (s *List_elemContext) AllList_elem_markup() []IList_elem_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_elem_markupContext)(nil)).Elem())
	var tst = make([]IList_elem_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_elem_markupContext)
		}
	}

	return tst
}

func (s *List_elemContext) List_elem_markup(i int) IList_elem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elem_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_elem_markupContext)
}

func (s *List_elemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elem(s)
	}
}

func (s *List_elemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elem(s)
	}
}

func (p *Creole10Parser) List_elem() (localctx IList_elemContext) {
	localctx = NewList_elemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Creole10ParserRULE_list_elem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(447)
				p.List_elem_markup()
			}

		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}
	{
		p.SetState(453)
		p.List_elemcontent()
	}
	{
		p.SetState(454)
		p.List_elemseparator()
	}

	return localctx
}

// IList_elem_markupContext is an interface to support dynamic dispatch.
type IList_elem_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elem_markupContext differentiates from other interfaces.
	IsList_elem_markupContext()
}

type List_elem_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elem_markupContext() *List_elem_markupContext {
	var p = new(List_elem_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elem_markup
	return p
}

func (*List_elem_markupContext) IsList_elem_markupContext() {}

func NewList_elem_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elem_markupContext {
	var p = new(List_elem_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elem_markup

	return p
}

func (s *List_elem_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elem_markupContext) List_ordelem_markup() IList_ordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ordelem_markupContext)
}

func (s *List_elem_markupContext) List_unordelem_markup() IList_unordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_unordelem_markupContext)
}

func (s *List_elem_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elem_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elem_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elem_markup(s)
	}
}

func (s *List_elem_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elem_markup(s)
	}
}

func (p *Creole10Parser) List_elem_markup() (localctx IList_elem_markupContext) {
	localctx = NewList_elem_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Creole10ParserRULE_list_elem_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(458)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserPOUND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(456)
			p.List_ordelem_markup()
		}

	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(457)
			p.List_unordelem_markup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_elemcontentContext is an interface to support dynamic dispatch.
type IList_elemcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemcontentContext differentiates from other interfaces.
	IsList_elemcontentContext()
}

type List_elemcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemcontentContext() *List_elemcontentContext {
	var p = new(List_elemcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elemcontent
	return p
}

func (*List_elemcontentContext) IsList_elemcontentContext() {}

func NewList_elemcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemcontentContext {
	var p = new(List_elemcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elemcontent

	return p
}

func (s *List_elemcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemcontentContext) AllList_elemcontentpart() []IList_elemcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_elemcontentpartContext)(nil)).Elem())
	var tst = make([]IList_elemcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_elemcontentpartContext)
		}
	}

	return tst
}

func (s *List_elemcontentContext) List_elemcontentpart(i int) IList_elemcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_elemcontentpartContext)
}

func (s *List_elemcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elemcontent(s)
	}
}

func (s *List_elemcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elemcontent(s)
	}
}

func (p *Creole10Parser) List_elemcontent() (localctx IList_elemcontentContext) {
	localctx = NewList_elemcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Creole10ParserRULE_list_elemcontent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		{
			p.SetState(460)
			p.List_elemcontentpart()
		}

		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_elemcontentpartContext is an interface to support dynamic dispatch.
type IList_elemcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemcontentpartContext differentiates from other interfaces.
	IsList_elemcontentpartContext()
}

type List_elemcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemcontentpartContext() *List_elemcontentpartContext {
	var p = new(List_elemcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elemcontentpart
	return p
}

func (*List_elemcontentpartContext) IsList_elemcontentpartContext() {}

func NewList_elemcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemcontentpartContext {
	var p = new(List_elemcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elemcontentpart

	return p
}

func (s *List_elemcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemcontentpartContext) Text_unformattedelement() IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_elemcontentpartContext) Onestar() IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *List_elemcontentpartContext) List_formatted_elem() IList_formatted_elemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_formatted_elemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_formatted_elemContext)
}

func (s *List_elemcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elemcontentpart(s)
	}
}

func (s *List_elemcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elemcontentpart(s)
	}
}

func (p *Creole10Parser) List_elemcontentpart() (localctx IList_elemcontentpartContext) {
	localctx = NewList_elemcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Creole10ParserRULE_list_elemcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(470)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(466)
			p.Text_unformattedelement()
		}
		{
			p.SetState(467)
			p.Onestar()
		}

	case Creole10ParserITAL, Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(469)
			p.List_formatted_elem()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_formatted_elemContext is an interface to support dynamic dispatch.
type IList_formatted_elemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_formatted_elemContext differentiates from other interfaces.
	IsList_formatted_elemContext()
}

type List_formatted_elemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_formatted_elemContext() *List_formatted_elemContext {
	var p = new(List_formatted_elemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_formatted_elem
	return p
}

func (*List_formatted_elemContext) IsList_formatted_elemContext() {}

func NewList_formatted_elemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_formatted_elemContext {
	var p = new(List_formatted_elemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_formatted_elem

	return p
}

func (s *List_formatted_elemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_formatted_elemContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *List_formatted_elemContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *List_formatted_elemContext) AllList_boldcontentpart() []IList_boldcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_boldcontentpartContext)(nil)).Elem())
	var tst = make([]IList_boldcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_boldcontentpartContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) List_boldcontentpart(i int) IList_boldcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_boldcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_boldcontentpartContext)
}

func (s *List_formatted_elemContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *List_formatted_elemContext) AllList_italcontentpart() []IList_italcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_italcontentpartContext)(nil)).Elem())
	var tst = make([]IList_italcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_italcontentpartContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) List_italcontentpart(i int) IList_italcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_italcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_italcontentpartContext)
}

func (s *List_formatted_elemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_formatted_elemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_formatted_elemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_formatted_elem(s)
	}
}

func (s *List_formatted_elemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_formatted_elem(s)
	}
}

func (p *Creole10Parser) List_formatted_elem() (localctx IList_formatted_elemContext) {
	localctx = NewList_formatted_elemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Creole10ParserRULE_list_formatted_elem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(496)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(472)
			p.Bold_markup()
		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(473)
					p.Onestar()
				}
				{
					p.SetState(474)
					p.List_boldcontentpart()
				}

			}
			p.SetState(480)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
		}
		p.SetState(482)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(481)
				p.Bold_markup()
			}

		}

	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(484)
			p.Ital_markup()
		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(485)
					p.Onestar()
				}
				{
					p.SetState(486)
					p.List_italcontentpart()
				}

			}
			p.SetState(492)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
		}
		p.SetState(494)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(493)
				p.Ital_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnestarContext is an interface to support dynamic dispatch.
type IOnestarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnestarContext differentiates from other interfaces.
	IsOnestarContext()
}

type OnestarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnestarContext() *OnestarContext {
	var p = new(OnestarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_onestar
	return p
}

func (*OnestarContext) IsOnestarContext() {}

func NewOnestarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnestarContext {
	var p = new(OnestarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_onestar

	return p
}

func (s *OnestarContext) GetParser() antlr.Parser { return s.parser }

func (s *OnestarContext) STAR() antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, 0)
}

func (s *OnestarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnestarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnestarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterOnestar(s)
	}
}

func (s *OnestarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitOnestar(s)
	}
}

func (p *Creole10Parser) Onestar() (localctx IOnestarContext) {
	localctx = NewOnestarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Creole10ParserRULE_onestar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(498)

		if !(p.GetInputStream().LA(2) != Creole10ParserSTAR) {
			panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(2)!=Creole10ParserSTAR", ""))
		}
		p.SetState(500)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(499)
				p.Match(Creole10ParserSTAR)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IList_boldcontentpartContext is an interface to support dynamic dispatch.
type IList_boldcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_boldcontentpartContext differentiates from other interfaces.
	IsList_boldcontentpartContext()
}

type List_boldcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_boldcontentpartContext() *List_boldcontentpartContext {
	var p = new(List_boldcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_boldcontentpart
	return p
}

func (*List_boldcontentpartContext) IsList_boldcontentpartContext() {}

func NewList_boldcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_boldcontentpartContext {
	var p = new(List_boldcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_boldcontentpart

	return p
}

func (s *List_boldcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *List_boldcontentpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *List_boldcontentpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *List_boldcontentpartContext) List_bolditalcontent() IList_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_bolditalcontentContext)
}

func (s *List_boldcontentpartContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *List_boldcontentpartContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_boldcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_boldcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_boldcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_boldcontentpart(s)
	}
}

func (s *List_boldcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_boldcontentpart(s)
	}
}

func (p *Creole10Parser) List_boldcontentpart() (localctx IList_boldcontentpartContext) {
	localctx = NewList_boldcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Creole10ParserRULE_list_boldcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(515)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.Ital_markup()
		}
		{
			p.SetState(506)
			p.List_bolditalcontent()
		}
		p.SetState(508)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(507)
				p.Ital_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(510)
					p.Text_unformattedelement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(513)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_italcontentpartContext is an interface to support dynamic dispatch.
type IList_italcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_italcontentpartContext differentiates from other interfaces.
	IsList_italcontentpartContext()
}

type List_italcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_italcontentpartContext() *List_italcontentpartContext {
	var p = new(List_italcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_italcontentpart
	return p
}

func (*List_italcontentpartContext) IsList_italcontentpartContext() {}

func NewList_italcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_italcontentpartContext {
	var p = new(List_italcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_italcontentpart

	return p
}

func (s *List_italcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *List_italcontentpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *List_italcontentpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *List_italcontentpartContext) List_bolditalcontent() IList_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_bolditalcontentContext)
}

func (s *List_italcontentpartContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *List_italcontentpartContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_italcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_italcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_italcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_italcontentpart(s)
	}
}

func (s *List_italcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_italcontentpart(s)
	}
}

func (p *Creole10Parser) List_italcontentpart() (localctx IList_italcontentpartContext) {
	localctx = NewList_italcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Creole10ParserRULE_list_italcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(527)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(517)
			p.Bold_markup()
		}
		{
			p.SetState(518)
			p.List_bolditalcontent()
		}
		p.SetState(520)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(519)
				p.Bold_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(522)
					p.Text_unformattedelement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(525)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_bolditalcontentContext is an interface to support dynamic dispatch.
type IList_bolditalcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_bolditalcontentContext differentiates from other interfaces.
	IsList_bolditalcontentContext()
}

type List_bolditalcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_bolditalcontentContext() *List_bolditalcontentContext {
	var p = new(List_bolditalcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_bolditalcontent
	return p
}

func (*List_bolditalcontentContext) IsList_bolditalcontentContext() {}

func NewList_bolditalcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_bolditalcontentContext {
	var p = new(List_bolditalcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_bolditalcontent

	return p
}

func (s *List_bolditalcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *List_bolditalcontentContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *List_bolditalcontentContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_bolditalcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_bolditalcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_bolditalcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_bolditalcontent(s)
	}
}

func (s *List_bolditalcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_bolditalcontent(s)
	}
}

func (p *Creole10Parser) List_bolditalcontent() (localctx IList_bolditalcontentContext) {
	localctx = NewList_bolditalcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Creole10ParserRULE_list_bolditalcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(529)
				p.Text_unformattedelement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) AllTable_row() []ITable_rowContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_rowContext)(nil)).Elem())
	var tst = make([]ITable_rowContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_rowContext)
		}
	}

	return tst
}

func (s *TableContext) Table_row(i int) ITable_rowContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_rowContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_rowContext)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *Creole10Parser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Creole10ParserRULE_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(534)
				p.Table_row()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// ITable_rowContext is an interface to support dynamic dispatch.
type ITable_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_rowContext differentiates from other interfaces.
	IsTable_rowContext()
}

type Table_rowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowContext() *Table_rowContext {
	var p = new(Table_rowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_row
	return p
}

func (*Table_rowContext) IsTable_rowContext() {}

func NewTable_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowContext {
	var p = new(Table_rowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_row

	return p
}

func (s *Table_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowContext) Table_rowseparator() ITable_rowseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_rowseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_rowseparatorContext)
}

func (s *Table_rowContext) AllTable_cell() []ITable_cellContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_cellContext)(nil)).Elem())
	var tst = make([]ITable_cellContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_cellContext)
		}
	}

	return tst
}

func (s *Table_rowContext) Table_cell(i int) ITable_cellContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_cellContext)
}

func (s *Table_rowContext) Table_cell_markup() ITable_cell_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cell_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cell_markupContext)
}

func (s *Table_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_row(s)
	}
}

func (s *Table_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_row(s)
	}
}

func (p *Creole10Parser) Table_row() (localctx ITable_rowContext) {
	localctx = NewTable_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Creole10ParserRULE_table_row)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(539)
				p.Table_cell()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserPIPE {
		{
			p.SetState(544)
			p.Table_cell_markup()
		}

	}
	{
		p.SetState(547)
		p.Table_rowseparator()
	}

	return localctx
}

// ITable_cellContext is an interface to support dynamic dispatch.
type ITable_cellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cellContext differentiates from other interfaces.
	IsTable_cellContext()
}

type Table_cellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cellContext() *Table_cellContext {
	var p = new(Table_cellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cell
	return p
}

func (*Table_cellContext) IsTable_cellContext() {}

func NewTable_cellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cellContext {
	var p = new(Table_cellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cell

	return p
}

func (s *Table_cellContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cellContext) Table_headercell() ITable_headercellContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_headercellContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_headercellContext)
}

func (s *Table_cellContext) Table_normalcell() ITable_normalcellContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_normalcellContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_normalcellContext)
}

func (s *Table_cellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cell(s)
	}
}

func (s *Table_cellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cell(s)
	}
}

func (p *Creole10Parser) Table_cell() (localctx ITable_cellContext) {
	localctx = NewTable_cellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Creole10ParserRULE_table_cell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(552)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(549)

		if !(p.GetInputStream().LA(2) == Creole10ParserEQUAL) {
			panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(2)==Creole10ParserEQUAL", ""))
		}
		{
			p.SetState(550)
			p.Table_headercell()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(551)
			p.Table_normalcell()
		}

	}

	return localctx
}

// ITable_headercellContext is an interface to support dynamic dispatch.
type ITable_headercellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_headercellContext differentiates from other interfaces.
	IsTable_headercellContext()
}

type Table_headercellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_headercellContext() *Table_headercellContext {
	var p = new(Table_headercellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_headercell
	return p
}

func (*Table_headercellContext) IsTable_headercellContext() {}

func NewTable_headercellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_headercellContext {
	var p = new(Table_headercellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_headercell

	return p
}

func (s *Table_headercellContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_headercellContext) Table_headercell_markup() ITable_headercell_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_headercell_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_headercell_markupContext)
}

func (s *Table_headercellContext) Table_cellcontent() ITable_cellcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cellcontentContext)
}

func (s *Table_headercellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_headercellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_headercellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_headercell(s)
	}
}

func (s *Table_headercellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_headercell(s)
	}
}

func (p *Creole10Parser) Table_headercell() (localctx ITable_headercellContext) {
	localctx = NewTable_headercellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Creole10ParserRULE_table_headercell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.Table_headercell_markup()
	}
	{
		p.SetState(555)
		p.Table_cellcontent()
	}

	return localctx
}

// ITable_normalcellContext is an interface to support dynamic dispatch.
type ITable_normalcellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_normalcellContext differentiates from other interfaces.
	IsTable_normalcellContext()
}

type Table_normalcellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_normalcellContext() *Table_normalcellContext {
	var p = new(Table_normalcellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_normalcell
	return p
}

func (*Table_normalcellContext) IsTable_normalcellContext() {}

func NewTable_normalcellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_normalcellContext {
	var p = new(Table_normalcellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_normalcell

	return p
}

func (s *Table_normalcellContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_normalcellContext) Table_cell_markup() ITable_cell_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cell_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cell_markupContext)
}

func (s *Table_normalcellContext) Table_cellcontent() ITable_cellcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cellcontentContext)
}

func (s *Table_normalcellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_normalcellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_normalcellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_normalcell(s)
	}
}

func (s *Table_normalcellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_normalcell(s)
	}
}

func (p *Creole10Parser) Table_normalcell() (localctx ITable_normalcellContext) {
	localctx = NewTable_normalcellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Creole10ParserRULE_table_normalcell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.Table_cell_markup()
	}
	{
		p.SetState(558)
		p.Table_cellcontent()
	}

	return localctx
}

// ITable_cellcontentContext is an interface to support dynamic dispatch.
type ITable_cellcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cellcontentContext differentiates from other interfaces.
	IsTable_cellcontentContext()
}

type Table_cellcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cellcontentContext() *Table_cellcontentContext {
	var p = new(Table_cellcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cellcontent
	return p
}

func (*Table_cellcontentContext) IsTable_cellcontentContext() {}

func NewTable_cellcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cellcontentContext {
	var p = new(Table_cellcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cellcontent

	return p
}

func (s *Table_cellcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cellcontentContext) AllTable_cellcontentpart() []ITable_cellcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_cellcontentpartContext)(nil)).Elem())
	var tst = make([]ITable_cellcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_cellcontentpartContext)
		}
	}

	return tst
}

func (s *Table_cellcontentContext) Table_cellcontentpart(i int) ITable_cellcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_cellcontentpartContext)
}

func (s *Table_cellcontentContext) STAR() antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, 0)
}

func (s *Table_cellcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cellcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cellcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cellcontent(s)
	}
}

func (s *Table_cellcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cellcontent(s)
	}
}

func (p *Creole10Parser) Table_cellcontent() (localctx ITable_cellcontentContext) {
	localctx = NewTable_cellcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Creole10ParserRULE_table_cellcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(560)
				p.Table_cellcontentpart()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(565)
			p.Match(Creole10ParserSTAR)
		}

	}

	return localctx
}

// ITable_cellcontentpartContext is an interface to support dynamic dispatch.
type ITable_cellcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cellcontentpartContext differentiates from other interfaces.
	IsTable_cellcontentpartContext()
}

type Table_cellcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cellcontentpartContext() *Table_cellcontentpartContext {
	var p = new(Table_cellcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cellcontentpart
	return p
}

func (*Table_cellcontentpartContext) IsTable_cellcontentpartContext() {}

func NewTable_cellcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cellcontentpartContext {
	var p = new(Table_cellcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cellcontentpart

	return p
}

func (s *Table_cellcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cellcontentpartContext) Table_formattedelement() ITable_formattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedelementContext)
}

func (s *Table_cellcontentpartContext) Onestar() IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Table_cellcontentpartContext) Table_unformattedelement() ITable_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_unformattedelementContext)
}

func (s *Table_cellcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cellcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cellcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cellcontentpart(s)
	}
}

func (s *Table_cellcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cellcontentpart(s)
	}
}

func (p *Creole10Parser) Table_cellcontentpart() (localctx ITable_cellcontentpartContext) {
	localctx = NewTable_cellcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Creole10ParserRULE_table_cellcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(568)
			p.Table_formattedelement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(569)
			p.Onestar()
		}
		{
			p.SetState(570)
			p.Table_unformattedelement()
		}

	}

	return localctx
}

// ITable_formattedelementContext is an interface to support dynamic dispatch.
type ITable_formattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_formattedelementContext differentiates from other interfaces.
	IsTable_formattedelementContext()
}

type Table_formattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_formattedelementContext() *Table_formattedelementContext {
	var p = new(Table_formattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_formattedelement
	return p
}

func (*Table_formattedelementContext) IsTable_formattedelementContext() {}

func NewTable_formattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_formattedelementContext {
	var p = new(Table_formattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_formattedelement

	return p
}

func (s *Table_formattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_formattedelementContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Table_formattedelementContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Table_formattedelementContext) Table_italcontent() ITable_italcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_italcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_italcontentContext)
}

func (s *Table_formattedelementContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Table_formattedelementContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Table_formattedelementContext) Table_boldcontent() ITable_boldcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_boldcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_boldcontentContext)
}

func (s *Table_formattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_formattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_formattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_formattedelement(s)
	}
}

func (s *Table_formattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_formattedelement(s)
	}
}

func (p *Creole10Parser) Table_formattedelement() (localctx ITable_formattedelementContext) {
	localctx = NewTable_formattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Creole10ParserRULE_table_formattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(588)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(574)
			p.Ital_markup()
		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(575)
				p.Table_italcontent()
			}

		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(578)
				p.Ital_markup()
			}

		}

	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(581)
			p.Bold_markup()
		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(582)
				p.Table_boldcontent()
			}

		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(585)
				p.Bold_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_boldcontentContext is an interface to support dynamic dispatch.
type ITable_boldcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_boldcontentContext differentiates from other interfaces.
	IsTable_boldcontentContext()
}

type Table_boldcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_boldcontentContext() *Table_boldcontentContext {
	var p = new(Table_boldcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_boldcontent
	return p
}

func (*Table_boldcontentContext) IsTable_boldcontentContext() {}

func NewTable_boldcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_boldcontentContext {
	var p = new(Table_boldcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_boldcontent

	return p
}

func (s *Table_boldcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_boldcontentContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Table_boldcontentContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Table_boldcontentContext) AllTable_boldcontentpart() []ITable_boldcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_boldcontentpartContext)(nil)).Elem())
	var tst = make([]ITable_boldcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_boldcontentpartContext)
		}
	}

	return tst
}

func (s *Table_boldcontentContext) Table_boldcontentpart(i int) ITable_boldcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_boldcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_boldcontentpartContext)
}

func (s *Table_boldcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_boldcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_boldcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_boldcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_boldcontent(s)
	}
}

func (s *Table_boldcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_boldcontent(s)
	}
}

func (p *Creole10Parser) Table_boldcontent() (localctx ITable_boldcontentContext) {
	localctx = NewTable_boldcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Creole10ParserRULE_table_boldcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(593)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(590)
					p.Onestar()
				}
				{
					p.SetState(591)
					p.Table_boldcontentpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(595)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(597)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// ITable_italcontentContext is an interface to support dynamic dispatch.
type ITable_italcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_italcontentContext differentiates from other interfaces.
	IsTable_italcontentContext()
}

type Table_italcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_italcontentContext() *Table_italcontentContext {
	var p = new(Table_italcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_italcontent
	return p
}

func (*Table_italcontentContext) IsTable_italcontentContext() {}

func NewTable_italcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_italcontentContext {
	var p = new(Table_italcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_italcontent

	return p
}

func (s *Table_italcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_italcontentContext) AllTable_italcontentpart() []ITable_italcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_italcontentpartContext)(nil)).Elem())
	var tst = make([]ITable_italcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_italcontentpartContext)
		}
	}

	return tst
}

func (s *Table_italcontentContext) Table_italcontentpart(i int) ITable_italcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_italcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_italcontentpartContext)
}

func (s *Table_italcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_italcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_italcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_italcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_italcontent(s)
	}
}

func (s *Table_italcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_italcontent(s)
	}
}

func (p *Creole10Parser) Table_italcontent() (localctx ITable_italcontentContext) {
	localctx = NewTable_italcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Creole10ParserRULE_table_italcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(606)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(601)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(600)
					p.Table_italcontentpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(603)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(605)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_boldcontentpartContext is an interface to support dynamic dispatch.
type ITable_boldcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_boldcontentpartContext differentiates from other interfaces.
	IsTable_boldcontentpartContext()
}

type Table_boldcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_boldcontentpartContext() *Table_boldcontentpartContext {
	var p = new(Table_boldcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_boldcontentpart
	return p
}

func (*Table_boldcontentpartContext) IsTable_boldcontentpartContext() {}

func NewTable_boldcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_boldcontentpartContext {
	var p = new(Table_boldcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_boldcontentpart

	return p
}

func (s *Table_boldcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_boldcontentpartContext) Table_formattedcontent() ITable_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedcontentContext)
}

func (s *Table_boldcontentpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Table_boldcontentpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Table_boldcontentpartContext) Table_bolditalcontent() ITable_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_bolditalcontentContext)
}

func (s *Table_boldcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_boldcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_boldcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_boldcontentpart(s)
	}
}

func (s *Table_boldcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_boldcontentpart(s)
	}
}

func (p *Creole10Parser) Table_boldcontentpart() (localctx ITable_boldcontentpartContext) {
	localctx = NewTable_boldcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Creole10ParserRULE_table_boldcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(614)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.Table_formattedcontent()
		}

	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(609)
			p.Ital_markup()
		}
		{
			p.SetState(610)
			p.Table_bolditalcontent()
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(611)
				p.Ital_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_italcontentpartContext is an interface to support dynamic dispatch.
type ITable_italcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_italcontentpartContext differentiates from other interfaces.
	IsTable_italcontentpartContext()
}

type Table_italcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_italcontentpartContext() *Table_italcontentpartContext {
	var p = new(Table_italcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_italcontentpart
	return p
}

func (*Table_italcontentpartContext) IsTable_italcontentpartContext() {}

func NewTable_italcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_italcontentpartContext {
	var p = new(Table_italcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_italcontentpart

	return p
}

func (s *Table_italcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_italcontentpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Table_italcontentpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Table_italcontentpartContext) Table_bolditalcontent() ITable_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_bolditalcontentContext)
}

func (s *Table_italcontentpartContext) Table_formattedcontent() ITable_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedcontentContext)
}

func (s *Table_italcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_italcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_italcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_italcontentpart(s)
	}
}

func (s *Table_italcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_italcontentpart(s)
	}
}

func (p *Creole10Parser) Table_italcontentpart() (localctx ITable_italcontentpartContext) {
	localctx = NewTable_italcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Creole10ParserRULE_table_italcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(622)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Bold_markup()
		}
		{
			p.SetState(617)
			p.Table_bolditalcontent()
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(618)
				p.Bold_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(621)
			p.Table_formattedcontent()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_bolditalcontentContext is an interface to support dynamic dispatch.
type ITable_bolditalcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_bolditalcontentContext differentiates from other interfaces.
	IsTable_bolditalcontentContext()
}

type Table_bolditalcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_bolditalcontentContext() *Table_bolditalcontentContext {
	var p = new(Table_bolditalcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_bolditalcontent
	return p
}

func (*Table_bolditalcontentContext) IsTable_bolditalcontentContext() {}

func NewTable_bolditalcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_bolditalcontentContext {
	var p = new(Table_bolditalcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_bolditalcontent

	return p
}

func (s *Table_bolditalcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_bolditalcontentContext) Table_formattedcontent() ITable_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedcontentContext)
}

func (s *Table_bolditalcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_bolditalcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_bolditalcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_bolditalcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_bolditalcontent(s)
	}
}

func (s *Table_bolditalcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_bolditalcontent(s)
	}
}

func (p *Creole10Parser) Table_bolditalcontent() (localctx ITable_bolditalcontentContext) {
	localctx = NewTable_bolditalcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Creole10ParserRULE_table_bolditalcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(625)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(624)
				p.Table_formattedcontent()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(627)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// ITable_formattedcontentContext is an interface to support dynamic dispatch.
type ITable_formattedcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_formattedcontentContext differentiates from other interfaces.
	IsTable_formattedcontentContext()
}

type Table_formattedcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_formattedcontentContext() *Table_formattedcontentContext {
	var p = new(Table_formattedcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_formattedcontent
	return p
}

func (*Table_formattedcontentContext) IsTable_formattedcontentContext() {}

func NewTable_formattedcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_formattedcontentContext {
	var p = new(Table_formattedcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_formattedcontent

	return p
}

func (s *Table_formattedcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_formattedcontentContext) AllTable_unformattedelement() []ITable_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_unformattedelementContext)(nil)).Elem())
	var tst = make([]ITable_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_unformattedelementContext)
		}
	}

	return tst
}

func (s *Table_formattedcontentContext) Table_unformattedelement(i int) ITable_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_unformattedelementContext)
}

func (s *Table_formattedcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_formattedcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_formattedcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_formattedcontent(s)
	}
}

func (s *Table_formattedcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_formattedcontent(s)
	}
}

func (p *Creole10Parser) Table_formattedcontent() (localctx ITable_formattedcontentContext) {
	localctx = NewTable_formattedcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Creole10ParserRULE_table_formattedcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(630)
				p.Table_unformattedelement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(633)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// ITable_inlineelementContext is an interface to support dynamic dispatch.
type ITable_inlineelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_inlineelementContext differentiates from other interfaces.
	IsTable_inlineelementContext()
}

type Table_inlineelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_inlineelementContext() *Table_inlineelementContext {
	var p = new(Table_inlineelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_inlineelement
	return p
}

func (*Table_inlineelementContext) IsTable_inlineelementContext() {}

func NewTable_inlineelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_inlineelementContext {
	var p = new(Table_inlineelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_inlineelement

	return p
}

func (s *Table_inlineelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_inlineelementContext) Link() ILinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkContext)
}

func (s *Table_inlineelementContext) Image() IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *Table_inlineelementContext) Extension() IExtensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionContext)
}

func (s *Table_inlineelementContext) Nowiki_inline() INowiki_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_inlineContext)
}

func (s *Table_inlineelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_inlineelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_inlineelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_inlineelement(s)
	}
}

func (s *Table_inlineelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_inlineelement(s)
	}
}

func (p *Creole10Parser) Table_inlineelement() (localctx ITable_inlineelementContext) {
	localctx = NewTable_inlineelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Creole10ParserRULE_table_inlineelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserLINK_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(635)
			p.Link()
		}

	case Creole10ParserIMAGE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(636)
			p.Image()
		}

	case Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(637)
			p.Extension()
		}

	case Creole10ParserNOWIKI_OPEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(638)
			p.Nowiki_inline()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_unformattedelementContext is an interface to support dynamic dispatch.
type ITable_unformattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_unformattedelementContext differentiates from other interfaces.
	IsTable_unformattedelementContext()
}

type Table_unformattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_unformattedelementContext() *Table_unformattedelementContext {
	var p = new(Table_unformattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_unformattedelement
	return p
}

func (*Table_unformattedelementContext) IsTable_unformattedelementContext() {}

func NewTable_unformattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_unformattedelementContext {
	var p = new(Table_unformattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_unformattedelement

	return p
}

func (s *Table_unformattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_unformattedelementContext) Table_unformatted() ITable_unformattedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_unformattedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_unformattedContext)
}

func (s *Table_unformattedelementContext) Table_inlineelement() ITable_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_inlineelementContext)
}

func (s *Table_unformattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_unformattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_unformattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_unformattedelement(s)
	}
}

func (s *Table_unformattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_unformattedelement(s)
	}
}

func (p *Creole10Parser) Table_unformattedelement() (localctx ITable_unformattedelementContext) {
	localctx = NewTable_unformattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Creole10ParserRULE_table_unformattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(643)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(641)
			p.Table_unformatted()
		}

	case Creole10ParserNOWIKI_OPEN, Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(642)
			p.Table_inlineelement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_unformattedContext is an interface to support dynamic dispatch.
type ITable_unformattedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_unformattedContext differentiates from other interfaces.
	IsTable_unformattedContext()
}

type Table_unformattedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_unformattedContext() *Table_unformattedContext {
	var p = new(Table_unformattedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_unformatted
	return p
}

func (*Table_unformattedContext) IsTable_unformattedContext() {}

func NewTable_unformattedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_unformattedContext {
	var p = new(Table_unformattedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_unformatted

	return p
}

func (s *Table_unformattedContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_unformattedContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Table_unformattedContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Table_unformattedContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Table_unformattedContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Table_unformattedContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Table_unformattedContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Table_unformattedContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Table_unformattedContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Table_unformattedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Table_unformattedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Table_unformattedContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Table_unformattedContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Table_unformattedContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Table_unformattedContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Table_unformattedContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Table_unformattedContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Table_unformattedContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Table_unformattedContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Table_unformattedContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Table_unformattedContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Table_unformattedContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Table_unformattedContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Table_unformattedContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Table_unformattedContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Table_unformattedContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Table_unformattedContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Table_unformattedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_unformattedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_unformattedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_unformatted(s)
	}
}

func (s *Table_unformattedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_unformatted(s)
	}
}

func (p *Creole10Parser) Table_unformatted() (localctx ITable_unformattedContext) {
	localctx = NewTable_unformattedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Creole10ParserRULE_table_unformatted)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(648)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(645)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserPIPE - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(646)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(647)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// INowiki_blockContext is an interface to support dynamic dispatch.
type INowiki_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_blockContext differentiates from other interfaces.
	IsNowiki_blockContext()
}

type Nowiki_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_blockContext() *Nowiki_blockContext {
	var p = new(Nowiki_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_block
	return p
}

func (*Nowiki_blockContext) IsNowiki_blockContext() {}

func NewNowiki_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_blockContext {
	var p = new(Nowiki_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_block

	return p
}

func (s *Nowiki_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_blockContext) Nowikiblock_open_markup() INowikiblock_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowikiblock_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowikiblock_open_markupContext)
}

func (s *Nowiki_blockContext) Nowikiblock_close_markup() INowikiblock_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowikiblock_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowikiblock_close_markupContext)
}

func (s *Nowiki_blockContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *Nowiki_blockContext) AllNOWIKI_BLOCK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_BLOCK_CLOSE)
}

func (s *Nowiki_blockContext) NOWIKI_BLOCK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_BLOCK_CLOSE, i)
}

func (s *Nowiki_blockContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Nowiki_blockContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Nowiki_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_block(s)
	}
}

func (s *Nowiki_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_block(s)
	}
}

func (p *Creole10Parser) Nowiki_block() (localctx INowiki_blockContext) {
	localctx = NewNowiki_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Creole10ParserRULE_nowiki_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Nowikiblock_open_markup()
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNEWLINE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		p.SetState(653)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == Creole10ParserEOF || _la == Creole10ParserNOWIKI_BLOCK_CLOSE {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(659)
		p.Nowikiblock_close_markup()
	}
	{
		p.SetState(660)
		p.Paragraph_separator()
	}

	return localctx
}

// INowikiblock_open_markupContext is an interface to support dynamic dispatch.
type INowikiblock_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowikiblock_open_markupContext differentiates from other interfaces.
	IsNowikiblock_open_markupContext()
}

type Nowikiblock_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowikiblock_open_markupContext() *Nowikiblock_open_markupContext {
	var p = new(Nowikiblock_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowikiblock_open_markup
	return p
}

func (*Nowikiblock_open_markupContext) IsNowikiblock_open_markupContext() {}

func NewNowikiblock_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowikiblock_open_markupContext {
	var p = new(Nowikiblock_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowikiblock_open_markup

	return p
}

func (s *Nowikiblock_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowikiblock_open_markupContext) Nowiki_open_markup() INowiki_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_open_markupContext)
}

func (s *Nowikiblock_open_markupContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Nowikiblock_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowikiblock_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowikiblock_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowikiblock_open_markup(s)
	}
}

func (s *Nowikiblock_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowikiblock_open_markup(s)
	}
}

func (p *Creole10Parser) Nowikiblock_open_markup() (localctx INowikiblock_open_markupContext) {
	localctx = NewNowikiblock_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Creole10ParserRULE_nowikiblock_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Nowiki_open_markup()
	}
	{
		p.SetState(663)
		p.Newline()
	}

	return localctx
}

// INowikiblock_close_markupContext is an interface to support dynamic dispatch.
type INowikiblock_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowikiblock_close_markupContext differentiates from other interfaces.
	IsNowikiblock_close_markupContext()
}

type Nowikiblock_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowikiblock_close_markupContext() *Nowikiblock_close_markupContext {
	var p = new(Nowikiblock_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowikiblock_close_markup
	return p
}

func (*Nowikiblock_close_markupContext) IsNowikiblock_close_markupContext() {}

func NewNowikiblock_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowikiblock_close_markupContext {
	var p = new(Nowikiblock_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowikiblock_close_markup

	return p
}

func (s *Nowikiblock_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowikiblock_close_markupContext) NOWIKI_BLOCK_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_BLOCK_CLOSE, 0)
}

func (s *Nowikiblock_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowikiblock_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowikiblock_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowikiblock_close_markup(s)
	}
}

func (s *Nowikiblock_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowikiblock_close_markup(s)
	}
}

func (p *Creole10Parser) Nowikiblock_close_markup() (localctx INowikiblock_close_markupContext) {
	localctx = NewNowikiblock_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Creole10ParserRULE_nowikiblock_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(Creole10ParserNOWIKI_BLOCK_CLOSE)
	}

	return localctx
}

// INowiki_inlineContext is an interface to support dynamic dispatch.
type INowiki_inlineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_inlineContext differentiates from other interfaces.
	IsNowiki_inlineContext()
}

type Nowiki_inlineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_inlineContext() *Nowiki_inlineContext {
	var p = new(Nowiki_inlineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_inline
	return p
}

func (*Nowiki_inlineContext) IsNowiki_inlineContext() {}

func NewNowiki_inlineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_inlineContext {
	var p = new(Nowiki_inlineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_inline

	return p
}

func (s *Nowiki_inlineContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_inlineContext) Nowiki_open_markup() INowiki_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_open_markupContext)
}

func (s *Nowiki_inlineContext) Nowiki_close_markup() INowiki_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_close_markupContext)
}

func (s *Nowiki_inlineContext) AllNOWIKI_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_CLOSE)
}

func (s *Nowiki_inlineContext) NOWIKI_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_CLOSE, i)
}

func (s *Nowiki_inlineContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Nowiki_inlineContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Nowiki_inlineContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Nowiki_inlineContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Nowiki_inlineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_inlineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_inlineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_inline(s)
	}
}

func (s *Nowiki_inlineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_inline(s)
	}
}

func (p *Creole10Parser) Nowiki_inline() (localctx INowiki_inlineContext) {
	localctx = NewNowiki_inlineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Creole10ParserRULE_nowiki_inline)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Nowiki_open_markup()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		p.SetState(668)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserNOWIKI_CLOSE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(674)
		p.Nowiki_close_markup()
	}

	return localctx
}

// IHorizontalruleContext is an interface to support dynamic dispatch.
type IHorizontalruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHorizontalruleContext differentiates from other interfaces.
	IsHorizontalruleContext()
}

type HorizontalruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHorizontalruleContext() *HorizontalruleContext {
	var p = new(HorizontalruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_horizontalrule
	return p
}

func (*HorizontalruleContext) IsHorizontalruleContext() {}

func NewHorizontalruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HorizontalruleContext {
	var p = new(HorizontalruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_horizontalrule

	return p
}

func (s *HorizontalruleContext) GetParser() antlr.Parser { return s.parser }

func (s *HorizontalruleContext) Horizontalrule_markup() IHorizontalrule_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHorizontalrule_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHorizontalrule_markupContext)
}

func (s *HorizontalruleContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *HorizontalruleContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *HorizontalruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HorizontalruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HorizontalruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHorizontalrule(s)
	}
}

func (s *HorizontalruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHorizontalrule(s)
	}
}

func (p *Creole10Parser) Horizontalrule() (localctx IHorizontalruleContext) {
	localctx = NewHorizontalruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Creole10ParserRULE_horizontalrule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Horizontalrule_markup()
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserBLANKS {
		{
			p.SetState(677)
			p.Blanks()
		}

	}
	{
		p.SetState(680)
		p.Paragraph_separator()
	}

	return localctx
}

// ILinkContext is an interface to support dynamic dispatch.
type ILinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkContext differentiates from other interfaces.
	IsLinkContext()
}

type LinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkContext() *LinkContext {
	var p = new(LinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link
	return p
}

func (*LinkContext) IsLinkContext() {}

func NewLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkContext {
	var p = new(LinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link

	return p
}

func (s *LinkContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkContext) Link_open_markup() ILink_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_open_markupContext)
}

func (s *LinkContext) Link_address() ILink_addressContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_addressContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_addressContext)
}

func (s *LinkContext) Link_close_markup() ILink_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_close_markupContext)
}

func (s *LinkContext) Link_description_markup() ILink_description_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_description_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_description_markupContext)
}

func (s *LinkContext) Link_description() ILink_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptionContext)
}

func (s *LinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink(s)
	}
}

func (s *LinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink(s)
	}
}

func (p *Creole10Parser) Link() (localctx ILinkContext) {
	localctx = NewLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Creole10ParserRULE_link)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(682)
		p.Link_open_markup()
	}
	{
		p.SetState(683)
		p.Link_address()
	}
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserPIPE {
		{
			p.SetState(684)
			p.Link_description_markup()
		}
		{
			p.SetState(685)
			p.Link_description()
		}

	}
	{
		p.SetState(689)
		p.Link_close_markup()
	}

	return localctx
}

// ILink_addressContext is an interface to support dynamic dispatch.
type ILink_addressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_addressContext differentiates from other interfaces.
	IsLink_addressContext()
}

type Link_addressContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_addressContext() *Link_addressContext {
	var p = new(Link_addressContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_address
	return p
}

func (*Link_addressContext) IsLink_addressContext() {}

func NewLink_addressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_addressContext {
	var p = new(Link_addressContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_address

	return p
}

func (s *Link_addressContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_addressContext) Link_interwiki_uri() ILink_interwiki_uriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_interwiki_uriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_interwiki_uriContext)
}

func (s *Link_addressContext) Link_interwiki_pagename() ILink_interwiki_pagenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_interwiki_pagenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_interwiki_pagenameContext)
}

func (s *Link_addressContext) Link_uri() ILink_uriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_uriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_uriContext)
}

func (s *Link_addressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_addressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_addressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_address(s)
	}
}

func (s *Link_addressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_address(s)
	}
}

func (p *Creole10Parser) Link_address() (localctx ILink_addressContext) {
	localctx = NewLink_addressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Creole10ParserRULE_link_address)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(691)
			p.Link_interwiki_uri()
		}
		{
			p.SetState(692)
			p.Match(Creole10ParserT__0)
		}
		{
			p.SetState(693)
			p.Link_interwiki_pagename()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(695)
			p.Link_uri()
		}

	}

	return localctx
}

// ILink_interwiki_uriContext is an interface to support dynamic dispatch.
type ILink_interwiki_uriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_interwiki_uriContext differentiates from other interfaces.
	IsLink_interwiki_uriContext()
}

type Link_interwiki_uriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_interwiki_uriContext() *Link_interwiki_uriContext {
	var p = new(Link_interwiki_uriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_interwiki_uri
	return p
}

func (*Link_interwiki_uriContext) IsLink_interwiki_uriContext() {}

func NewLink_interwiki_uriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_interwiki_uriContext {
	var p = new(Link_interwiki_uriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_interwiki_uri

	return p
}

func (s *Link_interwiki_uriContext) GetParser() antlr.Parser { return s.parser }
func (s *Link_interwiki_uriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_interwiki_uriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_interwiki_uriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_interwiki_uri(s)
	}
}

func (s *Link_interwiki_uriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_interwiki_uri(s)
	}
}

func (p *Creole10Parser) Link_interwiki_uri() (localctx ILink_interwiki_uriContext) {
	localctx = NewLink_interwiki_uriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Creole10ParserRULE_link_interwiki_uri)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(Creole10ParserT__1)
	}
	{
		p.SetState(699)
		p.Match(Creole10ParserT__2)
	}

	return localctx
}

// ILink_interwiki_pagenameContext is an interface to support dynamic dispatch.
type ILink_interwiki_pagenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_interwiki_pagenameContext differentiates from other interfaces.
	IsLink_interwiki_pagenameContext()
}

type Link_interwiki_pagenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_interwiki_pagenameContext() *Link_interwiki_pagenameContext {
	var p = new(Link_interwiki_pagenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_interwiki_pagename
	return p
}

func (*Link_interwiki_pagenameContext) IsLink_interwiki_pagenameContext() {}

func NewLink_interwiki_pagenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_interwiki_pagenameContext {
	var p = new(Link_interwiki_pagenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_interwiki_pagename

	return p
}

func (s *Link_interwiki_pagenameContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_interwiki_pagenameContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Link_interwiki_pagenameContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Link_interwiki_pagenameContext) AllLINK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_CLOSE)
}

func (s *Link_interwiki_pagenameContext) LINK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, i)
}

func (s *Link_interwiki_pagenameContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Link_interwiki_pagenameContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Link_interwiki_pagenameContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Link_interwiki_pagenameContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Link_interwiki_pagenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_interwiki_pagenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_interwiki_pagenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_interwiki_pagename(s)
	}
}

func (s *Link_interwiki_pagenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_interwiki_pagename(s)
	}
}

func (p *Creole10Parser) Link_interwiki_pagename() (localctx ILink_interwiki_pagenameContext) {
	localctx = NewLink_interwiki_pagenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Creole10ParserRULE_link_interwiki_pagename)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(701)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserLINK_CLOSE - -1))|(1<<(Creole10ParserPIPE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(704)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILink_descriptionContext is an interface to support dynamic dispatch.
type ILink_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_descriptionContext differentiates from other interfaces.
	IsLink_descriptionContext()
}

type Link_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_descriptionContext() *Link_descriptionContext {
	var p = new(Link_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_description
	return p
}

func (*Link_descriptionContext) IsLink_descriptionContext() {}

func NewLink_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_descriptionContext {
	var p = new(Link_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_description

	return p
}

func (s *Link_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_descriptionContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Link_descriptionContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Link_descriptionContext) AllLink_descriptionpart() []ILink_descriptionpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_descriptionpartContext)(nil)).Elem())
	var tst = make([]ILink_descriptionpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_descriptionpartContext)
		}
	}

	return tst
}

func (s *Link_descriptionContext) Link_descriptionpart(i int) ILink_descriptionpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptionpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptionpartContext)
}

func (s *Link_descriptionContext) AllImage() []IImageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImageContext)(nil)).Elem())
	var tst = make([]IImageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImageContext)
		}
	}

	return tst
}

func (s *Link_descriptionContext) Image(i int) IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *Link_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_description(s)
	}
}

func (s *Link_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_description(s)
	}
}

func (p *Creole10Parser) Link_description() (localctx ILink_descriptionContext) {
	localctx = NewLink_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Creole10ParserRULE_link_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(710)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(706)
					p.Onestar()
				}
				{
					p.SetState(707)
					p.Link_descriptionpart()
				}

			case 2:
				{
					p.SetState(709)
					p.Image()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(712)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}

	return localctx
}

// ILink_descriptionpartContext is an interface to support dynamic dispatch.
type ILink_descriptionpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_descriptionpartContext differentiates from other interfaces.
	IsLink_descriptionpartContext()
}

type Link_descriptionpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_descriptionpartContext() *Link_descriptionpartContext {
	var p = new(Link_descriptionpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_descriptionpart
	return p
}

func (*Link_descriptionpartContext) IsLink_descriptionpartContext() {}

func NewLink_descriptionpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_descriptionpartContext {
	var p = new(Link_descriptionpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_descriptionpart

	return p
}

func (s *Link_descriptionpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_descriptionpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Link_descriptionpartContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Link_descriptionpartContext) AllLink_bold_descriptionpart() []ILink_bold_descriptionpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_bold_descriptionpartContext)(nil)).Elem())
	var tst = make([]ILink_bold_descriptionpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_bold_descriptionpartContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Link_bold_descriptionpart(i int) ILink_bold_descriptionpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_bold_descriptionpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_bold_descriptionpartContext)
}

func (s *Link_descriptionpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Link_descriptionpartContext) AllLink_ital_descriptionpart() []ILink_ital_descriptionpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_ital_descriptionpartContext)(nil)).Elem())
	var tst = make([]ILink_ital_descriptionpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_ital_descriptionpartContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Link_ital_descriptionpart(i int) ILink_ital_descriptionpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_ital_descriptionpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_ital_descriptionpartContext)
}

func (s *Link_descriptionpartContext) AllLink_descriptiontext() []ILink_descriptiontextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem())
	var tst = make([]ILink_descriptiontextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_descriptiontextContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Link_descriptiontext(i int) ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_descriptionpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_descriptionpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_descriptionpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_descriptionpart(s)
	}
}

func (s *Link_descriptionpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_descriptionpart(s)
	}
}

func (p *Creole10Parser) Link_descriptionpart() (localctx ILink_descriptionpartContext) {
	localctx = NewLink_descriptionpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Creole10ParserRULE_link_descriptionpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(714)
			p.Bold_markup()
		}
		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(715)
					p.Onestar()
				}
				{
					p.SetState(716)
					p.Link_bold_descriptionpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(720)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())
		}
		{
			p.SetState(722)
			p.Bold_markup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(724)
			p.Ital_markup()
		}
		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(725)
					p.Onestar()
				}
				{
					p.SetState(726)
					p.Link_ital_descriptionpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(730)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
		}
		{
			p.SetState(732)
			p.Ital_markup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(734)
					p.Onestar()
				}
				{
					p.SetState(735)
					p.Link_descriptiontext()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(739)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
		}
		{
			p.SetState(741)
			p.Onestar()
		}

	}

	return localctx
}

// ILink_bold_descriptionpartContext is an interface to support dynamic dispatch.
type ILink_bold_descriptionpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_bold_descriptionpartContext differentiates from other interfaces.
	IsLink_bold_descriptionpartContext()
}

type Link_bold_descriptionpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_bold_descriptionpartContext() *Link_bold_descriptionpartContext {
	var p = new(Link_bold_descriptionpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_bold_descriptionpart
	return p
}

func (*Link_bold_descriptionpartContext) IsLink_bold_descriptionpartContext() {}

func NewLink_bold_descriptionpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_bold_descriptionpartContext {
	var p = new(Link_bold_descriptionpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_bold_descriptionpart

	return p
}

func (s *Link_bold_descriptionpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_bold_descriptionpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Link_bold_descriptionpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Link_bold_descriptionpartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Link_bold_descriptionpartContext) Link_descriptiontext() ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_bold_descriptionpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_bold_descriptionpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_bold_descriptionpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_bold_descriptionpart(s)
	}
}

func (s *Link_bold_descriptionpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_bold_descriptionpart(s)
	}
}

func (p *Creole10Parser) Link_bold_descriptionpart() (localctx ILink_bold_descriptionpartContext) {
	localctx = NewLink_bold_descriptionpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Creole10ParserRULE_link_bold_descriptionpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(750)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(745)
			p.Ital_markup()
		}
		{
			p.SetState(746)
			p.Link_boldital_description()
		}
		{
			p.SetState(747)
			p.Ital_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(749)
			p.Link_descriptiontext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILink_ital_descriptionpartContext is an interface to support dynamic dispatch.
type ILink_ital_descriptionpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_ital_descriptionpartContext differentiates from other interfaces.
	IsLink_ital_descriptionpartContext()
}

type Link_ital_descriptionpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_ital_descriptionpartContext() *Link_ital_descriptionpartContext {
	var p = new(Link_ital_descriptionpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_ital_descriptionpart
	return p
}

func (*Link_ital_descriptionpartContext) IsLink_ital_descriptionpartContext() {}

func NewLink_ital_descriptionpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_ital_descriptionpartContext {
	var p = new(Link_ital_descriptionpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_ital_descriptionpart

	return p
}

func (s *Link_ital_descriptionpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_ital_descriptionpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Link_ital_descriptionpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Link_ital_descriptionpartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Link_ital_descriptionpartContext) Link_descriptiontext() ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_ital_descriptionpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_ital_descriptionpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_ital_descriptionpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_ital_descriptionpart(s)
	}
}

func (s *Link_ital_descriptionpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_ital_descriptionpart(s)
	}
}

func (p *Creole10Parser) Link_ital_descriptionpart() (localctx ILink_ital_descriptionpartContext) {
	localctx = NewLink_ital_descriptionpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Creole10ParserRULE_link_ital_descriptionpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(757)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)
			p.Bold_markup()
		}
		{
			p.SetState(753)
			p.Link_boldital_description()
		}
		{
			p.SetState(754)
			p.Bold_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Link_descriptiontext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILink_boldital_descriptionContext is an interface to support dynamic dispatch.
type ILink_boldital_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_boldital_descriptionContext differentiates from other interfaces.
	IsLink_boldital_descriptionContext()
}

type Link_boldital_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_boldital_descriptionContext() *Link_boldital_descriptionContext {
	var p = new(Link_boldital_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_boldital_description
	return p
}

func (*Link_boldital_descriptionContext) IsLink_boldital_descriptionContext() {}

func NewLink_boldital_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_boldital_descriptionContext {
	var p = new(Link_boldital_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_boldital_description

	return p
}

func (s *Link_boldital_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_boldital_descriptionContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Link_boldital_descriptionContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Link_boldital_descriptionContext) AllLink_descriptiontext() []ILink_descriptiontextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem())
	var tst = make([]ILink_descriptiontextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_descriptiontextContext)
		}
	}

	return tst
}

func (s *Link_boldital_descriptionContext) Link_descriptiontext(i int) ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_boldital_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_boldital_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_boldital_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_boldital_description(s)
	}
}

func (s *Link_boldital_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_boldital_description(s)
	}
}

func (p *Creole10Parser) Link_boldital_description() (localctx ILink_boldital_descriptionContext) {
	localctx = NewLink_boldital_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Creole10ParserRULE_link_boldital_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(759)
				p.Onestar()
			}
			{
				p.SetState(760)
				p.Link_descriptiontext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())
	}
	{
		p.SetState(766)
		p.Onestar()
	}

	return localctx
}

// ILink_descriptiontextContext is an interface to support dynamic dispatch.
type ILink_descriptiontextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_descriptiontextContext differentiates from other interfaces.
	IsLink_descriptiontextContext()
}

type Link_descriptiontextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_descriptiontextContext() *Link_descriptiontextContext {
	var p = new(Link_descriptiontextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_descriptiontext
	return p
}

func (*Link_descriptiontextContext) IsLink_descriptiontextContext() {}

func NewLink_descriptiontextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_descriptiontextContext {
	var p = new(Link_descriptiontextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_descriptiontext

	return p
}

func (s *Link_descriptiontextContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_descriptiontextContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Link_descriptiontextContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Link_descriptiontextContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Link_descriptiontextContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Link_descriptiontextContext) AllLINK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_CLOSE)
}

func (s *Link_descriptiontextContext) LINK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, i)
}

func (s *Link_descriptiontextContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Link_descriptiontextContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Link_descriptiontextContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Link_descriptiontextContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Link_descriptiontextContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Link_descriptiontextContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Link_descriptiontextContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Link_descriptiontextContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Link_descriptiontextContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Link_descriptiontextContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Link_descriptiontextContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Link_descriptiontextContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Link_descriptiontextContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Link_descriptiontextContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Link_descriptiontextContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Link_descriptiontextContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Link_descriptiontextContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Link_descriptiontextContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Link_descriptiontextContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Link_descriptiontextContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Link_descriptiontextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_descriptiontextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_descriptiontextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_descriptiontext(s)
	}
}

func (s *Link_descriptiontextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_descriptiontext(s)
	}
}

func (p *Creole10Parser) Link_descriptiontext() (localctx ILink_descriptiontextContext) {
	localctx = NewLink_descriptiontextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Creole10ParserRULE_link_descriptiontext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(771)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(768)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserLINK_CLOSE - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(769)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(770)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}

	return localctx
}

// ILink_uriContext is an interface to support dynamic dispatch.
type ILink_uriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_uriContext differentiates from other interfaces.
	IsLink_uriContext()
}

type Link_uriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_uriContext() *Link_uriContext {
	var p = new(Link_uriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_uri
	return p
}

func (*Link_uriContext) IsLink_uriContext() {}

func NewLink_uriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_uriContext {
	var p = new(Link_uriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_uri

	return p
}

func (s *Link_uriContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_uriContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Link_uriContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Link_uriContext) AllLINK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_CLOSE)
}

func (s *Link_uriContext) LINK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, i)
}

func (s *Link_uriContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Link_uriContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Link_uriContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Link_uriContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Link_uriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_uriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_uriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_uri(s)
	}
}

func (s *Link_uriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_uri(s)
	}
}

func (p *Creole10Parser) Link_uri() (localctx ILink_uriContext) {
	localctx = NewLink_uriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Creole10ParserRULE_link_uri)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(776)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(775)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserLINK_CLOSE - -1))|(1<<(Creole10ParserPIPE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImageContext is an interface to support dynamic dispatch.
type IImageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImageContext differentiates from other interfaces.
	IsImageContext()
}

type ImageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImageContext() *ImageContext {
	var p = new(ImageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image
	return p
}

func (*ImageContext) IsImageContext() {}

func NewImageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImageContext {
	var p = new(ImageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image

	return p
}

func (s *ImageContext) GetParser() antlr.Parser { return s.parser }

func (s *ImageContext) Image_open_markup() IImage_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_open_markupContext)
}

func (s *ImageContext) Image_uri() IImage_uriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_uriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_uriContext)
}

func (s *ImageContext) Image_close_markup() IImage_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_close_markupContext)
}

func (s *ImageContext) Image_alternative() IImage_alternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativeContext)
}

func (s *ImageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage(s)
	}
}

func (s *ImageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage(s)
	}
}

func (p *Creole10Parser) Image() (localctx IImageContext) {
	localctx = NewImageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Creole10ParserRULE_image)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Image_open_markup()
	}
	{
		p.SetState(781)
		p.Image_uri()
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserPIPE {
		{
			p.SetState(782)
			p.Image_alternative()
		}

	}
	{
		p.SetState(785)
		p.Image_close_markup()
	}

	return localctx
}

// IImage_uriContext is an interface to support dynamic dispatch.
type IImage_uriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_uriContext differentiates from other interfaces.
	IsImage_uriContext()
}

type Image_uriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_uriContext() *Image_uriContext {
	var p = new(Image_uriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_uri
	return p
}

func (*Image_uriContext) IsImage_uriContext() {}

func NewImage_uriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_uriContext {
	var p = new(Image_uriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_uri

	return p
}

func (s *Image_uriContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_uriContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Image_uriContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Image_uriContext) AllIMAGE_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_CLOSE)
}

func (s *Image_uriContext) IMAGE_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_CLOSE, i)
}

func (s *Image_uriContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Image_uriContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Image_uriContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Image_uriContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Image_uriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_uriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_uriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_uri(s)
	}
}

func (s *Image_uriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_uri(s)
	}
}

func (p *Creole10Parser) Image_uri() (localctx IImage_uriContext) {
	localctx = NewImage_uriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Creole10ParserRULE_image_uri)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(787)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserIMAGE_CLOSE - -1))|(1<<(Creole10ParserPIPE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImage_alternativeContext is an interface to support dynamic dispatch.
type IImage_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternativeContext differentiates from other interfaces.
	IsImage_alternativeContext()
}

type Image_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternativeContext() *Image_alternativeContext {
	var p = new(Image_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternative
	return p
}

func (*Image_alternativeContext) IsImage_alternativeContext() {}

func NewImage_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternativeContext {
	var p = new(Image_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternative

	return p
}

func (s *Image_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternativeContext) Image_alternative_markup() IImage_alternative_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternative_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternative_markupContext)
}

func (s *Image_alternativeContext) AllImage_alternativepart() []IImage_alternativepartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_alternativepartContext)(nil)).Elem())
	var tst = make([]IImage_alternativepartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_alternativepartContext)
		}
	}

	return tst
}

func (s *Image_alternativeContext) Image_alternativepart(i int) IImage_alternativepartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativepartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativepartContext)
}

func (s *Image_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternative(s)
	}
}

func (s *Image_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternative(s)
	}
}

func (p *Creole10Parser) Image_alternative() (localctx IImage_alternativeContext) {
	localctx = NewImage_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Creole10ParserRULE_image_alternative)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Image_alternative_markup()
	}
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		{
			p.SetState(793)
			p.Image_alternativepart()
		}

		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImage_alternativepartContext is an interface to support dynamic dispatch.
type IImage_alternativepartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternativepartContext differentiates from other interfaces.
	IsImage_alternativepartContext()
}

type Image_alternativepartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternativepartContext() *Image_alternativepartContext {
	var p = new(Image_alternativepartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternativepart
	return p
}

func (*Image_alternativepartContext) IsImage_alternativepartContext() {}

func NewImage_alternativepartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternativepartContext {
	var p = new(Image_alternativepartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternativepart

	return p
}

func (s *Image_alternativepartContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternativepartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Image_alternativepartContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Image_alternativepartContext) AllImage_bold_alternativepart() []IImage_bold_alternativepartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_bold_alternativepartContext)(nil)).Elem())
	var tst = make([]IImage_bold_alternativepartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_bold_alternativepartContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Image_bold_alternativepart(i int) IImage_bold_alternativepartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_bold_alternativepartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_bold_alternativepartContext)
}

func (s *Image_alternativepartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Image_alternativepartContext) AllImage_ital_alternativepart() []IImage_ital_alternativepartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_ital_alternativepartContext)(nil)).Elem())
	var tst = make([]IImage_ital_alternativepartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_ital_alternativepartContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Image_ital_alternativepart(i int) IImage_ital_alternativepartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_ital_alternativepartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_ital_alternativepartContext)
}

func (s *Image_alternativepartContext) Image_alternativetext() IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_alternativepartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternativepartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternativepartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternativepart(s)
	}
}

func (s *Image_alternativepartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternativepart(s)
	}
}

func (p *Creole10Parser) Image_alternativepart() (localctx IImage_alternativepartContext) {
	localctx = NewImage_alternativepartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Creole10ParserRULE_image_alternativepart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(819)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(798)
			p.Bold_markup()
		}
		p.SetState(802)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(799)
					p.Onestar()
				}
				{
					p.SetState(800)
					p.Image_bold_alternativepart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(804)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())
		}
		{
			p.SetState(806)
			p.Bold_markup()
		}

	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.Ital_markup()
		}
		p.SetState(812)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(809)
					p.Onestar()
				}
				{
					p.SetState(810)
					p.Image_ital_alternativepart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(814)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
		}
		{
			p.SetState(816)
			p.Ital_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(818)
			p.Image_alternativetext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImage_bold_alternativepartContext is an interface to support dynamic dispatch.
type IImage_bold_alternativepartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_bold_alternativepartContext differentiates from other interfaces.
	IsImage_bold_alternativepartContext()
}

type Image_bold_alternativepartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_bold_alternativepartContext() *Image_bold_alternativepartContext {
	var p = new(Image_bold_alternativepartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_bold_alternativepart
	return p
}

func (*Image_bold_alternativepartContext) IsImage_bold_alternativepartContext() {}

func NewImage_bold_alternativepartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_bold_alternativepartContext {
	var p = new(Image_bold_alternativepartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_bold_alternativepart

	return p
}

func (s *Image_bold_alternativepartContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_bold_alternativepartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Image_bold_alternativepartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Image_bold_alternativepartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Image_bold_alternativepartContext) Image_alternativetext() IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_bold_alternativepartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_bold_alternativepartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_bold_alternativepartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_bold_alternativepart(s)
	}
}

func (s *Image_bold_alternativepartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_bold_alternativepart(s)
	}
}

func (p *Creole10Parser) Image_bold_alternativepart() (localctx IImage_bold_alternativepartContext) {
	localctx = NewImage_bold_alternativepartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Creole10ParserRULE_image_bold_alternativepart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(826)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(821)
			p.Ital_markup()
		}
		{
			p.SetState(822)
			p.Link_boldital_description()
		}
		{
			p.SetState(823)
			p.Ital_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)
			p.Image_alternativetext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImage_ital_alternativepartContext is an interface to support dynamic dispatch.
type IImage_ital_alternativepartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_ital_alternativepartContext differentiates from other interfaces.
	IsImage_ital_alternativepartContext()
}

type Image_ital_alternativepartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_ital_alternativepartContext() *Image_ital_alternativepartContext {
	var p = new(Image_ital_alternativepartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_ital_alternativepart
	return p
}

func (*Image_ital_alternativepartContext) IsImage_ital_alternativepartContext() {}

func NewImage_ital_alternativepartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_ital_alternativepartContext {
	var p = new(Image_ital_alternativepartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_ital_alternativepart

	return p
}

func (s *Image_ital_alternativepartContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_ital_alternativepartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Image_ital_alternativepartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Image_ital_alternativepartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Image_ital_alternativepartContext) Image_alternativetext() IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_ital_alternativepartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_ital_alternativepartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_ital_alternativepartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_ital_alternativepart(s)
	}
}

func (s *Image_ital_alternativepartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_ital_alternativepart(s)
	}
}

func (p *Creole10Parser) Image_ital_alternativepart() (localctx IImage_ital_alternativepartContext) {
	localctx = NewImage_ital_alternativepartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Creole10ParserRULE_image_ital_alternativepart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(833)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(828)
			p.Bold_markup()
		}
		{
			p.SetState(829)
			p.Link_boldital_description()
		}
		{
			p.SetState(830)
			p.Bold_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(832)
			p.Image_alternativetext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImage_boldital_alternativeContext is an interface to support dynamic dispatch.
type IImage_boldital_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_boldital_alternativeContext differentiates from other interfaces.
	IsImage_boldital_alternativeContext()
}

type Image_boldital_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_boldital_alternativeContext() *Image_boldital_alternativeContext {
	var p = new(Image_boldital_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_boldital_alternative
	return p
}

func (*Image_boldital_alternativeContext) IsImage_boldital_alternativeContext() {}

func NewImage_boldital_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_boldital_alternativeContext {
	var p = new(Image_boldital_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_boldital_alternative

	return p
}

func (s *Image_boldital_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_boldital_alternativeContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Image_boldital_alternativeContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Image_boldital_alternativeContext) AllImage_alternativetext() []IImage_alternativetextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem())
	var tst = make([]IImage_alternativetextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_alternativetextContext)
		}
	}

	return tst
}

func (s *Image_boldital_alternativeContext) Image_alternativetext(i int) IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_boldital_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_boldital_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_boldital_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_boldital_alternative(s)
	}
}

func (s *Image_boldital_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_boldital_alternative(s)
	}
}

func (p *Creole10Parser) Image_boldital_alternative() (localctx IImage_boldital_alternativeContext) {
	localctx = NewImage_boldital_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Creole10ParserRULE_image_boldital_alternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(835)
				p.Onestar()
			}
			{
				p.SetState(836)
				p.Image_alternativetext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
	}
	{
		p.SetState(842)
		p.Onestar()
	}

	return localctx
}

// IImage_alternativetextContext is an interface to support dynamic dispatch.
type IImage_alternativetextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternativetextContext differentiates from other interfaces.
	IsImage_alternativetextContext()
}

type Image_alternativetextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternativetextContext() *Image_alternativetextContext {
	var p = new(Image_alternativetextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternativetext
	return p
}

func (*Image_alternativetextContext) IsImage_alternativetextContext() {}

func NewImage_alternativetextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternativetextContext {
	var p = new(Image_alternativetextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternativetext

	return p
}

func (s *Image_alternativetextContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternativetextContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Image_alternativetextContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Image_alternativetextContext) AllIMAGE_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_CLOSE)
}

func (s *Image_alternativetextContext) IMAGE_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_CLOSE, i)
}

func (s *Image_alternativetextContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Image_alternativetextContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Image_alternativetextContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Image_alternativetextContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Image_alternativetextContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Image_alternativetextContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Image_alternativetextContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Image_alternativetextContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Image_alternativetextContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Image_alternativetextContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Image_alternativetextContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Image_alternativetextContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Image_alternativetextContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Image_alternativetextContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Image_alternativetextContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Image_alternativetextContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Image_alternativetextContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Image_alternativetextContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Image_alternativetextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternativetextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternativetextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternativetext(s)
	}
}

func (s *Image_alternativetextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternativetext(s)
	}
}

func (p *Creole10Parser) Image_alternativetext() (localctx IImage_alternativetextContext) {
	localctx = NewImage_alternativetextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Creole10ParserRULE_image_alternativetext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(846)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(844)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserIMAGE_CLOSE - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(845)
					p.Forced_linebreak()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(848)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionContext is an interface to support dynamic dispatch.
type IExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionContext differentiates from other interfaces.
	IsExtensionContext()
}

type ExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionContext() *ExtensionContext {
	var p = new(ExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension
	return p
}

func (*ExtensionContext) IsExtensionContext() {}

func NewExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionContext {
	var p = new(ExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension

	return p
}

func (s *ExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionContext) AllExtension_markup() []IExtension_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtension_markupContext)(nil)).Elem())
	var tst = make([]IExtension_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtension_markupContext)
		}
	}

	return tst
}

func (s *ExtensionContext) Extension_markup(i int) IExtension_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtension_markupContext)
}

func (s *ExtensionContext) Extension_handler() IExtension_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_handlerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtension_handlerContext)
}

func (s *ExtensionContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *ExtensionContext) Extension_statement() IExtension_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtension_statementContext)
}

func (s *ExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension(s)
	}
}

func (s *ExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension(s)
	}
}

func (p *Creole10Parser) Extension() (localctx IExtensionContext) {
	localctx = NewExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Creole10ParserRULE_extension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(850)
		p.Extension_markup()
	}
	{
		p.SetState(851)
		p.Extension_handler()
	}
	{
		p.SetState(852)
		p.Blanks()
	}
	{
		p.SetState(853)
		p.Extension_statement()
	}
	{
		p.SetState(854)
		p.Extension_markup()
	}

	return localctx
}

// IExtension_handlerContext is an interface to support dynamic dispatch.
type IExtension_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_handlerContext differentiates from other interfaces.
	IsExtension_handlerContext()
}

type Extension_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_handlerContext() *Extension_handlerContext {
	var p = new(Extension_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension_handler
	return p
}

func (*Extension_handlerContext) IsExtension_handlerContext() {}

func NewExtension_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_handlerContext {
	var p = new(Extension_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension_handler

	return p
}

func (s *Extension_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_handlerContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Extension_handlerContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Extension_handlerContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Extension_handlerContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Extension_handlerContext) AllBLANKS() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserBLANKS)
}

func (s *Extension_handlerContext) BLANKS(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserBLANKS, i)
}

func (s *Extension_handlerContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Extension_handlerContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Extension_handlerContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Extension_handlerContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Extension_handlerContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Extension_handlerContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Extension_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension_handler(s)
	}
}

func (s *Extension_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension_handler(s)
	}
}

func (p *Creole10Parser) Extension_handler() (localctx IExtension_handlerContext) {
	localctx = NewExtension_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Creole10ParserRULE_extension_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(858)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
			p.SetState(856)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserBLANKS - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

		case Creole10ParserESCAPE:
			{
				p.SetState(857)
				p.Escaped()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExtension_statementContext is an interface to support dynamic dispatch.
type IExtension_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_statementContext differentiates from other interfaces.
	IsExtension_statementContext()
}

type Extension_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_statementContext() *Extension_statementContext {
	var p = new(Extension_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension_statement
	return p
}

func (*Extension_statementContext) IsExtension_statementContext() {}

func NewExtension_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_statementContext {
	var p = new(Extension_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension_statement

	return p
}

func (s *Extension_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_statementContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Extension_statementContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Extension_statementContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Extension_statementContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Extension_statementContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Extension_statementContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Extension_statementContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Extension_statementContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Extension_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension_statement(s)
	}
}

func (s *Extension_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension_statement(s)
	}
}

func (p *Creole10Parser) Extension_statement() (localctx IExtension_statementContext) {
	localctx = NewExtension_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Creole10ParserRULE_extension_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(866)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserNEWLINE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		p.SetState(864)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserNEWLINE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
			p.SetState(862)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

		case Creole10ParserESCAPE:
			{
				p.SetState(863)
				p.Escaped()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEscapedContext is an interface to support dynamic dispatch.
type IEscapedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscapedContext differentiates from other interfaces.
	IsEscapedContext()
}

type EscapedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedContext() *EscapedContext {
	var p = new(EscapedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_escaped
	return p
}

func (*EscapedContext) IsEscapedContext() {}

func NewEscapedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedContext {
	var p = new(EscapedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_escaped

	return p
}

func (s *EscapedContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, 0)
}

func (s *EscapedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *EscapedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *EscapedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterEscaped(s)
	}
}

func (s *EscapedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitEscaped(s)
	}
}

func (p *Creole10Parser) Escaped() (localctx IEscapedContext) {
	localctx = NewEscapedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Creole10ParserRULE_escaped)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(869)
			p.Match(Creole10ParserESCAPE)
		}
		{
			p.SetState(870)
			p.Match(Creole10ParserSTAR)
		}
		{
			p.SetState(871)
			p.Match(Creole10ParserSTAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(872)
			p.Match(Creole10ParserESCAPE)
		}
		p.SetState(873)
		p.MatchWildcard()

	}

	return localctx
}

// IParagraph_separatorContext is an interface to support dynamic dispatch.
type IParagraph_separatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraph_separatorContext differentiates from other interfaces.
	IsParagraph_separatorContext()
}

type Paragraph_separatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraph_separatorContext() *Paragraph_separatorContext {
	var p = new(Paragraph_separatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_paragraph_separator
	return p
}

func (*Paragraph_separatorContext) IsParagraph_separatorContext() {}

func NewParagraph_separatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Paragraph_separatorContext {
	var p = new(Paragraph_separatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_paragraph_separator

	return p
}

func (s *Paragraph_separatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Paragraph_separatorContext) AllNewline() []INewlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INewlineContext)(nil)).Elem())
	var tst = make([]INewlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INewlineContext)
		}
	}

	return tst
}

func (s *Paragraph_separatorContext) Newline(i int) INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Paragraph_separatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Paragraph_separatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Paragraph_separatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Paragraph_separatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterParagraph_separator(s)
	}
}

func (s *Paragraph_separatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitParagraph_separator(s)
	}
}

func (p *Creole10Parser) Paragraph_separator() (localctx IParagraph_separatorContext) {
	localctx = NewParagraph_separatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Creole10ParserRULE_paragraph_separator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(882)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(876)
					p.Newline()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(879)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(881)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhitespacesContext is an interface to support dynamic dispatch.
type IWhitespacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhitespacesContext differentiates from other interfaces.
	IsWhitespacesContext()
}

type WhitespacesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhitespacesContext() *WhitespacesContext {
	var p = new(WhitespacesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_whitespaces
	return p
}

func (*WhitespacesContext) IsWhitespacesContext() {}

func NewWhitespacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhitespacesContext {
	var p = new(WhitespacesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_whitespaces

	return p
}

func (s *WhitespacesContext) GetParser() antlr.Parser { return s.parser }

func (s *WhitespacesContext) AllBlanks() []IBlanksContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlanksContext)(nil)).Elem())
	var tst = make([]IBlanksContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlanksContext)
		}
	}

	return tst
}

func (s *WhitespacesContext) Blanks(i int) IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *WhitespacesContext) AllNewline() []INewlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INewlineContext)(nil)).Elem())
	var tst = make([]INewlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INewlineContext)
		}
	}

	return tst
}

func (s *WhitespacesContext) Newline(i int) INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *WhitespacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhitespacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhitespacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterWhitespaces(s)
	}
}

func (s *WhitespacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitWhitespaces(s)
	}
}

func (p *Creole10Parser) Whitespaces() (localctx IWhitespacesContext) {
	localctx = NewWhitespacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Creole10ParserRULE_whitespaces)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(886)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserBLANKS:
				{
					p.SetState(884)
					p.Blanks()
				}

			case Creole10ParserNEWLINE:
				{
					p.SetState(885)
					p.Newline()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
	}

	return localctx
}

// IBlanksContext is an interface to support dynamic dispatch.
type IBlanksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlanksContext differentiates from other interfaces.
	IsBlanksContext()
}

type BlanksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlanksContext() *BlanksContext {
	var p = new(BlanksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_blanks
	return p
}

func (*BlanksContext) IsBlanksContext() {}

func NewBlanksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlanksContext {
	var p = new(BlanksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_blanks

	return p
}

func (s *BlanksContext) GetParser() antlr.Parser { return s.parser }

func (s *BlanksContext) BLANKS() antlr.TerminalNode {
	return s.GetToken(Creole10ParserBLANKS, 0)
}

func (s *BlanksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlanksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlanksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterBlanks(s)
	}
}

func (s *BlanksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitBlanks(s)
	}
}

func (p *Creole10Parser) Blanks() (localctx IBlanksContext) {
	localctx = NewBlanksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Creole10ParserRULE_blanks)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(Creole10ParserBLANKS)
	}

	return localctx
}

// IText_lineseparatorContext is an interface to support dynamic dispatch.
type IText_lineseparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_lineseparatorContext differentiates from other interfaces.
	IsText_lineseparatorContext()
}

type Text_lineseparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_lineseparatorContext() *Text_lineseparatorContext {
	var p = new(Text_lineseparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_lineseparator
	return p
}

func (*Text_lineseparatorContext) IsText_lineseparatorContext() {}

func NewText_lineseparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_lineseparatorContext {
	var p = new(Text_lineseparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_lineseparator

	return p
}

func (s *Text_lineseparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_lineseparatorContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Text_lineseparatorContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *Text_lineseparatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_lineseparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_lineseparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_lineseparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_lineseparator(s)
	}
}

func (s *Text_lineseparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_lineseparator(s)
	}
}

func (p *Creole10Parser) Text_lineseparator() (localctx IText_lineseparatorContext) {
	localctx = NewText_lineseparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Creole10ParserRULE_text_lineseparator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(897)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(892)
			p.Newline()
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(893)
				p.Blanks()
			}

		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(896)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INewlineContext is an interface to support dynamic dispatch.
type INewlineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewlineContext differentiates from other interfaces.
	IsNewlineContext()
}

type NewlineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewlineContext() *NewlineContext {
	var p = new(NewlineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_newline
	return p
}

func (*NewlineContext) IsNewlineContext() {}

func NewNewlineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewlineContext {
	var p = new(NewlineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_newline

	return p
}

func (s *NewlineContext) GetParser() antlr.Parser { return s.parser }

func (s *NewlineContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, 0)
}

func (s *NewlineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewlineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewlineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNewline(s)
	}
}

func (s *NewlineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNewline(s)
	}
}

func (p *Creole10Parser) Newline() (localctx INewlineContext) {
	localctx = NewNewlineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Creole10ParserRULE_newline)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(899)
		p.Match(Creole10ParserNEWLINE)
	}

	return localctx
}

// IBold_markupContext is an interface to support dynamic dispatch.
type IBold_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBold_markupContext differentiates from other interfaces.
	IsBold_markupContext()
}

type Bold_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBold_markupContext() *Bold_markupContext {
	var p = new(Bold_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_bold_markup
	return p
}

func (*Bold_markupContext) IsBold_markupContext() {}

func NewBold_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bold_markupContext {
	var p = new(Bold_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_bold_markup

	return p
}

func (s *Bold_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Bold_markupContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Bold_markupContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Bold_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bold_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bold_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterBold_markup(s)
	}
}

func (s *Bold_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitBold_markup(s)
	}
}

func (p *Creole10Parser) Bold_markup() (localctx IBold_markupContext) {
	localctx = NewBold_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Creole10ParserRULE_bold_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.Match(Creole10ParserSTAR)
	}
	{
		p.SetState(902)
		p.Match(Creole10ParserSTAR)
	}

	return localctx
}

// IItal_markupContext is an interface to support dynamic dispatch.
type IItal_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsItal_markupContext differentiates from other interfaces.
	IsItal_markupContext()
}

type Ital_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItal_markupContext() *Ital_markupContext {
	var p = new(Ital_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_ital_markup
	return p
}

func (*Ital_markupContext) IsItal_markupContext() {}

func NewItal_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ital_markupContext {
	var p = new(Ital_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_ital_markup

	return p
}

func (s *Ital_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Ital_markupContext) ITAL() antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, 0)
}

func (s *Ital_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ital_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ital_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterItal_markup(s)
	}
}

func (s *Ital_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitItal_markup(s)
	}
}

func (p *Creole10Parser) Ital_markup() (localctx IItal_markupContext) {
	localctx = NewItal_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Creole10ParserRULE_ital_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		p.Match(Creole10ParserITAL)
	}

	return localctx
}

// IHeading_markupContext is an interface to support dynamic dispatch.
type IHeading_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeading_markupContext differentiates from other interfaces.
	IsHeading_markupContext()
}

type Heading_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeading_markupContext() *Heading_markupContext {
	var p = new(Heading_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_heading_markup
	return p
}

func (*Heading_markupContext) IsHeading_markupContext() {}

func NewHeading_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Heading_markupContext {
	var p = new(Heading_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_heading_markup

	return p
}

func (s *Heading_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Heading_markupContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, 0)
}

func (s *Heading_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Heading_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Heading_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHeading_markup(s)
	}
}

func (s *Heading_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHeading_markup(s)
	}
}

func (p *Creole10Parser) Heading_markup() (localctx IHeading_markupContext) {
	localctx = NewHeading_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Creole10ParserRULE_heading_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.Match(Creole10ParserEQUAL)
	}

	return localctx
}

// IList_ordelem_markupContext is an interface to support dynamic dispatch.
type IList_ordelem_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ordelem_markupContext differentiates from other interfaces.
	IsList_ordelem_markupContext()
}

type List_ordelem_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ordelem_markupContext() *List_ordelem_markupContext {
	var p = new(List_ordelem_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_ordelem_markup
	return p
}

func (*List_ordelem_markupContext) IsList_ordelem_markupContext() {}

func NewList_ordelem_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ordelem_markupContext {
	var p = new(List_ordelem_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_ordelem_markup

	return p
}

func (s *List_ordelem_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ordelem_markupContext) POUND() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPOUND, 0)
}

func (s *List_ordelem_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ordelem_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_ordelem_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_ordelem_markup(s)
	}
}

func (s *List_ordelem_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_ordelem_markup(s)
	}
}

func (p *Creole10Parser) List_ordelem_markup() (localctx IList_ordelem_markupContext) {
	localctx = NewList_ordelem_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Creole10ParserRULE_list_ordelem_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.Match(Creole10ParserPOUND)
	}

	return localctx
}

// IList_unordelem_markupContext is an interface to support dynamic dispatch.
type IList_unordelem_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_unordelem_markupContext differentiates from other interfaces.
	IsList_unordelem_markupContext()
}

type List_unordelem_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_unordelem_markupContext() *List_unordelem_markupContext {
	var p = new(List_unordelem_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_unordelem_markup
	return p
}

func (*List_unordelem_markupContext) IsList_unordelem_markupContext() {}

func NewList_unordelem_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_unordelem_markupContext {
	var p = new(List_unordelem_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_unordelem_markup

	return p
}

func (s *List_unordelem_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *List_unordelem_markupContext) STAR() antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, 0)
}

func (s *List_unordelem_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_unordelem_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_unordelem_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_unordelem_markup(s)
	}
}

func (s *List_unordelem_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_unordelem_markup(s)
	}
}

func (p *Creole10Parser) List_unordelem_markup() (localctx IList_unordelem_markupContext) {
	localctx = NewList_unordelem_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Creole10ParserRULE_list_unordelem_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.Match(Creole10ParserSTAR)
	}

	return localctx
}

// IList_elemseparatorContext is an interface to support dynamic dispatch.
type IList_elemseparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemseparatorContext differentiates from other interfaces.
	IsList_elemseparatorContext()
}

type List_elemseparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemseparatorContext() *List_elemseparatorContext {
	var p = new(List_elemseparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elemseparator
	return p
}

func (*List_elemseparatorContext) IsList_elemseparatorContext() {}

func NewList_elemseparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemseparatorContext {
	var p = new(List_elemseparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elemseparator

	return p
}

func (s *List_elemseparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemseparatorContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *List_elemseparatorContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *List_elemseparatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *List_elemseparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemseparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemseparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elemseparator(s)
	}
}

func (s *List_elemseparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elemseparator(s)
	}
}

func (p *Creole10Parser) List_elemseparator() (localctx IList_elemseparatorContext) {
	localctx = NewList_elemseparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Creole10ParserRULE_list_elemseparator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(917)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(912)
			p.Newline()
		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(913)
				p.Blanks()
			}

		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(916)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnd_of_listContext is an interface to support dynamic dispatch.
type IEnd_of_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnd_of_listContext differentiates from other interfaces.
	IsEnd_of_listContext()
}

type End_of_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_of_listContext() *End_of_listContext {
	var p = new(End_of_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_end_of_list
	return p
}

func (*End_of_listContext) IsEnd_of_listContext() {}

func NewEnd_of_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_of_listContext {
	var p = new(End_of_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_end_of_list

	return p
}

func (s *End_of_listContext) GetParser() antlr.Parser { return s.parser }

func (s *End_of_listContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *End_of_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *End_of_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_of_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_of_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterEnd_of_list(s)
	}
}

func (s *End_of_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitEnd_of_list(s)
	}
}

func (p *Creole10Parser) End_of_list() (localctx IEnd_of_listContext) {
	localctx = NewEnd_of_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Creole10ParserRULE_end_of_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(921)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Newline()
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_cell_markupContext is an interface to support dynamic dispatch.
type ITable_cell_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cell_markupContext differentiates from other interfaces.
	IsTable_cell_markupContext()
}

type Table_cell_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cell_markupContext() *Table_cell_markupContext {
	var p = new(Table_cell_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cell_markup
	return p
}

func (*Table_cell_markupContext) IsTable_cell_markupContext() {}

func NewTable_cell_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cell_markupContext {
	var p = new(Table_cell_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cell_markup

	return p
}

func (s *Table_cell_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cell_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Table_cell_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cell_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cell_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cell_markup(s)
	}
}

func (s *Table_cell_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cell_markup(s)
	}
}

func (p *Creole10Parser) Table_cell_markup() (localctx ITable_cell_markupContext) {
	localctx = NewTable_cell_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Creole10ParserRULE_table_cell_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(923)
		p.Match(Creole10ParserPIPE)
	}

	return localctx
}

// ITable_headercell_markupContext is an interface to support dynamic dispatch.
type ITable_headercell_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_headercell_markupContext differentiates from other interfaces.
	IsTable_headercell_markupContext()
}

type Table_headercell_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_headercell_markupContext() *Table_headercell_markupContext {
	var p = new(Table_headercell_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_headercell_markup
	return p
}

func (*Table_headercell_markupContext) IsTable_headercell_markupContext() {}

func NewTable_headercell_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_headercell_markupContext {
	var p = new(Table_headercell_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_headercell_markup

	return p
}

func (s *Table_headercell_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_headercell_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Table_headercell_markupContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, 0)
}

func (s *Table_headercell_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_headercell_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_headercell_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_headercell_markup(s)
	}
}

func (s *Table_headercell_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_headercell_markup(s)
	}
}

func (p *Creole10Parser) Table_headercell_markup() (localctx ITable_headercell_markupContext) {
	localctx = NewTable_headercell_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Creole10ParserRULE_table_headercell_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.Match(Creole10ParserPIPE)
	}
	{
		p.SetState(926)
		p.Match(Creole10ParserEQUAL)
	}

	return localctx
}

// ITable_rowseparatorContext is an interface to support dynamic dispatch.
type ITable_rowseparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_rowseparatorContext differentiates from other interfaces.
	IsTable_rowseparatorContext()
}

type Table_rowseparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowseparatorContext() *Table_rowseparatorContext {
	var p = new(Table_rowseparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_rowseparator
	return p
}

func (*Table_rowseparatorContext) IsTable_rowseparatorContext() {}

func NewTable_rowseparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowseparatorContext {
	var p = new(Table_rowseparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_rowseparator

	return p
}

func (s *Table_rowseparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowseparatorContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Table_rowseparatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_rowseparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowseparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_rowseparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_rowseparator(s)
	}
}

func (s *Table_rowseparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_rowseparator(s)
	}
}

func (p *Creole10Parser) Table_rowseparator() (localctx ITable_rowseparatorContext) {
	localctx = NewTable_rowseparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Creole10ParserRULE_table_rowseparator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(930)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Newline()
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(929)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INowiki_open_markupContext is an interface to support dynamic dispatch.
type INowiki_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_open_markupContext differentiates from other interfaces.
	IsNowiki_open_markupContext()
}

type Nowiki_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_open_markupContext() *Nowiki_open_markupContext {
	var p = new(Nowiki_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_open_markup
	return p
}

func (*Nowiki_open_markupContext) IsNowiki_open_markupContext() {}

func NewNowiki_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_open_markupContext {
	var p = new(Nowiki_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_open_markup

	return p
}

func (s *Nowiki_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_open_markupContext) NOWIKI_OPEN() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, 0)
}

func (s *Nowiki_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_open_markup(s)
	}
}

func (s *Nowiki_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_open_markup(s)
	}
}

func (p *Creole10Parser) Nowiki_open_markup() (localctx INowiki_open_markupContext) {
	localctx = NewNowiki_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Creole10ParserRULE_nowiki_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(932)
		p.Match(Creole10ParserNOWIKI_OPEN)
	}

	return localctx
}

// INowiki_close_markupContext is an interface to support dynamic dispatch.
type INowiki_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_close_markupContext differentiates from other interfaces.
	IsNowiki_close_markupContext()
}

type Nowiki_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_close_markupContext() *Nowiki_close_markupContext {
	var p = new(Nowiki_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_close_markup
	return p
}

func (*Nowiki_close_markupContext) IsNowiki_close_markupContext() {}

func NewNowiki_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_close_markupContext {
	var p = new(Nowiki_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_close_markup

	return p
}

func (s *Nowiki_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_close_markupContext) NOWIKI_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_CLOSE, 0)
}

func (s *Nowiki_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_close_markup(s)
	}
}

func (s *Nowiki_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_close_markup(s)
	}
}

func (p *Creole10Parser) Nowiki_close_markup() (localctx INowiki_close_markupContext) {
	localctx = NewNowiki_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Creole10ParserRULE_nowiki_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.Match(Creole10ParserNOWIKI_CLOSE)
	}

	return localctx
}

// IHorizontalrule_markupContext is an interface to support dynamic dispatch.
type IHorizontalrule_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHorizontalrule_markupContext differentiates from other interfaces.
	IsHorizontalrule_markupContext()
}

type Horizontalrule_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHorizontalrule_markupContext() *Horizontalrule_markupContext {
	var p = new(Horizontalrule_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_horizontalrule_markup
	return p
}

func (*Horizontalrule_markupContext) IsHorizontalrule_markupContext() {}

func NewHorizontalrule_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Horizontalrule_markupContext {
	var p = new(Horizontalrule_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_horizontalrule_markup

	return p
}

func (s *Horizontalrule_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Horizontalrule_markupContext) AllDASH() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserDASH)
}

func (s *Horizontalrule_markupContext) DASH(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserDASH, i)
}

func (s *Horizontalrule_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Horizontalrule_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Horizontalrule_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHorizontalrule_markup(s)
	}
}

func (s *Horizontalrule_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHorizontalrule_markup(s)
	}
}

func (p *Creole10Parser) Horizontalrule_markup() (localctx IHorizontalrule_markupContext) {
	localctx = NewHorizontalrule_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Creole10ParserRULE_horizontalrule_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(936)
		p.Match(Creole10ParserDASH)
	}
	{
		p.SetState(937)
		p.Match(Creole10ParserDASH)
	}
	{
		p.SetState(938)
		p.Match(Creole10ParserDASH)
	}
	{
		p.SetState(939)
		p.Match(Creole10ParserDASH)
	}

	return localctx
}

// ILink_open_markupContext is an interface to support dynamic dispatch.
type ILink_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_open_markupContext differentiates from other interfaces.
	IsLink_open_markupContext()
}

type Link_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_open_markupContext() *Link_open_markupContext {
	var p = new(Link_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_open_markup
	return p
}

func (*Link_open_markupContext) IsLink_open_markupContext() {}

func NewLink_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_open_markupContext {
	var p = new(Link_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_open_markup

	return p
}

func (s *Link_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_open_markupContext) LINK_OPEN() antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, 0)
}

func (s *Link_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_open_markup(s)
	}
}

func (s *Link_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_open_markup(s)
	}
}

func (p *Creole10Parser) Link_open_markup() (localctx ILink_open_markupContext) {
	localctx = NewLink_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Creole10ParserRULE_link_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(941)
		p.Match(Creole10ParserLINK_OPEN)
	}

	return localctx
}

// ILink_close_markupContext is an interface to support dynamic dispatch.
type ILink_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_close_markupContext differentiates from other interfaces.
	IsLink_close_markupContext()
}

type Link_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_close_markupContext() *Link_close_markupContext {
	var p = new(Link_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_close_markup
	return p
}

func (*Link_close_markupContext) IsLink_close_markupContext() {}

func NewLink_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_close_markupContext {
	var p = new(Link_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_close_markup

	return p
}

func (s *Link_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_close_markupContext) LINK_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, 0)
}

func (s *Link_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_close_markup(s)
	}
}

func (s *Link_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_close_markup(s)
	}
}

func (p *Creole10Parser) Link_close_markup() (localctx ILink_close_markupContext) {
	localctx = NewLink_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Creole10ParserRULE_link_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(943)
		p.Match(Creole10ParserLINK_CLOSE)
	}

	return localctx
}

// ILink_description_markupContext is an interface to support dynamic dispatch.
type ILink_description_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_description_markupContext differentiates from other interfaces.
	IsLink_description_markupContext()
}

type Link_description_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_description_markupContext() *Link_description_markupContext {
	var p = new(Link_description_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_description_markup
	return p
}

func (*Link_description_markupContext) IsLink_description_markupContext() {}

func NewLink_description_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_description_markupContext {
	var p = new(Link_description_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_description_markup

	return p
}

func (s *Link_description_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_description_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Link_description_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_description_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_description_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_description_markup(s)
	}
}

func (s *Link_description_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_description_markup(s)
	}
}

func (p *Creole10Parser) Link_description_markup() (localctx ILink_description_markupContext) {
	localctx = NewLink_description_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Creole10ParserRULE_link_description_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(945)
		p.Match(Creole10ParserPIPE)
	}

	return localctx
}

// IImage_open_markupContext is an interface to support dynamic dispatch.
type IImage_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_open_markupContext differentiates from other interfaces.
	IsImage_open_markupContext()
}

type Image_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_open_markupContext() *Image_open_markupContext {
	var p = new(Image_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_open_markup
	return p
}

func (*Image_open_markupContext) IsImage_open_markupContext() {}

func NewImage_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_open_markupContext {
	var p = new(Image_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_open_markup

	return p
}

func (s *Image_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_open_markupContext) IMAGE_OPEN() antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, 0)
}

func (s *Image_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_open_markup(s)
	}
}

func (s *Image_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_open_markup(s)
	}
}

func (p *Creole10Parser) Image_open_markup() (localctx IImage_open_markupContext) {
	localctx = NewImage_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Creole10ParserRULE_image_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(947)
		p.Match(Creole10ParserIMAGE_OPEN)
	}

	return localctx
}

// IImage_close_markupContext is an interface to support dynamic dispatch.
type IImage_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_close_markupContext differentiates from other interfaces.
	IsImage_close_markupContext()
}

type Image_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_close_markupContext() *Image_close_markupContext {
	var p = new(Image_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_close_markup
	return p
}

func (*Image_close_markupContext) IsImage_close_markupContext() {}

func NewImage_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_close_markupContext {
	var p = new(Image_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_close_markup

	return p
}

func (s *Image_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_close_markupContext) IMAGE_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_CLOSE, 0)
}

func (s *Image_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_close_markup(s)
	}
}

func (s *Image_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_close_markup(s)
	}
}

func (p *Creole10Parser) Image_close_markup() (localctx IImage_close_markupContext) {
	localctx = NewImage_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Creole10ParserRULE_image_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.Match(Creole10ParserIMAGE_CLOSE)
	}

	return localctx
}

// IImage_alternative_markupContext is an interface to support dynamic dispatch.
type IImage_alternative_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternative_markupContext differentiates from other interfaces.
	IsImage_alternative_markupContext()
}

type Image_alternative_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternative_markupContext() *Image_alternative_markupContext {
	var p = new(Image_alternative_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternative_markup
	return p
}

func (*Image_alternative_markupContext) IsImage_alternative_markupContext() {}

func NewImage_alternative_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternative_markupContext {
	var p = new(Image_alternative_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternative_markup

	return p
}

func (s *Image_alternative_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternative_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Image_alternative_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternative_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternative_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternative_markup(s)
	}
}

func (s *Image_alternative_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternative_markup(s)
	}
}

func (p *Creole10Parser) Image_alternative_markup() (localctx IImage_alternative_markupContext) {
	localctx = NewImage_alternative_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Creole10ParserRULE_image_alternative_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(951)
		p.Match(Creole10ParserPIPE)
	}

	return localctx
}

// IExtension_markupContext is an interface to support dynamic dispatch.
type IExtension_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_markupContext differentiates from other interfaces.
	IsExtension_markupContext()
}

type Extension_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_markupContext() *Extension_markupContext {
	var p = new(Extension_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension_markup
	return p
}

func (*Extension_markupContext) IsExtension_markupContext() {}

func NewExtension_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_markupContext {
	var p = new(Extension_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension_markup

	return p
}

func (s *Extension_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_markupContext) EXTENSION() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, 0)
}

func (s *Extension_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension_markup(s)
	}
}

func (s *Extension_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension_markup(s)
	}
}

func (p *Creole10Parser) Extension_markup() (localctx IExtension_markupContext) {
	localctx = NewExtension_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Creole10ParserRULE_extension_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(953)
		p.Match(Creole10ParserEXTENSION)
	}

	return localctx
}

// IForced_linebreakContext is an interface to support dynamic dispatch.
type IForced_linebreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForced_linebreakContext differentiates from other interfaces.
	IsForced_linebreakContext()
}

type Forced_linebreakContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForced_linebreakContext() *Forced_linebreakContext {
	var p = new(Forced_linebreakContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_forced_linebreak
	return p
}

func (*Forced_linebreakContext) IsForced_linebreakContext() {}

func NewForced_linebreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forced_linebreakContext {
	var p = new(Forced_linebreakContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_forced_linebreak

	return p
}

func (s *Forced_linebreakContext) GetParser() antlr.Parser { return s.parser }

func (s *Forced_linebreakContext) FORCED_LINEBREAK() antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, 0)
}

func (s *Forced_linebreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forced_linebreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forced_linebreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterForced_linebreak(s)
	}
}

func (s *Forced_linebreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitForced_linebreak(s)
	}
}

func (p *Creole10Parser) Forced_linebreak() (localctx IForced_linebreakContext) {
	localctx = NewForced_linebreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Creole10ParserRULE_forced_linebreak)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(Creole10ParserFORCED_LINEBREAK)
	}

	return localctx
}

func (p *Creole10Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 3:
		var t *ParagraphContext = nil
		if localctx != nil {
			t = localctx.(*ParagraphContext)
		}
		return p.Paragraph_Sempred(t, predIndex)

	case 6:
		var t *Text_firstelementContext = nil
		if localctx != nil {
			t = localctx.(*Text_firstelementContext)
		}
		return p.Text_firstelement_Sempred(t, predIndex)

	case 16:
		var t *Text_lineseparator1Context = nil
		if localctx != nil {
			t = localctx.(*Text_lineseparator1Context)
		}
		return p.Text_lineseparator1_Sempred(t, predIndex)

	case 34:
		var t *OnestarContext = nil
		if localctx != nil {
			t = localctx.(*OnestarContext)
		}
		return p.Onestar_Sempred(t, predIndex)

	case 40:
		var t *Table_cellContext = nil
		if localctx != nil {
			t = localctx.(*Table_cellContext)
		}
		return p.Table_cell_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Creole10Parser) Paragraph_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.GetInputStream().LA(1) == Creole10ParserDASH && p.GetInputStream().LA(2) == Creole10ParserDASH && p.GetInputStream().LA(3) == Creole10ParserDASH && p.GetInputStream().LA(4) == Creole10ParserDASH

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Text_firstelement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.GetInputStream().LA(1) != Creole10ParserSTAR || (p.GetInputStream().LA(1) == Creole10ParserSTAR && p.GetInputStream().LA(2) == Creole10ParserSTAR)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Text_lineseparator1_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.GetInputStream().LA(2) != Creole10ParserDASH && p.GetInputStream().LA(2) != Creole10ParserPOUND && p.GetInputStream().LA(2) != Creole10ParserEQUAL && p.GetInputStream().LA(2) != Creole10ParserNEWLINE

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Onestar_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.GetInputStream().LA(2) != Creole10ParserSTAR

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Table_cell_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.GetInputStream().LA(2) == Creole10ParserEQUAL

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
