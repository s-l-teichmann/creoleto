// Generated from Creole10.g4 by ANTLR 4.7.

package parser // Creole10

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 26, 963,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 3, 2, 3, 2, 3, 3, 5, 3, 226, 10, 3, 3, 3, 3, 3, 3, 3, 3, 4, 7,
	4, 232, 10, 4, 12, 4, 14, 4, 235, 11, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5,
	5, 5, 242, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 251,
	10, 5, 3, 5, 5, 5, 254, 10, 5, 5, 5, 256, 10, 5, 3, 6, 3, 6, 3, 6, 7, 6,
	261, 10, 6, 12, 6, 14, 6, 264, 11, 6, 3, 6, 3, 6, 6, 6, 268, 10, 6, 13,
	6, 14, 6, 269, 3, 7, 3, 7, 7, 7, 274, 10, 7, 12, 7, 14, 7, 277, 11, 7,
	3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 5, 8, 284, 10, 8, 3, 9, 3, 9, 3, 9, 5, 9,
	289, 10, 9, 3, 9, 5, 9, 292, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 297, 10, 9,
	3, 9, 5, 9, 300, 10, 9, 5, 9, 302, 10, 9, 3, 10, 5, 10, 305, 10, 10, 3,
	10, 7, 10, 308, 10, 10, 12, 10, 14, 10, 311, 11, 10, 3, 10, 5, 10, 314,
	10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 323, 10,
	11, 3, 12, 3, 12, 3, 13, 5, 13, 328, 10, 13, 3, 13, 7, 13, 331, 10, 13,
	12, 13, 14, 13, 334, 11, 13, 3, 13, 5, 13, 337, 10, 13, 3, 14, 3, 14, 3,
	14, 5, 14, 342, 10, 14, 3, 14, 5, 14, 345, 10, 14, 3, 15, 3, 15, 3, 15,
	5, 15, 350, 10, 15, 3, 15, 5, 15, 353, 10, 15, 3, 16, 5, 16, 356, 10, 16,
	3, 16, 5, 16, 359, 10, 16, 3, 16, 5, 16, 362, 10, 16, 3, 17, 3, 17, 3,
	17, 5, 17, 367, 10, 17, 6, 17, 369, 10, 17, 13, 17, 14, 17, 370, 3, 18,
	3, 18, 3, 18, 3, 19, 3, 19, 5, 19, 378, 10, 19, 3, 20, 3, 20, 3, 20, 5,
	20, 383, 10, 20, 3, 21, 3, 21, 5, 21, 387, 10, 21, 3, 22, 3, 22, 3, 22,
	6, 22, 392, 10, 22, 13, 22, 14, 22, 393, 3, 23, 3, 23, 5, 23, 398, 10,
	23, 3, 24, 3, 24, 3, 24, 6, 24, 403, 10, 24, 13, 24, 14, 24, 404, 3, 25,
	3, 25, 3, 25, 5, 25, 410, 10, 25, 3, 25, 5, 25, 413, 10, 25, 3, 25, 3,
	25, 3, 26, 3, 26, 3, 26, 5, 26, 420, 10, 26, 3, 26, 3, 26, 6, 26, 424,
	10, 26, 13, 26, 14, 26, 425, 5, 26, 428, 10, 26, 3, 27, 6, 27, 431, 10,
	27, 13, 27, 14, 27, 432, 3, 27, 5, 27, 436, 10, 27, 3, 28, 3, 28, 3, 28,
	3, 29, 6, 29, 442, 10, 29, 13, 29, 14, 29, 443, 3, 29, 5, 29, 447, 10,
	29, 3, 30, 3, 30, 3, 30, 3, 31, 7, 31, 453, 10, 31, 12, 31, 14, 31, 456,
	11, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 5, 32, 463, 10, 32, 3, 33, 7,
	33, 466, 10, 33, 12, 33, 14, 33, 469, 11, 33, 3, 34, 3, 34, 3, 34, 3, 34,
	5, 34, 475, 10, 34, 3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 481, 10, 35, 12,
	35, 14, 35, 484, 11, 35, 3, 35, 5, 35, 487, 10, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 7, 35, 493, 10, 35, 12, 35, 14, 35, 496, 11, 35, 3, 35, 5, 35, 499,
	10, 35, 5, 35, 501, 10, 35, 3, 36, 3, 36, 5, 36, 505, 10, 36, 3, 36, 5,
	36, 508, 10, 36, 3, 37, 3, 37, 3, 37, 5, 37, 513, 10, 37, 3, 37, 6, 37,
	516, 10, 37, 13, 37, 14, 37, 517, 5, 37, 520, 10, 37, 3, 38, 3, 38, 3,
	38, 5, 38, 525, 10, 38, 3, 38, 6, 38, 528, 10, 38, 13, 38, 14, 38, 529,
	5, 38, 532, 10, 38, 3, 39, 6, 39, 535, 10, 39, 13, 39, 14, 39, 536, 3,
	40, 6, 40, 540, 10, 40, 13, 40, 14, 40, 541, 3, 41, 6, 41, 545, 10, 41,
	13, 41, 14, 41, 546, 3, 41, 5, 41, 550, 10, 41, 3, 41, 3, 41, 3, 42, 3,
	42, 3, 42, 5, 42, 557, 10, 42, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44,
	3, 45, 6, 45, 566, 10, 45, 13, 45, 14, 45, 567, 3, 45, 5, 45, 571, 10,
	45, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 577, 10, 46, 3, 47, 3, 47, 5, 47,
	581, 10, 47, 3, 47, 5, 47, 584, 10, 47, 3, 47, 3, 47, 5, 47, 588, 10, 47,
	3, 47, 5, 47, 591, 10, 47, 5, 47, 593, 10, 47, 3, 48, 3, 48, 3, 48, 6,
	48, 598, 10, 48, 13, 48, 14, 48, 599, 3, 48, 5, 48, 603, 10, 48, 3, 49,
	6, 49, 606, 10, 49, 13, 49, 14, 49, 607, 3, 49, 5, 49, 611, 10, 49, 3,
	50, 3, 50, 3, 50, 3, 50, 5, 50, 617, 10, 50, 5, 50, 619, 10, 50, 3, 51,
	3, 51, 3, 51, 5, 51, 624, 10, 51, 3, 51, 5, 51, 627, 10, 51, 3, 52, 5,
	52, 630, 10, 52, 3, 52, 5, 52, 633, 10, 52, 3, 53, 6, 53, 636, 10, 53,
	13, 53, 14, 53, 637, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 644, 10, 54, 3,
	55, 3, 55, 5, 55, 648, 10, 55, 3, 56, 3, 56, 3, 56, 6, 56, 653, 10, 56,
	13, 56, 14, 56, 654, 3, 57, 3, 57, 7, 57, 659, 10, 57, 12, 57, 14, 57,
	662, 11, 57, 3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 61, 7, 61, 677, 10, 61, 12, 61, 14, 61, 680,
	11, 61, 3, 62, 3, 62, 5, 62, 684, 10, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3,
	63, 3, 63, 3, 63, 5, 63, 693, 10, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64,
	3, 64, 3, 64, 5, 64, 702, 10, 64, 3, 65, 3, 65, 3, 65, 3, 66, 6, 66, 708,
	10, 66, 13, 66, 14, 66, 709, 3, 67, 3, 67, 3, 67, 3, 67, 6, 67, 716, 10,
	67, 13, 67, 14, 67, 717, 3, 68, 3, 68, 3, 68, 3, 68, 6, 68, 724, 10, 68,
	13, 68, 14, 68, 725, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 6, 68, 734,
	10, 68, 13, 68, 14, 68, 735, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 6, 68,
	743, 10, 68, 13, 68, 14, 68, 744, 3, 68, 3, 68, 5, 68, 749, 10, 68, 3,
	69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 756, 10, 69, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 5, 70, 763, 10, 70, 3, 71, 3, 71, 3, 71, 6, 71, 768, 10,
	71, 13, 71, 14, 71, 769, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 6, 72, 777,
	10, 72, 13, 72, 14, 72, 778, 3, 73, 6, 73, 782, 10, 73, 13, 73, 14, 73,
	783, 3, 74, 3, 74, 3, 74, 5, 74, 789, 10, 74, 3, 74, 3, 74, 3, 75, 6, 75,
	794, 10, 75, 13, 75, 14, 75, 795, 3, 76, 3, 76, 6, 76, 800, 10, 76, 13,
	76, 14, 76, 801, 3, 77, 3, 77, 3, 77, 3, 77, 6, 77, 808, 10, 77, 13, 77,
	14, 77, 809, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77, 6, 77, 818, 10,
	77, 13, 77, 14, 77, 819, 3, 77, 3, 77, 3, 77, 5, 77, 825, 10, 77, 3, 78,
	3, 78, 3, 78, 3, 78, 3, 78, 5, 78, 832, 10, 78, 3, 79, 3, 79, 3, 79, 3,
	79, 3, 79, 5, 79, 839, 10, 79, 3, 80, 3, 80, 3, 80, 6, 80, 844, 10, 80,
	13, 80, 14, 80, 845, 3, 80, 3, 80, 3, 81, 3, 81, 6, 81, 852, 10, 81, 13,
	81, 14, 81, 853, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83,
	6, 83, 864, 10, 83, 13, 83, 14, 83, 865, 3, 84, 3, 84, 7, 84, 870, 10,
	84, 12, 84, 14, 84, 873, 11, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5,
	85, 880, 10, 85, 3, 86, 6, 86, 883, 10, 86, 13, 86, 14, 86, 884, 3, 86,
	5, 86, 888, 10, 86, 3, 87, 3, 87, 6, 87, 892, 10, 87, 13, 87, 14, 87, 893,
	3, 88, 3, 88, 3, 89, 3, 89, 5, 89, 900, 10, 89, 3, 89, 5, 89, 903, 10,
	89, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3, 93, 3, 93, 3, 94,
	3, 94, 3, 95, 3, 95, 3, 96, 3, 96, 5, 96, 920, 10, 96, 3, 96, 5, 96, 923,
	10, 96, 3, 97, 3, 97, 5, 97, 927, 10, 97, 3, 98, 3, 98, 3, 99, 3, 99, 3,
	99, 3, 100, 3, 100, 5, 100, 936, 10, 100, 3, 101, 3, 101, 3, 102, 3, 102,
	3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 3, 104, 3, 104, 3, 105, 3, 105,
	3, 106, 3, 106, 3, 107, 3, 107, 3, 108, 3, 108, 3, 109, 3, 109, 3, 110,
	3, 110, 3, 111, 3, 111, 3, 111, 2, 2, 112, 2, 4, 6, 8, 10, 12, 14, 16,
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
	90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
	212, 214, 216, 218, 220, 2, 14, 10, 3, 6, 6, 8, 8, 11, 12, 14, 14, 16,
	16, 18, 21, 23, 23, 25, 25, 10, 3, 6, 6, 8, 8, 11, 12, 14, 14, 16, 16,
	18, 18, 23, 23, 25, 25, 5, 3, 6, 6, 8, 8, 19, 19, 11, 3, 6, 6, 8, 8, 11,
	12, 14, 14, 16, 16, 18, 18, 20, 20, 23, 23, 25, 25, 3, 3, 7, 7, 4, 3, 8,
	8, 13, 13, 5, 3, 8, 8, 15, 15, 20, 20, 9, 3, 6, 6, 8, 8, 11, 12, 14, 16,
	18, 18, 23, 23, 25, 25, 5, 3, 8, 8, 17, 17, 20, 20, 8, 3, 8, 8, 11, 12,
	14, 14, 16, 18, 23, 23, 25, 25, 5, 3, 6, 6, 8, 9, 25, 25, 4, 3, 6, 6, 25,
	25, 2, 1006, 2, 222, 3, 2, 2, 2, 4, 225, 3, 2, 2, 2, 6, 233, 3, 2, 2, 2,
	8, 255, 3, 2, 2, 2, 10, 267, 3, 2, 2, 2, 12, 271, 3, 2, 2, 2, 14, 283,
	3, 2, 2, 2, 16, 301, 3, 2, 2, 2, 18, 313, 3, 2, 2, 2, 20, 322, 3, 2, 2,
	2, 22, 324, 3, 2, 2, 2, 24, 336, 3, 2, 2, 2, 26, 344, 3, 2, 2, 2, 28, 352,
	3, 2, 2, 2, 30, 361, 3, 2, 2, 2, 32, 368, 3, 2, 2, 2, 34, 372, 3, 2, 2,
	2, 36, 377, 3, 2, 2, 2, 38, 382, 3, 2, 2, 2, 40, 386, 3, 2, 2, 2, 42, 391,
	3, 2, 2, 2, 44, 397, 3, 2, 2, 2, 46, 402, 3, 2, 2, 2, 48, 406, 3, 2, 2,
	2, 50, 427, 3, 2, 2, 2, 52, 430, 3, 2, 2, 2, 54, 437, 3, 2, 2, 2, 56, 441,
	3, 2, 2, 2, 58, 448, 3, 2, 2, 2, 60, 454, 3, 2, 2, 2, 62, 462, 3, 2, 2,
	2, 64, 467, 3, 2, 2, 2, 66, 474, 3, 2, 2, 2, 68, 500, 3, 2, 2, 2, 70, 507,
	3, 2, 2, 2, 72, 519, 3, 2, 2, 2, 74, 531, 3, 2, 2, 2, 76, 534, 3, 2, 2,
	2, 78, 539, 3, 2, 2, 2, 80, 544, 3, 2, 2, 2, 82, 556, 3, 2, 2, 2, 84, 558,
	3, 2, 2, 2, 86, 561, 3, 2, 2, 2, 88, 565, 3, 2, 2, 2, 90, 576, 3, 2, 2,
	2, 92, 592, 3, 2, 2, 2, 94, 602, 3, 2, 2, 2, 96, 610, 3, 2, 2, 2, 98, 618,
	3, 2, 2, 2, 100, 626, 3, 2, 2, 2, 102, 632, 3, 2, 2, 2, 104, 635, 3, 2,
	2, 2, 106, 643, 3, 2, 2, 2, 108, 647, 3, 2, 2, 2, 110, 652, 3, 2, 2, 2,
	112, 656, 3, 2, 2, 2, 114, 666, 3, 2, 2, 2, 116, 669, 3, 2, 2, 2, 118,
	671, 3, 2, 2, 2, 120, 678, 3, 2, 2, 2, 122, 681, 3, 2, 2, 2, 124, 687,
	3, 2, 2, 2, 126, 701, 3, 2, 2, 2, 128, 703, 3, 2, 2, 2, 130, 707, 3, 2,
	2, 2, 132, 715, 3, 2, 2, 2, 134, 748, 3, 2, 2, 2, 136, 755, 3, 2, 2, 2,
	138, 762, 3, 2, 2, 2, 140, 767, 3, 2, 2, 2, 142, 776, 3, 2, 2, 2, 144,
	781, 3, 2, 2, 2, 146, 785, 3, 2, 2, 2, 148, 793, 3, 2, 2, 2, 150, 797,
	3, 2, 2, 2, 152, 824, 3, 2, 2, 2, 154, 831, 3, 2, 2, 2, 156, 838, 3, 2,
	2, 2, 158, 843, 3, 2, 2, 2, 160, 851, 3, 2, 2, 2, 162, 855, 3, 2, 2, 2,
	164, 863, 3, 2, 2, 2, 166, 871, 3, 2, 2, 2, 168, 879, 3, 2, 2, 2, 170,
	887, 3, 2, 2, 2, 172, 891, 3, 2, 2, 2, 174, 895, 3, 2, 2, 2, 176, 902,
	3, 2, 2, 2, 178, 904, 3, 2, 2, 2, 180, 906, 3, 2, 2, 2, 182, 909, 3, 2,
	2, 2, 184, 911, 3, 2, 2, 2, 186, 913, 3, 2, 2, 2, 188, 915, 3, 2, 2, 2,
	190, 922, 3, 2, 2, 2, 192, 926, 3, 2, 2, 2, 194, 928, 3, 2, 2, 2, 196,
	930, 3, 2, 2, 2, 198, 935, 3, 2, 2, 2, 200, 937, 3, 2, 2, 2, 202, 939,
	3, 2, 2, 2, 204, 941, 3, 2, 2, 2, 206, 946, 3, 2, 2, 2, 208, 948, 3, 2,
	2, 2, 210, 950, 3, 2, 2, 2, 212, 952, 3, 2, 2, 2, 214, 954, 3, 2, 2, 2,
	216, 956, 3, 2, 2, 2, 218, 958, 3, 2, 2, 2, 220, 960, 3, 2, 2, 2, 222,
	223, 5, 4, 3, 2, 223, 3, 3, 2, 2, 2, 224, 226, 5, 172, 87, 2, 225, 224,
	3, 2, 2, 2, 225, 226, 3, 2, 2, 2, 226, 227, 3, 2, 2, 2, 227, 228, 5, 6,
	4, 2, 228, 229, 7, 2, 2, 3, 229, 5, 3, 2, 2, 2, 230, 232, 5, 8, 5, 2, 231,
	230, 3, 2, 2, 2, 232, 235, 3, 2, 2, 2, 233, 231, 3, 2, 2, 2, 233, 234,
	3, 2, 2, 2, 234, 7, 3, 2, 2, 2, 235, 233, 3, 2, 2, 2, 236, 256, 5, 112,
	57, 2, 237, 238, 5, 174, 88, 2, 238, 239, 5, 170, 86, 2, 239, 256, 3, 2,
	2, 2, 240, 242, 5, 174, 88, 2, 241, 240, 3, 2, 2, 2, 241, 242, 3, 2, 2,
	2, 242, 250, 3, 2, 2, 2, 243, 251, 5, 48, 25, 2, 244, 245, 6, 5, 2, 2,
	245, 251, 5, 122, 62, 2, 246, 251, 5, 56, 29, 2, 247, 251, 5, 52, 27, 2,
	248, 251, 5, 78, 40, 2, 249, 251, 5, 10, 6, 2, 250, 243, 3, 2, 2, 2, 250,
	244, 3, 2, 2, 2, 250, 246, 3, 2, 2, 2, 250, 247, 3, 2, 2, 2, 250, 248,
	3, 2, 2, 2, 250, 249, 3, 2, 2, 2, 251, 253, 3, 2, 2, 2, 252, 254, 5, 170,
	86, 2, 253, 252, 3, 2, 2, 2, 253, 254, 3, 2, 2, 2, 254, 256, 3, 2, 2, 2,
	255, 236, 3, 2, 2, 2, 255, 237, 3, 2, 2, 2, 255, 241, 3, 2, 2, 2, 256,
	9, 3, 2, 2, 2, 257, 268, 5, 12, 7, 2, 258, 262, 5, 118, 60, 2, 259, 261,
	5, 20, 11, 2, 260, 259, 3, 2, 2, 2, 261, 264, 3, 2, 2, 2, 262, 260, 3,
	2, 2, 2, 262, 263, 3, 2, 2, 2, 263, 265, 3, 2, 2, 2, 264, 262, 3, 2, 2,
	2, 265, 266, 5, 176, 89, 2, 266, 268, 3, 2, 2, 2, 267, 257, 3, 2, 2, 2,
	267, 258, 3, 2, 2, 2, 268, 269, 3, 2, 2, 2, 269, 267, 3, 2, 2, 2, 269,
	270, 3, 2, 2, 2, 270, 11, 3, 2, 2, 2, 271, 275, 5, 14, 8, 2, 272, 274,
	5, 20, 11, 2, 273, 272, 3, 2, 2, 2, 274, 277, 3, 2, 2, 2, 275, 273, 3,
	2, 2, 2, 275, 276, 3, 2, 2, 2, 276, 278, 3, 2, 2, 2, 277, 275, 3, 2, 2,
	2, 278, 279, 5, 176, 89, 2, 279, 13, 3, 2, 2, 2, 280, 281, 6, 8, 3, 2,
	281, 284, 5, 16, 9, 2, 282, 284, 5, 40, 21, 2, 283, 280, 3, 2, 2, 2, 283,
	282, 3, 2, 2, 2, 284, 15, 3, 2, 2, 2, 285, 286, 5, 182, 92, 2, 286, 291,
	5, 24, 13, 2, 287, 289, 7, 8, 2, 2, 288, 287, 3, 2, 2, 2, 288, 289, 3,
	2, 2, 2, 289, 290, 3, 2, 2, 2, 290, 292, 5, 182, 92, 2, 291, 288, 3, 2,
	2, 2, 291, 292, 3, 2, 2, 2, 292, 302, 3, 2, 2, 2, 293, 294, 5, 180, 91,
	2, 294, 299, 5, 18, 10, 2, 295, 297, 7, 8, 2, 2, 296, 295, 3, 2, 2, 2,
	296, 297, 3, 2, 2, 2, 297, 298, 3, 2, 2, 2, 298, 300, 5, 180, 91, 2, 299,
	296, 3, 2, 2, 2, 299, 300, 3, 2, 2, 2, 300, 302, 3, 2, 2, 2, 301, 285,
	3, 2, 2, 2, 301, 293, 3, 2, 2, 2, 302, 17, 3, 2, 2, 2, 303, 305, 5, 22,
	12, 2, 304, 303, 3, 2, 2, 2, 304, 305, 3, 2, 2, 2, 305, 309, 3, 2, 2, 2,
	306, 308, 5, 26, 14, 2, 307, 306, 3, 2, 2, 2, 308, 311, 3, 2, 2, 2, 309,
	307, 3, 2, 2, 2, 309, 310, 3, 2, 2, 2, 310, 314, 3, 2, 2, 2, 311, 309,
	3, 2, 2, 2, 312, 314, 7, 2, 2, 3, 313, 304, 3, 2, 2, 2, 313, 312, 3, 2,
	2, 2, 314, 19, 3, 2, 2, 2, 315, 316, 5, 70, 36, 2, 316, 317, 5, 44, 23,
	2, 317, 323, 3, 2, 2, 2, 318, 319, 5, 44, 23, 2, 319, 320, 5, 70, 36, 2,
	320, 323, 3, 2, 2, 2, 321, 323, 5, 16, 9, 2, 322, 315, 3, 2, 2, 2, 322,
	318, 3, 2, 2, 2, 322, 321, 3, 2, 2, 2, 323, 21, 3, 2, 2, 2, 324, 325, 7,
	8, 2, 2, 325, 23, 3, 2, 2, 2, 326, 328, 5, 22, 12, 2, 327, 326, 3, 2, 2,
	2, 327, 328, 3, 2, 2, 2, 328, 332, 3, 2, 2, 2, 329, 331, 5, 28, 15, 2,
	330, 329, 3, 2, 2, 2, 331, 334, 3, 2, 2, 2, 332, 330, 3, 2, 2, 2, 332,
	333, 3, 2, 2, 2, 333, 337, 3, 2, 2, 2, 334, 332, 3, 2, 2, 2, 335, 337,
	7, 2, 2, 3, 336, 327, 3, 2, 2, 2, 336, 335, 3, 2, 2, 2, 337, 25, 3, 2,
	2, 2, 338, 339, 5, 182, 92, 2, 339, 341, 5, 30, 16, 2, 340, 342, 5, 182,
	92, 2, 341, 340, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342, 345, 3, 2, 2, 2,
	343, 345, 5, 32, 17, 2, 344, 338, 3, 2, 2, 2, 344, 343, 3, 2, 2, 2, 345,
	27, 3, 2, 2, 2, 346, 347, 5, 180, 91, 2, 347, 349, 5, 30, 16, 2, 348, 350,
	5, 180, 91, 2, 349, 348, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 353, 3,
	2, 2, 2, 351, 353, 5, 32, 17, 2, 352, 346, 3, 2, 2, 2, 352, 351, 3, 2,
	2, 2, 353, 29, 3, 2, 2, 2, 354, 356, 5, 22, 12, 2, 355, 354, 3, 2, 2, 2,
	355, 356, 3, 2, 2, 2, 356, 358, 3, 2, 2, 2, 357, 359, 5, 32, 17, 2, 358,
	357, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359, 362, 3, 2, 2, 2, 360, 362,
	7, 2, 2, 3, 361, 355, 3, 2, 2, 2, 361, 360, 3, 2, 2, 2, 362, 31, 3, 2,
	2, 2, 363, 364, 5, 70, 36, 2, 364, 366, 5, 44, 23, 2, 365, 367, 5, 34,
	18, 2, 366, 365, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 369, 3, 2, 2, 2,
	368, 363, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2, 370, 368, 3, 2, 2, 2, 370,
	371, 3, 2, 2, 2, 371, 33, 3, 2, 2, 2, 372, 373, 6, 18, 4, 2, 373, 374,
	5, 176, 89, 2, 374, 35, 3, 2, 2, 2, 375, 378, 5, 38, 20, 2, 376, 378, 5,
	118, 60, 2, 377, 375, 3, 2, 2, 2, 377, 376, 3, 2, 2, 2, 378, 37, 3, 2,
	2, 2, 379, 383, 5, 124, 63, 2, 380, 383, 5, 146, 74, 2, 381, 383, 5, 162,
	82, 2, 382, 379, 3, 2, 2, 2, 382, 380, 3, 2, 2, 2, 382, 381, 3, 2, 2, 2,
	383, 39, 3, 2, 2, 2, 384, 387, 5, 42, 22, 2, 385, 387, 5, 38, 20, 2, 386,
	384, 3, 2, 2, 2, 386, 385, 3, 2, 2, 2, 387, 41, 3, 2, 2, 2, 388, 392, 10,
	2, 2, 2, 389, 392, 5, 220, 111, 2, 390, 392, 5, 168, 85, 2, 391, 388, 3,
	2, 2, 2, 391, 389, 3, 2, 2, 2, 391, 390, 3, 2, 2, 2, 392, 393, 3, 2, 2,
	2, 393, 391, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2, 394, 43, 3, 2, 2, 2, 395,
	398, 5, 46, 24, 2, 396, 398, 5, 36, 19, 2, 397, 395, 3, 2, 2, 2, 397, 396,
	3, 2, 2, 2, 398, 45, 3, 2, 2, 2, 399, 403, 10, 3, 2, 2, 400, 403, 5, 220,
	111, 2, 401, 403, 5, 168, 85, 2, 402, 399, 3, 2, 2, 2, 402, 400, 3, 2,
	2, 2, 402, 401, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2,
	404, 405, 3, 2, 2, 2, 405, 47, 3, 2, 2, 2, 406, 407, 5, 184, 93, 2, 407,
	409, 5, 50, 26, 2, 408, 410, 5, 184, 93, 2, 409, 408, 3, 2, 2, 2, 409,
	410, 3, 2, 2, 2, 410, 412, 3, 2, 2, 2, 411, 413, 5, 174, 88, 2, 412, 411,
	3, 2, 2, 2, 412, 413, 3, 2, 2, 2, 413, 414, 3, 2, 2, 2, 414, 415, 5, 170,
	86, 2, 415, 49, 3, 2, 2, 2, 416, 417, 5, 184, 93, 2, 417, 419, 5, 50, 26,
	2, 418, 420, 5, 184, 93, 2, 419, 418, 3, 2, 2, 2, 419, 420, 3, 2, 2, 2,
	420, 428, 3, 2, 2, 2, 421, 424, 10, 4, 2, 2, 422, 424, 5, 168, 85, 2, 423,
	421, 3, 2, 2, 2, 423, 422, 3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 423,
	3, 2, 2, 2, 425, 426, 3, 2, 2, 2, 426, 428, 3, 2, 2, 2, 427, 416, 3, 2,
	2, 2, 427, 423, 3, 2, 2, 2, 428, 51, 3, 2, 2, 2, 429, 431, 5, 54, 28, 2,
	430, 429, 3, 2, 2, 2, 431, 432, 3, 2, 2, 2, 432, 430, 3, 2, 2, 2, 432,
	433, 3, 2, 2, 2, 433, 435, 3, 2, 2, 2, 434, 436, 5, 192, 97, 2, 435, 434,
	3, 2, 2, 2, 435, 436, 3, 2, 2, 2, 436, 53, 3, 2, 2, 2, 437, 438, 5, 186,
	94, 2, 438, 439, 5, 60, 31, 2, 439, 55, 3, 2, 2, 2, 440, 442, 5, 58, 30,
	2, 441, 440, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 441, 3, 2, 2, 2, 443,
	444, 3, 2, 2, 2, 444, 446, 3, 2, 2, 2, 445, 447, 5, 192, 97, 2, 446, 445,
	3, 2, 2, 2, 446, 447, 3, 2, 2, 2, 447, 57, 3, 2, 2, 2, 448, 449, 5, 188,
	95, 2, 449, 450, 5, 60, 31, 2, 450, 59, 3, 2, 2, 2, 451, 453, 5, 62, 32,
	2, 452, 451, 3, 2, 2, 2, 453, 456, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 454,
	455, 3, 2, 2, 2, 455, 457, 3, 2, 2, 2, 456, 454, 3, 2, 2, 2, 457, 458,
	5, 64, 33, 2, 458, 459, 5, 190, 96, 2, 459, 61, 3, 2, 2, 2, 460, 463, 5,
	186, 94, 2, 461, 463, 5, 188, 95, 2, 462, 460, 3, 2, 2, 2, 462, 461, 3,
	2, 2, 2, 463, 63, 3, 2, 2, 2, 464, 466, 5, 66, 34, 2, 465, 464, 3, 2, 2,
	2, 466, 469, 3, 2, 2, 2, 467, 465, 3, 2, 2, 2, 467, 468, 3, 2, 2, 2, 468,
	65, 3, 2, 2, 2, 469, 467, 3, 2, 2, 2, 470, 471, 5, 44, 23, 2, 471, 472,
	5, 70, 36, 2, 472, 475, 3, 2, 2, 2, 473, 475, 5, 68, 35, 2, 474, 470, 3,
	2, 2, 2, 474, 473, 3, 2, 2, 2, 475, 67, 3, 2, 2, 2, 476, 482, 5, 180, 91,
	2, 477, 478, 5, 70, 36, 2, 478, 479, 5, 72, 37, 2, 479, 481, 3, 2, 2, 2,
	480, 477, 3, 2, 2, 2, 481, 484, 3, 2, 2, 2, 482, 480, 3, 2, 2, 2, 482,
	483, 3, 2, 2, 2, 483, 486, 3, 2, 2, 2, 484, 482, 3, 2, 2, 2, 485, 487,
	5, 180, 91, 2, 486, 485, 3, 2, 2, 2, 486, 487, 3, 2, 2, 2, 487, 501, 3,
	2, 2, 2, 488, 494, 5, 182, 92, 2, 489, 490, 5, 70, 36, 2, 490, 491, 5,
	74, 38, 2, 491, 493, 3, 2, 2, 2, 492, 489, 3, 2, 2, 2, 493, 496, 3, 2,
	2, 2, 494, 492, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 498, 3, 2, 2, 2,
	496, 494, 3, 2, 2, 2, 497, 499, 5, 182, 92, 2, 498, 497, 3, 2, 2, 2, 498,
	499, 3, 2, 2, 2, 499, 501, 3, 2, 2, 2, 500, 476, 3, 2, 2, 2, 500, 488,
	3, 2, 2, 2, 501, 69, 3, 2, 2, 2, 502, 504, 6, 36, 5, 2, 503, 505, 7, 23,
	2, 2, 504, 503, 3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 508, 3, 2, 2, 2,
	506, 508, 3, 2, 2, 2, 507, 502, 3, 2, 2, 2, 507, 506, 3, 2, 2, 2, 508,
	71, 3, 2, 2, 2, 509, 510, 5, 182, 92, 2, 510, 512, 5, 76, 39, 2, 511, 513,
	5, 182, 92, 2, 512, 511, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 520, 3,
	2, 2, 2, 514, 516, 5, 44, 23, 2, 515, 514, 3, 2, 2, 2, 516, 517, 3, 2,
	2, 2, 517, 515, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 520, 3, 2, 2, 2,
	519, 509, 3, 2, 2, 2, 519, 515, 3, 2, 2, 2, 520, 73, 3, 2, 2, 2, 521, 522,
	5, 180, 91, 2, 522, 524, 5, 76, 39, 2, 523, 525, 5, 180, 91, 2, 524, 523,
	3, 2, 2, 2, 524, 525, 3, 2, 2, 2, 525, 532, 3, 2, 2, 2, 526, 528, 5, 44,
	23, 2, 527, 526, 3, 2, 2, 2, 528, 529, 3, 2, 2, 2, 529, 527, 3, 2, 2, 2,
	529, 530, 3, 2, 2, 2, 530, 532, 3, 2, 2, 2, 531, 521, 3, 2, 2, 2, 531,
	527, 3, 2, 2, 2, 532, 75, 3, 2, 2, 2, 533, 535, 5, 44, 23, 2, 534, 533,
	3, 2, 2, 2, 535, 536, 3, 2, 2, 2, 536, 534, 3, 2, 2, 2, 536, 537, 3, 2,
	2, 2, 537, 77, 3, 2, 2, 2, 538, 540, 5, 80, 41, 2, 539, 538, 3, 2, 2, 2,
	540, 541, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2, 541, 542, 3, 2, 2, 2, 542,
	79, 3, 2, 2, 2, 543, 545, 5, 82, 42, 2, 544, 543, 3, 2, 2, 2, 545, 546,
	3, 2, 2, 2, 546, 544, 3, 2, 2, 2, 546, 547, 3, 2, 2, 2, 547, 549, 3, 2,
	2, 2, 548, 550, 5, 194, 98, 2, 549, 548, 3, 2, 2, 2, 549, 550, 3, 2, 2,
	2, 550, 551, 3, 2, 2, 2, 551, 552, 5, 198, 100, 2, 552, 81, 3, 2, 2, 2,
	553, 554, 6, 42, 6, 2, 554, 557, 5, 84, 43, 2, 555, 557, 5, 86, 44, 2,
	556, 553, 3, 2, 2, 2, 556, 555, 3, 2, 2, 2, 557, 83, 3, 2, 2, 2, 558, 559,
	5, 196, 99, 2, 559, 560, 5, 88, 45, 2, 560, 85, 3, 2, 2, 2, 561, 562, 5,
	194, 98, 2, 562, 563, 5, 88, 45, 2, 563, 87, 3, 2, 2, 2, 564, 566, 5, 90,
	46, 2, 565, 564, 3, 2, 2, 2, 566, 567, 3, 2, 2, 2, 567, 565, 3, 2, 2, 2,
	567, 568, 3, 2, 2, 2, 568, 570, 3, 2, 2, 2, 569, 571, 7, 23, 2, 2, 570,
	569, 3, 2, 2, 2, 570, 571, 3, 2, 2, 2, 571, 89, 3, 2, 2, 2, 572, 577, 5,
	92, 47, 2, 573, 574, 5, 70, 36, 2, 574, 575, 5, 108, 55, 2, 575, 577, 3,
	2, 2, 2, 576, 572, 3, 2, 2, 2, 576, 573, 3, 2, 2, 2, 577, 91, 3, 2, 2,
	2, 578, 580, 5, 182, 92, 2, 579, 581, 5, 96, 49, 2, 580, 579, 3, 2, 2,
	2, 580, 581, 3, 2, 2, 2, 581, 583, 3, 2, 2, 2, 582, 584, 5, 182, 92, 2,
	583, 582, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 593, 3, 2, 2, 2, 585,
	587, 5, 180, 91, 2, 586, 588, 5, 94, 48, 2, 587, 586, 3, 2, 2, 2, 587,
	588, 3, 2, 2, 2, 588, 590, 3, 2, 2, 2, 589, 591, 5, 180, 91, 2, 590, 589,
	3, 2, 2, 2, 590, 591, 3, 2, 2, 2, 591, 593, 3, 2, 2, 2, 592, 578, 3, 2,
	2, 2, 592, 585, 3, 2, 2, 2, 593, 93, 3, 2, 2, 2, 594, 595, 5, 70, 36, 2,
	595, 596, 5, 98, 50, 2, 596, 598, 3, 2, 2, 2, 597, 594, 3, 2, 2, 2, 598,
	599, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 599, 600, 3, 2, 2, 2, 600, 603,
	3, 2, 2, 2, 601, 603, 7, 2, 2, 3, 602, 597, 3, 2, 2, 2, 602, 601, 3, 2,
	2, 2, 603, 95, 3, 2, 2, 2, 604, 606, 5, 100, 51, 2, 605, 604, 3, 2, 2,
	2, 606, 607, 3, 2, 2, 2, 607, 605, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608,
	611, 3, 2, 2, 2, 609, 611, 7, 2, 2, 3, 610, 605, 3, 2, 2, 2, 610, 609,
	3, 2, 2, 2, 611, 97, 3, 2, 2, 2, 612, 619, 5, 104, 53, 2, 613, 614, 5,
	182, 92, 2, 614, 616, 5, 102, 52, 2, 615, 617, 5, 182, 92, 2, 616, 615,
	3, 2, 2, 2, 616, 617, 3, 2, 2, 2, 617, 619, 3, 2, 2, 2, 618, 612, 3, 2,
	2, 2, 618, 613, 3, 2, 2, 2, 619, 99, 3, 2, 2, 2, 620, 621, 5, 180, 91,
	2, 621, 623, 5, 102, 52, 2, 622, 624, 5, 180, 91, 2, 623, 622, 3, 2, 2,
	2, 623, 624, 3, 2, 2, 2, 624, 627, 3, 2, 2, 2, 625, 627, 5, 104, 53, 2,
	626, 620, 3, 2, 2, 2, 626, 625, 3, 2, 2, 2, 627, 101, 3, 2, 2, 2, 628,
	630, 5, 104, 53, 2, 629, 628, 3, 2, 2, 2, 629, 630, 3, 2, 2, 2, 630, 633,
	3, 2, 2, 2, 631, 633, 7, 2, 2, 3, 632, 629, 3, 2, 2, 2, 632, 631, 3, 2,
	2, 2, 633, 103, 3, 2, 2, 2, 634, 636, 5, 108, 55, 2, 635, 634, 3, 2, 2,
	2, 636, 637, 3, 2, 2, 2, 637, 635, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638,
	105, 3, 2, 2, 2, 639, 644, 5, 124, 63, 2, 640, 644, 5, 146, 74, 2, 641,
	644, 5, 162, 82, 2, 642, 644, 5, 118, 60, 2, 643, 639, 3, 2, 2, 2, 643,
	640, 3, 2, 2, 2, 643, 641, 3, 2, 2, 2, 643, 642, 3, 2, 2, 2, 644, 107,
	3, 2, 2, 2, 645, 648, 5, 110, 56, 2, 646, 648, 5, 106, 54, 2, 647, 645,
	3, 2, 2, 2, 647, 646, 3, 2, 2, 2, 648, 109, 3, 2, 2, 2, 649, 653, 10, 5,
	2, 2, 650, 653, 5, 220, 111, 2, 651, 653, 5, 168, 85, 2, 652, 649, 3, 2,
	2, 2, 652, 650, 3, 2, 2, 2, 652, 651, 3, 2, 2, 2, 653, 654, 3, 2, 2, 2,
	654, 652, 3, 2, 2, 2, 654, 655, 3, 2, 2, 2, 655, 111, 3, 2, 2, 2, 656,
	660, 5, 114, 58, 2, 657, 659, 10, 6, 2, 2, 658, 657, 3, 2, 2, 2, 659, 662,
	3, 2, 2, 2, 660, 658, 3, 2, 2, 2, 660, 661, 3, 2, 2, 2, 661, 663, 3, 2,
	2, 2, 662, 660, 3, 2, 2, 2, 663, 664, 5, 116, 59, 2, 664, 665, 5, 170,
	86, 2, 665, 113, 3, 2, 2, 2, 666, 667, 5, 200, 101, 2, 667, 668, 5, 178,
	90, 2, 668, 115, 3, 2, 2, 2, 669, 670, 7, 7, 2, 2, 670, 117, 3, 2, 2, 2,
	671, 672, 5, 200, 101, 2, 672, 673, 5, 120, 61, 2, 673, 674, 5, 202, 102,
	2, 674, 119, 3, 2, 2, 2, 675, 677, 10, 7, 2, 2, 676, 675, 3, 2, 2, 2, 677,
	680, 3, 2, 2, 2, 678, 676, 3, 2, 2, 2, 678, 679, 3, 2, 2, 2, 679, 121,
	3, 2, 2, 2, 680, 678, 3, 2, 2, 2, 681, 683, 5, 204, 103, 2, 682, 684, 5,
	174, 88, 2, 683, 682, 3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 685, 3, 2,
	2, 2, 685, 686, 5, 170, 86, 2, 686, 123, 3, 2, 2, 2, 687, 688, 5, 206,
	104, 2, 688, 692, 5, 126, 64, 2, 689, 690, 5, 210, 106, 2, 690, 691, 5,
	132, 67, 2, 691, 693, 3, 2, 2, 2, 692, 689, 3, 2, 2, 2, 692, 693, 3, 2,
	2, 2, 693, 694, 3, 2, 2, 2, 694, 695, 5, 208, 105, 2, 695, 125, 3, 2, 2,
	2, 696, 697, 5, 128, 65, 2, 697, 698, 7, 3, 2, 2, 698, 699, 5, 130, 66,
	2, 699, 702, 3, 2, 2, 2, 700, 702, 5, 144, 73, 2, 701, 696, 3, 2, 2, 2,
	701, 700, 3, 2, 2, 2, 702, 127, 3, 2, 2, 2, 703, 704, 7, 4, 2, 2, 704,
	705, 7, 5, 2, 2, 705, 129, 3, 2, 2, 2, 706, 708, 10, 8, 2, 2, 707, 706,
	3, 2, 2, 2, 708, 709, 3, 2, 2, 2, 709, 707, 3, 2, 2, 2, 709, 710, 3, 2,
	2, 2, 710, 131, 3, 2, 2, 2, 711, 712, 5, 70, 36, 2, 712, 713, 5, 134, 68,
	2, 713, 716, 3, 2, 2, 2, 714, 716, 5, 146, 74, 2, 715, 711, 3, 2, 2, 2,
	715, 714, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 715, 3, 2, 2, 2, 717,
	718, 3, 2, 2, 2, 718, 133, 3, 2, 2, 2, 719, 723, 5, 180, 91, 2, 720, 721,
	5, 70, 36, 2, 721, 722, 5, 136, 69, 2, 722, 724, 3, 2, 2, 2, 723, 720,
	3, 2, 2, 2, 724, 725, 3, 2, 2, 2, 725, 723, 3, 2, 2, 2, 725, 726, 3, 2,
	2, 2, 726, 727, 3, 2, 2, 2, 727, 728, 5, 180, 91, 2, 728, 749, 3, 2, 2,
	2, 729, 733, 5, 182, 92, 2, 730, 731, 5, 70, 36, 2, 731, 732, 5, 138, 70,
	2, 732, 734, 3, 2, 2, 2, 733, 730, 3, 2, 2, 2, 734, 735, 3, 2, 2, 2, 735,
	733, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 737, 3, 2, 2, 2, 737, 738,
	5, 182, 92, 2, 738, 749, 3, 2, 2, 2, 739, 740, 5, 70, 36, 2, 740, 741,
	5, 142, 72, 2, 741, 743, 3, 2, 2, 2, 742, 739, 3, 2, 2, 2, 743, 744, 3,
	2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 746, 3, 2, 2,
	2, 746, 747, 5, 70, 36, 2, 747, 749, 3, 2, 2, 2, 748, 719, 3, 2, 2, 2,
	748, 729, 3, 2, 2, 2, 748, 742, 3, 2, 2, 2, 749, 135, 3, 2, 2, 2, 750,
	751, 5, 182, 92, 2, 751, 752, 5, 140, 71, 2, 752, 753, 5, 182, 92, 2, 753,
	756, 3, 2, 2, 2, 754, 756, 5, 142, 72, 2, 755, 750, 3, 2, 2, 2, 755, 754,
	3, 2, 2, 2, 756, 137, 3, 2, 2, 2, 757, 758, 5, 180, 91, 2, 758, 759, 5,
	140, 71, 2, 759, 760, 5, 180, 91, 2, 760, 763, 3, 2, 2, 2, 761, 763, 5,
	142, 72, 2, 762, 757, 3, 2, 2, 2, 762, 761, 3, 2, 2, 2, 763, 139, 3, 2,
	2, 2, 764, 765, 5, 70, 36, 2, 765, 766, 5, 142, 72, 2, 766, 768, 3, 2,
	2, 2, 767, 764, 3, 2, 2, 2, 768, 769, 3, 2, 2, 2, 769, 767, 3, 2, 2, 2,
	769, 770, 3, 2, 2, 2, 770, 771, 3, 2, 2, 2, 771, 772, 5, 70, 36, 2, 772,
	141, 3, 2, 2, 2, 773, 777, 10, 9, 2, 2, 774, 777, 5, 220, 111, 2, 775,
	777, 5, 168, 85, 2, 776, 773, 3, 2, 2, 2, 776, 774, 3, 2, 2, 2, 776, 775,
	3, 2, 2, 2, 777, 778, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2, 778, 779, 3, 2,
	2, 2, 779, 143, 3, 2, 2, 2, 780, 782, 10, 8, 2, 2, 781, 780, 3, 2, 2, 2,
	782, 783, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784,
	145, 3, 2, 2, 2, 785, 786, 5, 212, 107, 2, 786, 788, 5, 148, 75, 2, 787,
	789, 5, 150, 76, 2, 788, 787, 3, 2, 2, 2, 788, 789, 3, 2, 2, 2, 789, 790,
	3, 2, 2, 2, 790, 791, 5, 214, 108, 2, 791, 147, 3, 2, 2, 2, 792, 794, 10,
	10, 2, 2, 793, 792, 3, 2, 2, 2, 794, 795, 3, 2, 2, 2, 795, 793, 3, 2, 2,
	2, 795, 796, 3, 2, 2, 2, 796, 149, 3, 2, 2, 2, 797, 799, 5, 216, 109, 2,
	798, 800, 5, 152, 77, 2, 799, 798, 3, 2, 2, 2, 800, 801, 3, 2, 2, 2, 801,
	799, 3, 2, 2, 2, 801, 802, 3, 2, 2, 2, 802, 151, 3, 2, 2, 2, 803, 807,
	5, 180, 91, 2, 804, 805, 5, 70, 36, 2, 805, 806, 5, 154, 78, 2, 806, 808,
	3, 2, 2, 2, 807, 804, 3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 809, 807, 3, 2,
	2, 2, 809, 810, 3, 2, 2, 2, 810, 811, 3, 2, 2, 2, 811, 812, 5, 180, 91,
	2, 812, 825, 3, 2, 2, 2, 813, 817, 5, 182, 92, 2, 814, 815, 5, 70, 36,
	2, 815, 816, 5, 156, 79, 2, 816, 818, 3, 2, 2, 2, 817, 814, 3, 2, 2, 2,
	818, 819, 3, 2, 2, 2, 819, 817, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2, 820,
	821, 3, 2, 2, 2, 821, 822, 5, 182, 92, 2, 822, 825, 3, 2, 2, 2, 823, 825,
	5, 160, 81, 2, 824, 803, 3, 2, 2, 2, 824, 813, 3, 2, 2, 2, 824, 823, 3,
	2, 2, 2, 825, 153, 3, 2, 2, 2, 826, 827, 5, 182, 92, 2, 827, 828, 5, 140,
	71, 2, 828, 829, 5, 182, 92, 2, 829, 832, 3, 2, 2, 2, 830, 832, 5, 160,
	81, 2, 831, 826, 3, 2, 2, 2, 831, 830, 3, 2, 2, 2, 832, 155, 3, 2, 2, 2,
	833, 834, 5, 180, 91, 2, 834, 835, 5, 140, 71, 2, 835, 836, 5, 180, 91,
	2, 836, 839, 3, 2, 2, 2, 837, 839, 5, 160, 81, 2, 838, 833, 3, 2, 2, 2,
	838, 837, 3, 2, 2, 2, 839, 157, 3, 2, 2, 2, 840, 841, 5, 70, 36, 2, 841,
	842, 5, 160, 81, 2, 842, 844, 3, 2, 2, 2, 843, 840, 3, 2, 2, 2, 844, 845,
	3, 2, 2, 2, 845, 843, 3, 2, 2, 2, 845, 846, 3, 2, 2, 2, 846, 847, 3, 2,
	2, 2, 847, 848, 5, 70, 36, 2, 848, 159, 3, 2, 2, 2, 849, 852, 10, 11, 2,
	2, 850, 852, 5, 220, 111, 2, 851, 849, 3, 2, 2, 2, 851, 850, 3, 2, 2, 2,
	852, 853, 3, 2, 2, 2, 853, 851, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854,
	161, 3, 2, 2, 2, 855, 856, 5, 218, 110, 2, 856, 857, 5, 164, 83, 2, 857,
	858, 5, 174, 88, 2, 858, 859, 5, 166, 84, 2, 859, 860, 5, 218, 110, 2,
	860, 163, 3, 2, 2, 2, 861, 864, 10, 12, 2, 2, 862, 864, 5, 168, 85, 2,
	863, 861, 3, 2, 2, 2, 863, 862, 3, 2, 2, 2, 864, 865, 3, 2, 2, 2, 865,
	863, 3, 2, 2, 2, 865, 866, 3, 2, 2, 2, 866, 165, 3, 2, 2, 2, 867, 870,
	10, 13, 2, 2, 868, 870, 5, 168, 85, 2, 869, 867, 3, 2, 2, 2, 869, 868,
	3, 2, 2, 2, 870, 873, 3, 2, 2, 2, 871, 869, 3, 2, 2, 2, 871, 872, 3, 2,
	2, 2, 872, 167, 3, 2, 2, 2, 873, 871, 3, 2, 2, 2, 874, 875, 7, 6, 2, 2,
	875, 876, 7, 23, 2, 2, 876, 880, 7, 23, 2, 2, 877, 878, 7, 6, 2, 2, 878,
	880, 11, 2, 2, 2, 879, 874, 3, 2, 2, 2, 879, 877, 3, 2, 2, 2, 880, 169,
	3, 2, 2, 2, 881, 883, 5, 178, 90, 2, 882, 881, 3, 2, 2, 2, 883, 884, 3,
	2, 2, 2, 884, 882, 3, 2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 888, 3, 2, 2,
	2, 886, 888, 7, 2, 2, 3, 887, 882, 3, 2, 2, 2, 887, 886, 3, 2, 2, 2, 888,
	171, 3, 2, 2, 2, 889, 892, 5, 174, 88, 2, 890, 892, 5, 178, 90, 2, 891,
	889, 3, 2, 2, 2, 891, 890, 3, 2, 2, 2, 892, 893, 3, 2, 2, 2, 893, 891,
	3, 2, 2, 2, 893, 894, 3, 2, 2, 2, 894, 173, 3, 2, 2, 2, 895, 896, 7, 9,
	2, 2, 896, 175, 3, 2, 2, 2, 897, 899, 5, 178, 90, 2, 898, 900, 5, 174,
	88, 2, 899, 898, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 903, 3, 2, 2, 2,
	901, 903, 7, 2, 2, 3, 902, 897, 3, 2, 2, 2, 902, 901, 3, 2, 2, 2, 903,
	177, 3, 2, 2, 2, 904, 905, 7, 8, 2, 2, 905, 179, 3, 2, 2, 2, 906, 907,
	7, 23, 2, 2, 907, 908, 7, 23, 2, 2, 908, 181, 3, 2, 2, 2, 909, 910, 7,
	11, 2, 2, 910, 183, 3, 2, 2, 2, 911, 912, 7, 19, 2, 2, 912, 185, 3, 2,
	2, 2, 913, 914, 7, 21, 2, 2, 914, 187, 3, 2, 2, 2, 915, 916, 7, 23, 2,
	2, 916, 189, 3, 2, 2, 2, 917, 919, 5, 178, 90, 2, 918, 920, 5, 174, 88,
	2, 919, 918, 3, 2, 2, 2, 919, 920, 3, 2, 2, 2, 920, 923, 3, 2, 2, 2, 921,
	923, 7, 2, 2, 3, 922, 917, 3, 2, 2, 2, 922, 921, 3, 2, 2, 2, 923, 191,
	3, 2, 2, 2, 924, 927, 5, 178, 90, 2, 925, 927, 7, 2, 2, 3, 926, 924, 3,
	2, 2, 2, 926, 925, 3, 2, 2, 2, 927, 193, 3, 2, 2, 2, 928, 929, 7, 20, 2,
	2, 929, 195, 3, 2, 2, 2, 930, 931, 7, 20, 2, 2, 931, 932, 7, 19, 2, 2,
	932, 197, 3, 2, 2, 2, 933, 936, 5, 178, 90, 2, 934, 936, 7, 2, 2, 3, 935,
	933, 3, 2, 2, 2, 935, 934, 3, 2, 2, 2, 936, 199, 3, 2, 2, 2, 937, 938,
	7, 12, 2, 2, 938, 201, 3, 2, 2, 2, 939, 940, 7, 13, 2, 2, 940, 203, 3,
	2, 2, 2, 941, 942, 7, 22, 2, 2, 942, 943, 7, 22, 2, 2, 943, 944, 7, 22,
	2, 2, 944, 945, 7, 22, 2, 2, 945, 205, 3, 2, 2, 2, 946, 947, 7, 14, 2,
	2, 947, 207, 3, 2, 2, 2, 948, 949, 7, 15, 2, 2, 949, 209, 3, 2, 2, 2, 950,
	951, 7, 20, 2, 2, 951, 211, 3, 2, 2, 2, 952, 953, 7, 16, 2, 2, 953, 213,
	3, 2, 2, 2, 954, 955, 7, 17, 2, 2, 955, 215, 3, 2, 2, 2, 956, 957, 7, 20,
	2, 2, 957, 217, 3, 2, 2, 2, 958, 959, 7, 25, 2, 2, 959, 219, 3, 2, 2, 2,
	960, 961, 7, 18, 2, 2, 961, 221, 3, 2, 2, 2, 141, 225, 233, 241, 250, 253,
	255, 262, 267, 269, 275, 283, 288, 291, 296, 299, 301, 304, 309, 313, 322,
	327, 332, 336, 341, 344, 349, 352, 355, 358, 361, 366, 370, 377, 382, 386,
	391, 393, 397, 402, 404, 409, 412, 419, 423, 425, 427, 432, 435, 443, 446,
	454, 462, 467, 474, 482, 486, 494, 498, 500, 504, 507, 512, 517, 519, 524,
	529, 531, 536, 541, 546, 549, 556, 567, 570, 576, 580, 583, 587, 590, 592,
	599, 602, 607, 610, 616, 618, 623, 626, 629, 632, 637, 643, 647, 652, 654,
	660, 678, 683, 692, 701, 709, 715, 717, 725, 735, 744, 748, 755, 762, 769,
	776, 778, 783, 788, 795, 801, 809, 819, 824, 831, 838, 845, 851, 853, 863,
	865, 869, 871, 879, 884, 887, 891, 893, 899, 902, 919, 922, 926, 935,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "':'", "'C'", "'2'", "'~'", "", "", "", "", "'//'", "'{{{'", "'}}}'",
	"'[['", "']]'", "'{{'", "'}}'", "'\\\\'", "'='", "'|'", "'#'", "'-'", "'*'",
	"'/'", "'@@'",
}
var symbolicNames = []string{
	"", "", "", "", "ESCAPE", "NOWIKI_BLOCK_CLOSE", "NEWLINE", "BLANKS", "COLON_SLASH",
	"ITAL", "NOWIKI_OPEN", "NOWIKI_CLOSE", "LINK_OPEN", "LINK_CLOSE", "IMAGE_OPEN",
	"IMAGE_CLOSE", "FORCED_LINEBREAK", "EQUAL", "PIPE", "POUND", "DASH", "STAR",
	"SLASH", "EXTENSION", "INSIGNIFICANT_CHAR",
}

var ruleNames = []string{
	"start", "wikipage", "paragraphs", "paragraph", "text_paragraph", "text_line",
	"text_firstelement", "text_formattedelement", "text_boldcontent", "text_element",
	"nachmarkup", "text_italcontent", "text_boldcontentpart", "text_italcontentpart",
	"text_bolditalcontent", "text_formattedcontent", "text_lineseparator1",
	"text_inlineelement", "text_first_inlineelement", "text_first_unformattedelement",
	"text_first_unformatted", "text_unformattedelement", "text_unformatted",
	"heading", "heading_content", "list_ord", "list_ordelem", "list_unord",
	"list_unordelem", "list_elem", "list_elem_markup", "list_elemcontent",
	"list_elemcontentpart", "list_formatted_elem", "onestar", "list_boldcontentpart",
	"list_italcontentpart", "list_bolditalcontent", "table", "table_row", "table_cell",
	"table_headercell", "table_normalcell", "table_cellcontent", "table_cellcontentpart",
	"table_formattedelement", "table_boldcontent", "table_italcontent", "table_boldcontentpart",
	"table_italcontentpart", "table_bolditalcontent", "table_formattedcontent",
	"table_inlineelement", "table_unformattedelement", "table_unformatted",
	"nowiki_block", "nowikiblock_open_markup", "nowikiblock_close_markup",
	"nowiki_inline", "nowiki_inline_content", "horizontalrule", "link", "link_address",
	"link_interwiki_uri", "link_interwiki_pagename", "link_description", "link_descriptionpart",
	"link_bold_descriptionpart", "link_ital_descriptionpart", "link_boldital_description",
	"link_descriptiontext", "link_uri", "image", "image_uri", "image_alternative",
	"image_alternativepart", "image_bold_alternativepart", "image_ital_alternativepart",
	"image_boldital_alternative", "image_alternativetext", "extension", "extension_handler",
	"extension_statement", "escaped", "paragraph_separator", "whitespaces",
	"blanks", "text_lineseparator", "newline", "bold_markup", "ital_markup",
	"heading_markup", "list_ordelem_markup", "list_unordelem_markup", "list_elemseparator",
	"end_of_list", "table_cell_markup", "table_headercell_markup", "table_rowseparator",
	"nowiki_open_markup", "nowiki_close_markup", "horizontalrule_markup", "link_open_markup",
	"link_close_markup", "link_description_markup", "image_open_markup", "image_close_markup",
	"image_alternative_markup", "extension_markup", "forced_linebreak",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type Creole10Parser struct {
	*antlr.BaseParser
}

func NewCreole10Parser(input antlr.TokenStream) *Creole10Parser {
	this := new(Creole10Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "Creole10.g4"

	return this
}

// Creole10Parser tokens.
const (
	Creole10ParserEOF                = antlr.TokenEOF
	Creole10ParserT__0               = 1
	Creole10ParserT__1               = 2
	Creole10ParserT__2               = 3
	Creole10ParserESCAPE             = 4
	Creole10ParserNOWIKI_BLOCK_CLOSE = 5
	Creole10ParserNEWLINE            = 6
	Creole10ParserBLANKS             = 7
	Creole10ParserCOLON_SLASH        = 8
	Creole10ParserITAL               = 9
	Creole10ParserNOWIKI_OPEN        = 10
	Creole10ParserNOWIKI_CLOSE       = 11
	Creole10ParserLINK_OPEN          = 12
	Creole10ParserLINK_CLOSE         = 13
	Creole10ParserIMAGE_OPEN         = 14
	Creole10ParserIMAGE_CLOSE        = 15
	Creole10ParserFORCED_LINEBREAK   = 16
	Creole10ParserEQUAL              = 17
	Creole10ParserPIPE               = 18
	Creole10ParserPOUND              = 19
	Creole10ParserDASH               = 20
	Creole10ParserSTAR               = 21
	Creole10ParserSLASH              = 22
	Creole10ParserEXTENSION          = 23
	Creole10ParserINSIGNIFICANT_CHAR = 24
)

// Creole10Parser rules.
const (
	Creole10ParserRULE_start                         = 0
	Creole10ParserRULE_wikipage                      = 1
	Creole10ParserRULE_paragraphs                    = 2
	Creole10ParserRULE_paragraph                     = 3
	Creole10ParserRULE_text_paragraph                = 4
	Creole10ParserRULE_text_line                     = 5
	Creole10ParserRULE_text_firstelement             = 6
	Creole10ParserRULE_text_formattedelement         = 7
	Creole10ParserRULE_text_boldcontent              = 8
	Creole10ParserRULE_text_element                  = 9
	Creole10ParserRULE_nachmarkup                    = 10
	Creole10ParserRULE_text_italcontent              = 11
	Creole10ParserRULE_text_boldcontentpart          = 12
	Creole10ParserRULE_text_italcontentpart          = 13
	Creole10ParserRULE_text_bolditalcontent          = 14
	Creole10ParserRULE_text_formattedcontent         = 15
	Creole10ParserRULE_text_lineseparator1           = 16
	Creole10ParserRULE_text_inlineelement            = 17
	Creole10ParserRULE_text_first_inlineelement      = 18
	Creole10ParserRULE_text_first_unformattedelement = 19
	Creole10ParserRULE_text_first_unformatted        = 20
	Creole10ParserRULE_text_unformattedelement       = 21
	Creole10ParserRULE_text_unformatted              = 22
	Creole10ParserRULE_heading                       = 23
	Creole10ParserRULE_heading_content               = 24
	Creole10ParserRULE_list_ord                      = 25
	Creole10ParserRULE_list_ordelem                  = 26
	Creole10ParserRULE_list_unord                    = 27
	Creole10ParserRULE_list_unordelem                = 28
	Creole10ParserRULE_list_elem                     = 29
	Creole10ParserRULE_list_elem_markup              = 30
	Creole10ParserRULE_list_elemcontent              = 31
	Creole10ParserRULE_list_elemcontentpart          = 32
	Creole10ParserRULE_list_formatted_elem           = 33
	Creole10ParserRULE_onestar                       = 34
	Creole10ParserRULE_list_boldcontentpart          = 35
	Creole10ParserRULE_list_italcontentpart          = 36
	Creole10ParserRULE_list_bolditalcontent          = 37
	Creole10ParserRULE_table                         = 38
	Creole10ParserRULE_table_row                     = 39
	Creole10ParserRULE_table_cell                    = 40
	Creole10ParserRULE_table_headercell              = 41
	Creole10ParserRULE_table_normalcell              = 42
	Creole10ParserRULE_table_cellcontent             = 43
	Creole10ParserRULE_table_cellcontentpart         = 44
	Creole10ParserRULE_table_formattedelement        = 45
	Creole10ParserRULE_table_boldcontent             = 46
	Creole10ParserRULE_table_italcontent             = 47
	Creole10ParserRULE_table_boldcontentpart         = 48
	Creole10ParserRULE_table_italcontentpart         = 49
	Creole10ParserRULE_table_bolditalcontent         = 50
	Creole10ParserRULE_table_formattedcontent        = 51
	Creole10ParserRULE_table_inlineelement           = 52
	Creole10ParserRULE_table_unformattedelement      = 53
	Creole10ParserRULE_table_unformatted             = 54
	Creole10ParserRULE_nowiki_block                  = 55
	Creole10ParserRULE_nowikiblock_open_markup       = 56
	Creole10ParserRULE_nowikiblock_close_markup      = 57
	Creole10ParserRULE_nowiki_inline                 = 58
	Creole10ParserRULE_nowiki_inline_content         = 59
	Creole10ParserRULE_horizontalrule                = 60
	Creole10ParserRULE_link                          = 61
	Creole10ParserRULE_link_address                  = 62
	Creole10ParserRULE_link_interwiki_uri            = 63
	Creole10ParserRULE_link_interwiki_pagename       = 64
	Creole10ParserRULE_link_description              = 65
	Creole10ParserRULE_link_descriptionpart          = 66
	Creole10ParserRULE_link_bold_descriptionpart     = 67
	Creole10ParserRULE_link_ital_descriptionpart     = 68
	Creole10ParserRULE_link_boldital_description     = 69
	Creole10ParserRULE_link_descriptiontext          = 70
	Creole10ParserRULE_link_uri                      = 71
	Creole10ParserRULE_image                         = 72
	Creole10ParserRULE_image_uri                     = 73
	Creole10ParserRULE_image_alternative             = 74
	Creole10ParserRULE_image_alternativepart         = 75
	Creole10ParserRULE_image_bold_alternativepart    = 76
	Creole10ParserRULE_image_ital_alternativepart    = 77
	Creole10ParserRULE_image_boldital_alternative    = 78
	Creole10ParserRULE_image_alternativetext         = 79
	Creole10ParserRULE_extension                     = 80
	Creole10ParserRULE_extension_handler             = 81
	Creole10ParserRULE_extension_statement           = 82
	Creole10ParserRULE_escaped                       = 83
	Creole10ParserRULE_paragraph_separator           = 84
	Creole10ParserRULE_whitespaces                   = 85
	Creole10ParserRULE_blanks                        = 86
	Creole10ParserRULE_text_lineseparator            = 87
	Creole10ParserRULE_newline                       = 88
	Creole10ParserRULE_bold_markup                   = 89
	Creole10ParserRULE_ital_markup                   = 90
	Creole10ParserRULE_heading_markup                = 91
	Creole10ParserRULE_list_ordelem_markup           = 92
	Creole10ParserRULE_list_unordelem_markup         = 93
	Creole10ParserRULE_list_elemseparator            = 94
	Creole10ParserRULE_end_of_list                   = 95
	Creole10ParserRULE_table_cell_markup             = 96
	Creole10ParserRULE_table_headercell_markup       = 97
	Creole10ParserRULE_table_rowseparator            = 98
	Creole10ParserRULE_nowiki_open_markup            = 99
	Creole10ParserRULE_nowiki_close_markup           = 100
	Creole10ParserRULE_horizontalrule_markup         = 101
	Creole10ParserRULE_link_open_markup              = 102
	Creole10ParserRULE_link_close_markup             = 103
	Creole10ParserRULE_link_description_markup       = 104
	Creole10ParserRULE_image_open_markup             = 105
	Creole10ParserRULE_image_close_markup            = 106
	Creole10ParserRULE_image_alternative_markup      = 107
	Creole10ParserRULE_extension_markup              = 108
	Creole10ParserRULE_forced_linebreak              = 109
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) Wikipage() IWikipageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWikipageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWikipageContext)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitStart(s)
	}
}

func (p *Creole10Parser) Start() (localctx IStartContext) {
	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Creole10ParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(220)
		p.Wikipage()
	}

	return localctx
}

// IWikipageContext is an interface to support dynamic dispatch.
type IWikipageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWikipageContext differentiates from other interfaces.
	IsWikipageContext()
}

type WikipageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWikipageContext() *WikipageContext {
	var p = new(WikipageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_wikipage
	return p
}

func (*WikipageContext) IsWikipageContext() {}

func NewWikipageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WikipageContext {
	var p = new(WikipageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_wikipage

	return p
}

func (s *WikipageContext) GetParser() antlr.Parser { return s.parser }

func (s *WikipageContext) Paragraphs() IParagraphsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *WikipageContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *WikipageContext) Whitespaces() IWhitespacesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhitespacesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhitespacesContext)
}

func (s *WikipageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WikipageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WikipageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterWikipage(s)
	}
}

func (s *WikipageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitWikipage(s)
	}
}

func (p *Creole10Parser) Wikipage() (localctx IWikipageContext) {
	localctx = NewWikipageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Creole10ParserRULE_wikipage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(223)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(222)
			p.Whitespaces()
		}

	}
	{
		p.SetState(225)
		p.Paragraphs()
	}
	{
		p.SetState(226)
		p.Match(Creole10ParserEOF)
	}

	return localctx
}

// IParagraphsContext is an interface to support dynamic dispatch.
type IParagraphsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphsContext differentiates from other interfaces.
	IsParagraphsContext()
}

type ParagraphsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphsContext() *ParagraphsContext {
	var p = new(ParagraphsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_paragraphs
	return p
}

func (*ParagraphsContext) IsParagraphsContext() {}

func NewParagraphsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphsContext {
	var p = new(ParagraphsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_paragraphs

	return p
}

func (s *ParagraphsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphsContext) AllParagraph() []IParagraphContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParagraphContext)(nil)).Elem())
	var tst = make([]IParagraphContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParagraphContext)
		}
	}

	return tst
}

func (s *ParagraphsContext) Paragraph(i int) IParagraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraphContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ParagraphsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterParagraphs(s)
	}
}

func (s *ParagraphsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitParagraphs(s)
	}
}

func (p *Creole10Parser) Paragraphs() (localctx IParagraphsContext) {
	localctx = NewParagraphsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Creole10ParserRULE_paragraphs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(228)
				p.Paragraph()
			}

		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}

	return localctx
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_paragraph
	return p
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) Nowiki_block() INowiki_blockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_blockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_blockContext)
}

func (s *ParagraphContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *ParagraphContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *ParagraphContext) Heading() IHeadingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeadingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeadingContext)
}

func (s *ParagraphContext) Horizontalrule() IHorizontalruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHorizontalruleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHorizontalruleContext)
}

func (s *ParagraphContext) List_unord() IList_unordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_unordContext)
}

func (s *ParagraphContext) List_ord() IList_ordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ordContext)
}

func (s *ParagraphContext) Table() ITableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *ParagraphContext) Text_paragraph() IText_paragraphContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_paragraphContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_paragraphContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (p *Creole10Parser) Paragraph() (localctx IParagraphContext) {
	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Creole10ParserRULE_paragraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(234)
			p.Nowiki_block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(235)
			p.Blanks()
		}
		{
			p.SetState(236)
			p.Paragraph_separator()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(238)
				p.Blanks()
			}

		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(241)
				p.Heading()
			}

		case 2:
			p.SetState(242)

			if !(p.GetInputStream().LA(1) == Creole10ParserDASH &&
				p.GetInputStream().LA(2) == Creole10ParserDASH &&
				p.GetInputStream().LA(3) == Creole10ParserDASH &&
				p.GetInputStream().LA(4) == Creole10ParserDASH) {
				panic(antlr.NewFailedPredicateException(p, " p.GetInputStream().LA(1)==Creole10ParserDASH &&\r\n                  p.GetInputStream().LA(2)==Creole10ParserDASH && \r\n                  p.GetInputStream().LA(3)==Creole10ParserDASH && \r\n                  p.GetInputStream().LA(4)==Creole10ParserDASH", ""))
			}
			{
				p.SetState(243)
				p.Horizontalrule()
			}

		case 3:
			{
				p.SetState(244)
				p.List_unord()
			}

		case 4:
			{
				p.SetState(245)
				p.List_ord()
			}

		case 5:
			{
				p.SetState(246)
				p.Table()
			}

		case 6:
			{
				p.SetState(247)
				p.Text_paragraph()
			}

		}
		p.SetState(251)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(250)
				p.Paragraph_separator()
			}

		}

	}

	return localctx
}

// IText_paragraphContext is an interface to support dynamic dispatch.
type IText_paragraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_paragraphContext differentiates from other interfaces.
	IsText_paragraphContext()
}

type Text_paragraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_paragraphContext() *Text_paragraphContext {
	var p = new(Text_paragraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_paragraph
	return p
}

func (*Text_paragraphContext) IsText_paragraphContext() {}

func NewText_paragraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_paragraphContext {
	var p = new(Text_paragraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_paragraph

	return p
}

func (s *Text_paragraphContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_paragraphContext) AllText_line() []IText_lineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_lineContext)(nil)).Elem())
	var tst = make([]IText_lineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_lineContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Text_line(i int) IText_lineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_lineContext)
}

func (s *Text_paragraphContext) AllNowiki_inline() []INowiki_inlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem())
	var tst = make([]INowiki_inlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INowiki_inlineContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Nowiki_inline(i int) INowiki_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INowiki_inlineContext)
}

func (s *Text_paragraphContext) AllText_lineseparator() []IText_lineseparatorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem())
	var tst = make([]IText_lineseparatorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_lineseparatorContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Text_lineseparator(i int) IText_lineseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparatorContext)
}

func (s *Text_paragraphContext) AllText_element() []IText_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_elementContext)(nil)).Elem())
	var tst = make([]IText_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_elementContext)
		}
	}

	return tst
}

func (s *Text_paragraphContext) Text_element(i int) IText_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_elementContext)
}

func (s *Text_paragraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_paragraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_paragraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_paragraph(s)
	}
}

func (s *Text_paragraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_paragraph(s)
	}
}

func (p *Creole10Parser) Text_paragraph() (localctx IText_paragraphContext) {
	localctx = NewText_paragraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Creole10ParserRULE_text_paragraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(265)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(255)
					p.Text_line()
				}

			case 2:
				{
					p.SetState(256)
					p.Nowiki_inline()
				}
				p.SetState(260)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())

				for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
					if _alt == 1 {
						{
							p.SetState(257)
							p.Text_element()
						}

					}
					p.SetState(262)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
				}

				{
					p.SetState(263)
					p.Text_lineseparator()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IText_lineContext is an interface to support dynamic dispatch.
type IText_lineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_lineContext differentiates from other interfaces.
	IsText_lineContext()
}

type Text_lineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_lineContext() *Text_lineContext {
	var p = new(Text_lineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_line
	return p
}

func (*Text_lineContext) IsText_lineContext() {}

func NewText_lineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_lineContext {
	var p = new(Text_lineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_line

	return p
}

func (s *Text_lineContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_lineContext) Text_firstelement() IText_firstelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_firstelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_firstelementContext)
}

func (s *Text_lineContext) Text_lineseparator() IText_lineseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparatorContext)
}

func (s *Text_lineContext) AllText_element() []IText_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_elementContext)(nil)).Elem())
	var tst = make([]IText_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_elementContext)
		}
	}

	return tst
}

func (s *Text_lineContext) Text_element(i int) IText_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_elementContext)
}

func (s *Text_lineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_lineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_lineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_line(s)
	}
}

func (s *Text_lineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_line(s)
	}
}

func (p *Creole10Parser) Text_line() (localctx IText_lineContext) {
	localctx = NewText_lineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Creole10ParserRULE_text_line)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.Text_firstelement()
	}
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(270)
				p.Text_element()
			}

		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}

	{
		p.SetState(276)
		p.Text_lineseparator()
	}

	return localctx
}

// IText_firstelementContext is an interface to support dynamic dispatch.
type IText_firstelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_firstelementContext differentiates from other interfaces.
	IsText_firstelementContext()
}

type Text_firstelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_firstelementContext() *Text_firstelementContext {
	var p = new(Text_firstelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_firstelement
	return p
}

func (*Text_firstelementContext) IsText_firstelementContext() {}

func NewText_firstelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_firstelementContext {
	var p = new(Text_firstelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_firstelement

	return p
}

func (s *Text_firstelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_firstelementContext) Text_formattedelement() IText_formattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedelementContext)
}

func (s *Text_firstelementContext) Text_first_unformattedelement() IText_first_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_unformattedelementContext)
}

func (s *Text_firstelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_firstelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_firstelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_firstelement(s)
	}
}

func (s *Text_firstelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_firstelement(s)
	}
}

func (p *Creole10Parser) Text_firstelement() (localctx IText_firstelementContext) {
	localctx = NewText_firstelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Creole10ParserRULE_text_firstelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(278)

		if !(p.GetInputStream().LA(1) != Creole10ParserSTAR ||
			(p.GetInputStream().LA(1) == Creole10ParserSTAR &&
				p.GetInputStream().LA(2) == Creole10ParserSTAR)) {
			panic(antlr.NewFailedPredicateException(p, " p.GetInputStream().LA(1) != Creole10ParserSTAR || \r\n         (p.GetInputStream().LA(1) == Creole10ParserSTAR && \r\n         p.GetInputStream().LA(2) == Creole10ParserSTAR)", ""))
		}
		{
			p.SetState(279)
			p.Text_formattedelement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(280)
			p.Text_first_unformattedelement()
		}

	}

	return localctx
}

// IText_formattedelementContext is an interface to support dynamic dispatch.
type IText_formattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_formattedelementContext differentiates from other interfaces.
	IsText_formattedelementContext()
}

type Text_formattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_formattedelementContext() *Text_formattedelementContext {
	var p = new(Text_formattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_formattedelement
	return p
}

func (*Text_formattedelementContext) IsText_formattedelementContext() {}

func NewText_formattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_formattedelementContext {
	var p = new(Text_formattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_formattedelement

	return p
}

func (s *Text_formattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_formattedelementContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Text_formattedelementContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Text_formattedelementContext) Text_italcontent() IText_italcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_italcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_italcontentContext)
}

func (s *Text_formattedelementContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, 0)
}

func (s *Text_formattedelementContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Text_formattedelementContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Text_formattedelementContext) Text_boldcontent() IText_boldcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_boldcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_boldcontentContext)
}

func (s *Text_formattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_formattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_formattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_formattedelement(s)
	}
}

func (s *Text_formattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_formattedelement(s)
	}
}

func (p *Creole10Parser) Text_formattedelement() (localctx IText_formattedelementContext) {
	localctx = NewText_formattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Creole10ParserRULE_text_formattedelement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(299)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			p.Ital_markup()
		}
		{
			p.SetState(284)
			p.Text_italcontent()
		}
		p.SetState(289)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) == 1 {
			p.SetState(286)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Creole10ParserNEWLINE {
				{
					p.SetState(285)
					p.Match(Creole10ParserNEWLINE)
				}

			}
			{
				p.SetState(288)
				p.Ital_markup()
			}

		}

	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(291)
			p.Bold_markup()
		}
		{
			p.SetState(292)
			p.Text_boldcontent()
		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			p.SetState(294)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Creole10ParserNEWLINE {
				{
					p.SetState(293)
					p.Match(Creole10ParserNEWLINE)
				}

			}
			{
				p.SetState(296)
				p.Bold_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_boldcontentContext is an interface to support dynamic dispatch.
type IText_boldcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_boldcontentContext differentiates from other interfaces.
	IsText_boldcontentContext()
}

type Text_boldcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_boldcontentContext() *Text_boldcontentContext {
	var p = new(Text_boldcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_boldcontent
	return p
}

func (*Text_boldcontentContext) IsText_boldcontentContext() {}

func NewText_boldcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_boldcontentContext {
	var p = new(Text_boldcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_boldcontent

	return p
}

func (s *Text_boldcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_boldcontentContext) Nachmarkup() INachmarkupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INachmarkupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INachmarkupContext)
}

func (s *Text_boldcontentContext) AllText_boldcontentpart() []IText_boldcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_boldcontentpartContext)(nil)).Elem())
	var tst = make([]IText_boldcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_boldcontentpartContext)
		}
	}

	return tst
}

func (s *Text_boldcontentContext) Text_boldcontentpart(i int) IText_boldcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_boldcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_boldcontentpartContext)
}

func (s *Text_boldcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_boldcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_boldcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_boldcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_boldcontent(s)
	}
}

func (s *Text_boldcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_boldcontent(s)
	}
}

func (p *Creole10Parser) Text_boldcontent() (localctx IText_boldcontentContext) {
	localctx = NewText_boldcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Creole10ParserRULE_text_boldcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(311)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(301)
				p.Nachmarkup()
			}

		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(304)
					p.Text_boldcontentpart()
				}

			}
			p.SetState(309)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(310)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// IText_elementContext is an interface to support dynamic dispatch.
type IText_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_elementContext differentiates from other interfaces.
	IsText_elementContext()
}

type Text_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_elementContext() *Text_elementContext {
	var p = new(Text_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_element
	return p
}

func (*Text_elementContext) IsText_elementContext() {}

func NewText_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_elementContext {
	var p = new(Text_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_element

	return p
}

func (s *Text_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_elementContext) Onestar() IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Text_elementContext) Text_unformattedelement() IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *Text_elementContext) Text_formattedelement() IText_formattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedelementContext)
}

func (s *Text_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_element(s)
	}
}

func (s *Text_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_element(s)
	}
}

func (p *Creole10Parser) Text_element() (localctx IText_elementContext) {
	localctx = NewText_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Creole10ParserRULE_text_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(313)
			p.Onestar()
		}
		{
			p.SetState(314)
			p.Text_unformattedelement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.Text_unformattedelement()
		}
		{
			p.SetState(317)
			p.Onestar()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(319)
			p.Text_formattedelement()
		}

	}

	return localctx
}

// INachmarkupContext is an interface to support dynamic dispatch.
type INachmarkupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNachmarkupContext differentiates from other interfaces.
	IsNachmarkupContext()
}

type NachmarkupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNachmarkupContext() *NachmarkupContext {
	var p = new(NachmarkupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nachmarkup
	return p
}

func (*NachmarkupContext) IsNachmarkupContext() {}

func NewNachmarkupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NachmarkupContext {
	var p = new(NachmarkupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nachmarkup

	return p
}

func (s *NachmarkupContext) GetParser() antlr.Parser { return s.parser }

func (s *NachmarkupContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, 0)
}

func (s *NachmarkupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NachmarkupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NachmarkupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNachmarkup(s)
	}
}

func (s *NachmarkupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNachmarkup(s)
	}
}

func (p *Creole10Parser) Nachmarkup() (localctx INachmarkupContext) {
	localctx = NewNachmarkupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Creole10ParserRULE_nachmarkup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(322)
		p.Match(Creole10ParserNEWLINE)
	}

	return localctx
}

// IText_italcontentContext is an interface to support dynamic dispatch.
type IText_italcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_italcontentContext differentiates from other interfaces.
	IsText_italcontentContext()
}

type Text_italcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_italcontentContext() *Text_italcontentContext {
	var p = new(Text_italcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_italcontent
	return p
}

func (*Text_italcontentContext) IsText_italcontentContext() {}

func NewText_italcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_italcontentContext {
	var p = new(Text_italcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_italcontent

	return p
}

func (s *Text_italcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_italcontentContext) Nachmarkup() INachmarkupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INachmarkupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INachmarkupContext)
}

func (s *Text_italcontentContext) AllText_italcontentpart() []IText_italcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_italcontentpartContext)(nil)).Elem())
	var tst = make([]IText_italcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_italcontentpartContext)
		}
	}

	return tst
}

func (s *Text_italcontentContext) Text_italcontentpart(i int) IText_italcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_italcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_italcontentpartContext)
}

func (s *Text_italcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_italcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_italcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_italcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_italcontent(s)
	}
}

func (s *Text_italcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_italcontent(s)
	}
}

func (p *Creole10Parser) Text_italcontent() (localctx IText_italcontentContext) {
	localctx = NewText_italcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Creole10ParserRULE_text_italcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(325)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(324)
				p.Nachmarkup()
			}

		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(327)
					p.Text_italcontentpart()
				}

			}
			p.SetState(332)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(333)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// IText_boldcontentpartContext is an interface to support dynamic dispatch.
type IText_boldcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_boldcontentpartContext differentiates from other interfaces.
	IsText_boldcontentpartContext()
}

type Text_boldcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_boldcontentpartContext() *Text_boldcontentpartContext {
	var p = new(Text_boldcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_boldcontentpart
	return p
}

func (*Text_boldcontentpartContext) IsText_boldcontentpartContext() {}

func NewText_boldcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_boldcontentpartContext {
	var p = new(Text_boldcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_boldcontentpart

	return p
}

func (s *Text_boldcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_boldcontentpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Text_boldcontentpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Text_boldcontentpartContext) Text_bolditalcontent() IText_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_bolditalcontentContext)
}

func (s *Text_boldcontentpartContext) Text_formattedcontent() IText_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedcontentContext)
}

func (s *Text_boldcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_boldcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_boldcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_boldcontentpart(s)
	}
}

func (s *Text_boldcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_boldcontentpart(s)
	}
}

func (p *Creole10Parser) Text_boldcontentpart() (localctx IText_boldcontentpartContext) {
	localctx = NewText_boldcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Creole10ParserRULE_text_boldcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(336)
			p.Ital_markup()
		}
		{
			p.SetState(337)
			p.Text_bolditalcontent()
		}
		p.SetState(339)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(338)
				p.Ital_markup()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(341)
			p.Text_formattedcontent()
		}

	}

	return localctx
}

// IText_italcontentpartContext is an interface to support dynamic dispatch.
type IText_italcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_italcontentpartContext differentiates from other interfaces.
	IsText_italcontentpartContext()
}

type Text_italcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_italcontentpartContext() *Text_italcontentpartContext {
	var p = new(Text_italcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_italcontentpart
	return p
}

func (*Text_italcontentpartContext) IsText_italcontentpartContext() {}

func NewText_italcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_italcontentpartContext {
	var p = new(Text_italcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_italcontentpart

	return p
}

func (s *Text_italcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_italcontentpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Text_italcontentpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Text_italcontentpartContext) Text_bolditalcontent() IText_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_bolditalcontentContext)
}

func (s *Text_italcontentpartContext) Text_formattedcontent() IText_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedcontentContext)
}

func (s *Text_italcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_italcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_italcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_italcontentpart(s)
	}
}

func (s *Text_italcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_italcontentpart(s)
	}
}

func (p *Creole10Parser) Text_italcontentpart() (localctx IText_italcontentpartContext) {
	localctx = NewText_italcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Creole10ParserRULE_text_italcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(344)
			p.Bold_markup()
		}
		{
			p.SetState(345)
			p.Text_bolditalcontent()
		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(346)
				p.Bold_markup()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(349)
			p.Text_formattedcontent()
		}

	}

	return localctx
}

// IText_bolditalcontentContext is an interface to support dynamic dispatch.
type IText_bolditalcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_bolditalcontentContext differentiates from other interfaces.
	IsText_bolditalcontentContext()
}

type Text_bolditalcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_bolditalcontentContext() *Text_bolditalcontentContext {
	var p = new(Text_bolditalcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_bolditalcontent
	return p
}

func (*Text_bolditalcontentContext) IsText_bolditalcontentContext() {}

func NewText_bolditalcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_bolditalcontentContext {
	var p = new(Text_bolditalcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_bolditalcontent

	return p
}

func (s *Text_bolditalcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_bolditalcontentContext) Nachmarkup() INachmarkupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INachmarkupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INachmarkupContext)
}

func (s *Text_bolditalcontentContext) Text_formattedcontent() IText_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_formattedcontentContext)
}

func (s *Text_bolditalcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_bolditalcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_bolditalcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_bolditalcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_bolditalcontent(s)
	}
}

func (s *Text_bolditalcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_bolditalcontent(s)
	}
}

func (p *Creole10Parser) Text_bolditalcontent() (localctx IText_bolditalcontentContext) {
	localctx = NewText_bolditalcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Creole10ParserRULE_text_bolditalcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(353)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(352)
				p.Nachmarkup()
			}

		}
		p.SetState(356)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(355)
				p.Text_formattedcontent()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(358)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// IText_formattedcontentContext is an interface to support dynamic dispatch.
type IText_formattedcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_formattedcontentContext differentiates from other interfaces.
	IsText_formattedcontentContext()
}

type Text_formattedcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_formattedcontentContext() *Text_formattedcontentContext {
	var p = new(Text_formattedcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_formattedcontent
	return p
}

func (*Text_formattedcontentContext) IsText_formattedcontentContext() {}

func NewText_formattedcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_formattedcontentContext {
	var p = new(Text_formattedcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_formattedcontent

	return p
}

func (s *Text_formattedcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_formattedcontentContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Text_formattedcontentContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Text_formattedcontentContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *Text_formattedcontentContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *Text_formattedcontentContext) AllText_lineseparator1() []IText_lineseparator1Context {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_lineseparator1Context)(nil)).Elem())
	var tst = make([]IText_lineseparator1Context, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_lineseparator1Context)
		}
	}

	return tst
}

func (s *Text_formattedcontentContext) Text_lineseparator1(i int) IText_lineseparator1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparator1Context)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparator1Context)
}

func (s *Text_formattedcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_formattedcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_formattedcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_formattedcontent(s)
	}
}

func (s *Text_formattedcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_formattedcontent(s)
	}
}

func (p *Creole10Parser) Text_formattedcontent() (localctx IText_formattedcontentContext) {
	localctx = NewText_formattedcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Creole10ParserRULE_text_formattedcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(361)
				p.Onestar()
			}
			{
				p.SetState(362)
				p.Text_unformattedelement()
			}
			p.SetState(364)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(363)
					p.Text_lineseparator1()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(368)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext())
	}

	return localctx
}

// IText_lineseparator1Context is an interface to support dynamic dispatch.
type IText_lineseparator1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_lineseparator1Context differentiates from other interfaces.
	IsText_lineseparator1Context()
}

type Text_lineseparator1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_lineseparator1Context() *Text_lineseparator1Context {
	var p = new(Text_lineseparator1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_lineseparator1
	return p
}

func (*Text_lineseparator1Context) IsText_lineseparator1Context() {}

func NewText_lineseparator1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_lineseparator1Context {
	var p = new(Text_lineseparator1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_lineseparator1

	return p
}

func (s *Text_lineseparator1Context) GetParser() antlr.Parser { return s.parser }

func (s *Text_lineseparator1Context) Text_lineseparator() IText_lineseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_lineseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_lineseparatorContext)
}

func (s *Text_lineseparator1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_lineseparator1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_lineseparator1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_lineseparator1(s)
	}
}

func (s *Text_lineseparator1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_lineseparator1(s)
	}
}

func (p *Creole10Parser) Text_lineseparator1() (localctx IText_lineseparator1Context) {
	localctx = NewText_lineseparator1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Creole10ParserRULE_text_lineseparator1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(370)

	if !(p.GetInputStream().LA(2) != Creole10ParserDASH &&
		p.GetInputStream().LA(2) != Creole10ParserPOUND &&
		p.GetInputStream().LA(2) != Creole10ParserEQUAL &&
		p.GetInputStream().LA(2) != Creole10ParserNEWLINE) {
		panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(2) != Creole10ParserDASH && \r\n         p.GetInputStream().LA(2) != Creole10ParserPOUND && \r\n         p.GetInputStream().LA(2) != Creole10ParserEQUAL && \r\n         p.GetInputStream().LA(2) != Creole10ParserNEWLINE", ""))
	}
	{
		p.SetState(371)
		p.Text_lineseparator()
	}

	return localctx
}

// IText_inlineelementContext is an interface to support dynamic dispatch.
type IText_inlineelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_inlineelementContext differentiates from other interfaces.
	IsText_inlineelementContext()
}

type Text_inlineelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_inlineelementContext() *Text_inlineelementContext {
	var p = new(Text_inlineelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_inlineelement
	return p
}

func (*Text_inlineelementContext) IsText_inlineelementContext() {}

func NewText_inlineelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_inlineelementContext {
	var p = new(Text_inlineelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_inlineelement

	return p
}

func (s *Text_inlineelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_inlineelementContext) Text_first_inlineelement() IText_first_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_inlineelementContext)
}

func (s *Text_inlineelementContext) Nowiki_inline() INowiki_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_inlineContext)
}

func (s *Text_inlineelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_inlineelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_inlineelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_inlineelement(s)
	}
}

func (s *Text_inlineelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_inlineelement(s)
	}
}

func (p *Creole10Parser) Text_inlineelement() (localctx IText_inlineelementContext) {
	localctx = NewText_inlineelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Creole10ParserRULE_text_inlineelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(375)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Text_first_inlineelement()
		}

	case Creole10ParserNOWIKI_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Nowiki_inline()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_first_inlineelementContext is an interface to support dynamic dispatch.
type IText_first_inlineelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_first_inlineelementContext differentiates from other interfaces.
	IsText_first_inlineelementContext()
}

type Text_first_inlineelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_first_inlineelementContext() *Text_first_inlineelementContext {
	var p = new(Text_first_inlineelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_first_inlineelement
	return p
}

func (*Text_first_inlineelementContext) IsText_first_inlineelementContext() {}

func NewText_first_inlineelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_first_inlineelementContext {
	var p = new(Text_first_inlineelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_first_inlineelement

	return p
}

func (s *Text_first_inlineelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_first_inlineelementContext) Link() ILinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkContext)
}

func (s *Text_first_inlineelementContext) Image() IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *Text_first_inlineelementContext) Extension() IExtensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionContext)
}

func (s *Text_first_inlineelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_first_inlineelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_first_inlineelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_first_inlineelement(s)
	}
}

func (s *Text_first_inlineelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_first_inlineelement(s)
	}
}

func (p *Creole10Parser) Text_first_inlineelement() (localctx IText_first_inlineelementContext) {
	localctx = NewText_first_inlineelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Creole10ParserRULE_text_first_inlineelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(380)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserLINK_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(377)
			p.Link()
		}

	case Creole10ParserIMAGE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(378)
			p.Image()
		}

	case Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(379)
			p.Extension()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_first_unformattedelementContext is an interface to support dynamic dispatch.
type IText_first_unformattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_first_unformattedelementContext differentiates from other interfaces.
	IsText_first_unformattedelementContext()
}

type Text_first_unformattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_first_unformattedelementContext() *Text_first_unformattedelementContext {
	var p = new(Text_first_unformattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_first_unformattedelement
	return p
}

func (*Text_first_unformattedelementContext) IsText_first_unformattedelementContext() {}

func NewText_first_unformattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_first_unformattedelementContext {
	var p = new(Text_first_unformattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_first_unformattedelement

	return p
}

func (s *Text_first_unformattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_first_unformattedelementContext) Text_first_unformatted() IText_first_unformattedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_unformattedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_unformattedContext)
}

func (s *Text_first_unformattedelementContext) Text_first_inlineelement() IText_first_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_first_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_first_inlineelementContext)
}

func (s *Text_first_unformattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_first_unformattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_first_unformattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_first_unformattedelement(s)
	}
}

func (s *Text_first_unformattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_first_unformattedelement(s)
	}
}

func (p *Creole10Parser) Text_first_unformattedelement() (localctx IText_first_unformattedelementContext) {
	localctx = NewText_first_unformattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Creole10ParserRULE_text_first_unformattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(384)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(382)
			p.Text_first_unformatted()
		}

	case Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(383)
			p.Text_first_inlineelement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_first_unformattedContext is an interface to support dynamic dispatch.
type IText_first_unformattedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_first_unformattedContext differentiates from other interfaces.
	IsText_first_unformattedContext()
}

type Text_first_unformattedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_first_unformattedContext() *Text_first_unformattedContext {
	var p = new(Text_first_unformattedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_first_unformatted
	return p
}

func (*Text_first_unformattedContext) IsText_first_unformattedContext() {}

func NewText_first_unformattedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_first_unformattedContext {
	var p = new(Text_first_unformattedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_first_unformatted

	return p
}

func (s *Text_first_unformattedContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_first_unformattedContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Text_first_unformattedContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Text_first_unformattedContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Text_first_unformattedContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Text_first_unformattedContext) AllPOUND() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPOUND)
}

func (s *Text_first_unformattedContext) POUND(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPOUND, i)
}

func (s *Text_first_unformattedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Text_first_unformattedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Text_first_unformattedContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEQUAL)
}

func (s *Text_first_unformattedContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, i)
}

func (s *Text_first_unformattedContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Text_first_unformattedContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Text_first_unformattedContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Text_first_unformattedContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Text_first_unformattedContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Text_first_unformattedContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Text_first_unformattedContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Text_first_unformattedContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Text_first_unformattedContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Text_first_unformattedContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Text_first_unformattedContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Text_first_unformattedContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Text_first_unformattedContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Text_first_unformattedContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Text_first_unformattedContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Text_first_unformattedContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Text_first_unformattedContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Text_first_unformattedContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Text_first_unformattedContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Text_first_unformattedContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Text_first_unformattedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_first_unformattedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_first_unformattedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_first_unformatted(s)
	}
}

func (s *Text_first_unformattedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_first_unformatted(s)
	}
}

func (p *Creole10Parser) Text_first_unformatted() (localctx IText_first_unformattedContext) {
	localctx = NewText_first_unformattedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Creole10ParserRULE_text_first_unformatted)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(389)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(386)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserEQUAL - -1))|(1<<(Creole10ParserPIPE - -1))|(1<<(Creole10ParserPOUND - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(387)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(388)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext())
	}

	return localctx
}

// IText_unformattedelementContext is an interface to support dynamic dispatch.
type IText_unformattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_unformattedelementContext differentiates from other interfaces.
	IsText_unformattedelementContext()
}

type Text_unformattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_unformattedelementContext() *Text_unformattedelementContext {
	var p = new(Text_unformattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_unformattedelement
	return p
}

func (*Text_unformattedelementContext) IsText_unformattedelementContext() {}

func NewText_unformattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_unformattedelementContext {
	var p = new(Text_unformattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_unformattedelement

	return p
}

func (s *Text_unformattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_unformattedelementContext) Text_unformatted() IText_unformattedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedContext)
}

func (s *Text_unformattedelementContext) Text_inlineelement() IText_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_inlineelementContext)
}

func (s *Text_unformattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_unformattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_unformattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_unformattedelement(s)
	}
}

func (s *Text_unformattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_unformattedelement(s)
	}
}

func (p *Creole10Parser) Text_unformattedelement() (localctx IText_unformattedelementContext) {
	localctx = NewText_unformattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Creole10ParserRULE_text_unformattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(395)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(393)
			p.Text_unformatted()
		}

	case Creole10ParserNOWIKI_OPEN, Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(394)
			p.Text_inlineelement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IText_unformattedContext is an interface to support dynamic dispatch.
type IText_unformattedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_unformattedContext differentiates from other interfaces.
	IsText_unformattedContext()
}

type Text_unformattedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_unformattedContext() *Text_unformattedContext {
	var p = new(Text_unformattedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_unformatted
	return p
}

func (*Text_unformattedContext) IsText_unformattedContext() {}

func NewText_unformattedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_unformattedContext {
	var p = new(Text_unformattedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_unformatted

	return p
}

func (s *Text_unformattedContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_unformattedContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Text_unformattedContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Text_unformattedContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Text_unformattedContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Text_unformattedContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Text_unformattedContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Text_unformattedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Text_unformattedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Text_unformattedContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Text_unformattedContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Text_unformattedContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Text_unformattedContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Text_unformattedContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Text_unformattedContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Text_unformattedContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Text_unformattedContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Text_unformattedContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Text_unformattedContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Text_unformattedContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Text_unformattedContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Text_unformattedContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Text_unformattedContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Text_unformattedContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Text_unformattedContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Text_unformattedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_unformattedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_unformattedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_unformatted(s)
	}
}

func (s *Text_unformattedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_unformatted(s)
	}
}

func (p *Creole10Parser) Text_unformatted() (localctx IText_unformattedContext) {
	localctx = NewText_unformattedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Creole10ParserRULE_text_unformatted)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(400)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(397)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(398)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(399)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// IHeadingContext is an interface to support dynamic dispatch.
type IHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeadingContext differentiates from other interfaces.
	IsHeadingContext()
}

type HeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeadingContext() *HeadingContext {
	var p = new(HeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_heading
	return p
}

func (*HeadingContext) IsHeadingContext() {}

func NewHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HeadingContext {
	var p = new(HeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_heading

	return p
}

func (s *HeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *HeadingContext) AllHeading_markup() []IHeading_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem())
	var tst = make([]IHeading_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHeading_markupContext)
		}
	}

	return tst
}

func (s *HeadingContext) Heading_markup(i int) IHeading_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHeading_markupContext)
}

func (s *HeadingContext) Heading_content() IHeading_contentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_contentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeading_contentContext)
}

func (s *HeadingContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *HeadingContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *HeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHeading(s)
	}
}

func (s *HeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHeading(s)
	}
}

func (p *Creole10Parser) Heading() (localctx IHeadingContext) {
	localctx = NewHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Creole10ParserRULE_heading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Heading_markup()
	}
	{
		p.SetState(405)
		p.Heading_content()
	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserEQUAL {
		{
			p.SetState(406)
			p.Heading_markup()
		}

	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserBLANKS {
		{
			p.SetState(409)
			p.Blanks()
		}

	}
	{
		p.SetState(412)
		p.Paragraph_separator()
	}

	return localctx
}

// IHeading_contentContext is an interface to support dynamic dispatch.
type IHeading_contentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeading_contentContext differentiates from other interfaces.
	IsHeading_contentContext()
}

type Heading_contentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeading_contentContext() *Heading_contentContext {
	var p = new(Heading_contentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_heading_content
	return p
}

func (*Heading_contentContext) IsHeading_contentContext() {}

func NewHeading_contentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Heading_contentContext {
	var p = new(Heading_contentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_heading_content

	return p
}

func (s *Heading_contentContext) GetParser() antlr.Parser { return s.parser }

func (s *Heading_contentContext) AllHeading_markup() []IHeading_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem())
	var tst = make([]IHeading_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHeading_markupContext)
		}
	}

	return tst
}

func (s *Heading_contentContext) Heading_markup(i int) IHeading_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHeading_markupContext)
}

func (s *Heading_contentContext) Heading_content() IHeading_contentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeading_contentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeading_contentContext)
}

func (s *Heading_contentContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Heading_contentContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Heading_contentContext) AllEQUAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEQUAL)
}

func (s *Heading_contentContext) EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, i)
}

func (s *Heading_contentContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Heading_contentContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Heading_contentContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Heading_contentContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Heading_contentContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Heading_contentContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Heading_contentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Heading_contentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Heading_contentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHeading_content(s)
	}
}

func (s *Heading_contentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHeading_content(s)
	}
}

func (p *Creole10Parser) Heading_content() (localctx IHeading_contentContext) {
	localctx = NewHeading_contentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Creole10ParserRULE_heading_content)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(425)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserEQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(414)
			p.Heading_markup()
		}
		{
			p.SetState(415)
			p.Heading_content()
		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(416)
				p.Heading_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(421)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(421)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
					p.SetState(419)
					_la = p.GetTokenStream().LA(1)

					if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserEQUAL - -1)))) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}

				case Creole10ParserESCAPE:
					{
						p.SetState(420)
						p.Escaped()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(423)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_ordContext is an interface to support dynamic dispatch.
type IList_ordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ordContext differentiates from other interfaces.
	IsList_ordContext()
}

type List_ordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ordContext() *List_ordContext {
	var p = new(List_ordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_ord
	return p
}

func (*List_ordContext) IsList_ordContext() {}

func NewList_ordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ordContext {
	var p = new(List_ordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_ord

	return p
}

func (s *List_ordContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ordContext) AllList_ordelem() []IList_ordelemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_ordelemContext)(nil)).Elem())
	var tst = make([]IList_ordelemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_ordelemContext)
		}
	}

	return tst
}

func (s *List_ordContext) List_ordelem(i int) IList_ordelemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordelemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_ordelemContext)
}

func (s *List_ordContext) End_of_list() IEnd_of_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnd_of_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnd_of_listContext)
}

func (s *List_ordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_ordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_ord(s)
	}
}

func (s *List_ordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_ord(s)
	}
}

func (p *Creole10Parser) List_ord() (localctx IList_ordContext) {
	localctx = NewList_ordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Creole10ParserRULE_list_ord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(427)
				p.List_ordelem()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}
	p.SetState(433)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(432)
			p.End_of_list()
		}

	}

	return localctx
}

// IList_ordelemContext is an interface to support dynamic dispatch.
type IList_ordelemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ordelemContext differentiates from other interfaces.
	IsList_ordelemContext()
}

type List_ordelemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ordelemContext() *List_ordelemContext {
	var p = new(List_ordelemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_ordelem
	return p
}

func (*List_ordelemContext) IsList_ordelemContext() {}

func NewList_ordelemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ordelemContext {
	var p = new(List_ordelemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_ordelem

	return p
}

func (s *List_ordelemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ordelemContext) List_ordelem_markup() IList_ordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ordelem_markupContext)
}

func (s *List_ordelemContext) List_elem() IList_elemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemContext)
}

func (s *List_ordelemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ordelemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_ordelemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_ordelem(s)
	}
}

func (s *List_ordelemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_ordelem(s)
	}
}

func (p *Creole10Parser) List_ordelem() (localctx IList_ordelemContext) {
	localctx = NewList_ordelemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Creole10ParserRULE_list_ordelem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		p.List_ordelem_markup()
	}
	{
		p.SetState(436)
		p.List_elem()
	}

	return localctx
}

// IList_unordContext is an interface to support dynamic dispatch.
type IList_unordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_unordContext differentiates from other interfaces.
	IsList_unordContext()
}

type List_unordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_unordContext() *List_unordContext {
	var p = new(List_unordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_unord
	return p
}

func (*List_unordContext) IsList_unordContext() {}

func NewList_unordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_unordContext {
	var p = new(List_unordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_unord

	return p
}

func (s *List_unordContext) GetParser() antlr.Parser { return s.parser }

func (s *List_unordContext) AllList_unordelem() []IList_unordelemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_unordelemContext)(nil)).Elem())
	var tst = make([]IList_unordelemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_unordelemContext)
		}
	}

	return tst
}

func (s *List_unordContext) List_unordelem(i int) IList_unordelemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordelemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_unordelemContext)
}

func (s *List_unordContext) End_of_list() IEnd_of_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnd_of_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnd_of_listContext)
}

func (s *List_unordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_unordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_unordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_unord(s)
	}
}

func (s *List_unordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_unord(s)
	}
}

func (p *Creole10Parser) List_unord() (localctx IList_unordContext) {
	localctx = NewList_unordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Creole10ParserRULE_list_unord)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(438)
				p.List_unordelem()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}
	p.SetState(444)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(443)
			p.End_of_list()
		}

	}

	return localctx
}

// IList_unordelemContext is an interface to support dynamic dispatch.
type IList_unordelemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_unordelemContext differentiates from other interfaces.
	IsList_unordelemContext()
}

type List_unordelemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_unordelemContext() *List_unordelemContext {
	var p = new(List_unordelemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_unordelem
	return p
}

func (*List_unordelemContext) IsList_unordelemContext() {}

func NewList_unordelemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_unordelemContext {
	var p = new(List_unordelemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_unordelem

	return p
}

func (s *List_unordelemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_unordelemContext) List_unordelem_markup() IList_unordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_unordelem_markupContext)
}

func (s *List_unordelemContext) List_elem() IList_elemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemContext)
}

func (s *List_unordelemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_unordelemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_unordelemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_unordelem(s)
	}
}

func (s *List_unordelemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_unordelem(s)
	}
}

func (p *Creole10Parser) List_unordelem() (localctx IList_unordelemContext) {
	localctx = NewList_unordelemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Creole10ParserRULE_list_unordelem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		p.List_unordelem_markup()
	}
	{
		p.SetState(447)
		p.List_elem()
	}

	return localctx
}

// IList_elemContext is an interface to support dynamic dispatch.
type IList_elemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemContext differentiates from other interfaces.
	IsList_elemContext()
}

type List_elemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemContext() *List_elemContext {
	var p = new(List_elemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elem
	return p
}

func (*List_elemContext) IsList_elemContext() {}

func NewList_elemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemContext {
	var p = new(List_elemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elem

	return p
}

func (s *List_elemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemContext) List_elemcontent() IList_elemcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemcontentContext)
}

func (s *List_elemContext) List_elemseparator() IList_elemseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_elemseparatorContext)
}

func (s *List_elemContext) AllList_elem_markup() []IList_elem_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_elem_markupContext)(nil)).Elem())
	var tst = make([]IList_elem_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_elem_markupContext)
		}
	}

	return tst
}

func (s *List_elemContext) List_elem_markup(i int) IList_elem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elem_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_elem_markupContext)
}

func (s *List_elemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elem(s)
	}
}

func (s *List_elemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elem(s)
	}
}

func (p *Creole10Parser) List_elem() (localctx IList_elemContext) {
	localctx = NewList_elemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Creole10ParserRULE_list_elem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(449)
				p.List_elem_markup()
			}

		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
	}
	{
		p.SetState(455)
		p.List_elemcontent()
	}
	{
		p.SetState(456)
		p.List_elemseparator()
	}

	return localctx
}

// IList_elem_markupContext is an interface to support dynamic dispatch.
type IList_elem_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elem_markupContext differentiates from other interfaces.
	IsList_elem_markupContext()
}

type List_elem_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elem_markupContext() *List_elem_markupContext {
	var p = new(List_elem_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elem_markup
	return p
}

func (*List_elem_markupContext) IsList_elem_markupContext() {}

func NewList_elem_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elem_markupContext {
	var p = new(List_elem_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elem_markup

	return p
}

func (s *List_elem_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elem_markupContext) List_ordelem_markup() IList_ordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_ordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_ordelem_markupContext)
}

func (s *List_elem_markupContext) List_unordelem_markup() IList_unordelem_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_unordelem_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_unordelem_markupContext)
}

func (s *List_elem_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elem_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elem_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elem_markup(s)
	}
}

func (s *List_elem_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elem_markup(s)
	}
}

func (p *Creole10Parser) List_elem_markup() (localctx IList_elem_markupContext) {
	localctx = NewList_elem_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Creole10ParserRULE_list_elem_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(460)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserPOUND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.List_ordelem_markup()
		}

	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.List_unordelem_markup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_elemcontentContext is an interface to support dynamic dispatch.
type IList_elemcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemcontentContext differentiates from other interfaces.
	IsList_elemcontentContext()
}

type List_elemcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemcontentContext() *List_elemcontentContext {
	var p = new(List_elemcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elemcontent
	return p
}

func (*List_elemcontentContext) IsList_elemcontentContext() {}

func NewList_elemcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemcontentContext {
	var p = new(List_elemcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elemcontent

	return p
}

func (s *List_elemcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemcontentContext) AllList_elemcontentpart() []IList_elemcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_elemcontentpartContext)(nil)).Elem())
	var tst = make([]IList_elemcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_elemcontentpartContext)
		}
	}

	return tst
}

func (s *List_elemcontentContext) List_elemcontentpart(i int) IList_elemcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_elemcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_elemcontentpartContext)
}

func (s *List_elemcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elemcontent(s)
	}
}

func (s *List_elemcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elemcontent(s)
	}
}

func (p *Creole10Parser) List_elemcontent() (localctx IList_elemcontentContext) {
	localctx = NewList_elemcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Creole10ParserRULE_list_elemcontent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		{
			p.SetState(462)
			p.List_elemcontentpart()
		}

		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IList_elemcontentpartContext is an interface to support dynamic dispatch.
type IList_elemcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemcontentpartContext differentiates from other interfaces.
	IsList_elemcontentpartContext()
}

type List_elemcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemcontentpartContext() *List_elemcontentpartContext {
	var p = new(List_elemcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elemcontentpart
	return p
}

func (*List_elemcontentpartContext) IsList_elemcontentpartContext() {}

func NewList_elemcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemcontentpartContext {
	var p = new(List_elemcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elemcontentpart

	return p
}

func (s *List_elemcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemcontentpartContext) Text_unformattedelement() IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_elemcontentpartContext) Onestar() IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *List_elemcontentpartContext) List_formatted_elem() IList_formatted_elemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_formatted_elemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_formatted_elemContext)
}

func (s *List_elemcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elemcontentpart(s)
	}
}

func (s *List_elemcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elemcontentpart(s)
	}
}

func (p *Creole10Parser) List_elemcontentpart() (localctx IList_elemcontentpartContext) {
	localctx = NewList_elemcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Creole10ParserRULE_list_elemcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(472)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.Text_unformattedelement()
		}
		{
			p.SetState(469)
			p.Onestar()
		}

	case Creole10ParserITAL, Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(471)
			p.List_formatted_elem()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_formatted_elemContext is an interface to support dynamic dispatch.
type IList_formatted_elemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_formatted_elemContext differentiates from other interfaces.
	IsList_formatted_elemContext()
}

type List_formatted_elemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_formatted_elemContext() *List_formatted_elemContext {
	var p = new(List_formatted_elemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_formatted_elem
	return p
}

func (*List_formatted_elemContext) IsList_formatted_elemContext() {}

func NewList_formatted_elemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_formatted_elemContext {
	var p = new(List_formatted_elemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_formatted_elem

	return p
}

func (s *List_formatted_elemContext) GetParser() antlr.Parser { return s.parser }

func (s *List_formatted_elemContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *List_formatted_elemContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *List_formatted_elemContext) AllList_boldcontentpart() []IList_boldcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_boldcontentpartContext)(nil)).Elem())
	var tst = make([]IList_boldcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_boldcontentpartContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) List_boldcontentpart(i int) IList_boldcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_boldcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_boldcontentpartContext)
}

func (s *List_formatted_elemContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *List_formatted_elemContext) AllList_italcontentpart() []IList_italcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IList_italcontentpartContext)(nil)).Elem())
	var tst = make([]IList_italcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IList_italcontentpartContext)
		}
	}

	return tst
}

func (s *List_formatted_elemContext) List_italcontentpart(i int) IList_italcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_italcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IList_italcontentpartContext)
}

func (s *List_formatted_elemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_formatted_elemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_formatted_elemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_formatted_elem(s)
	}
}

func (s *List_formatted_elemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_formatted_elem(s)
	}
}

func (p *Creole10Parser) List_formatted_elem() (localctx IList_formatted_elemContext) {
	localctx = NewList_formatted_elemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Creole10ParserRULE_list_formatted_elem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(498)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.Bold_markup()
		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(475)
					p.Onestar()
				}
				{
					p.SetState(476)
					p.List_boldcontentpart()
				}

			}
			p.SetState(482)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
		}
		p.SetState(484)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(483)
				p.Bold_markup()
			}

		}

	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(486)
			p.Ital_markup()
		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(487)
					p.Onestar()
				}
				{
					p.SetState(488)
					p.List_italcontentpart()
				}

			}
			p.SetState(494)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext())
		}
		p.SetState(496)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(495)
				p.Ital_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOnestarContext is an interface to support dynamic dispatch.
type IOnestarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnestarContext differentiates from other interfaces.
	IsOnestarContext()
}

type OnestarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnestarContext() *OnestarContext {
	var p = new(OnestarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_onestar
	return p
}

func (*OnestarContext) IsOnestarContext() {}

func NewOnestarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnestarContext {
	var p = new(OnestarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_onestar

	return p
}

func (s *OnestarContext) GetParser() antlr.Parser { return s.parser }

func (s *OnestarContext) STAR() antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, 0)
}

func (s *OnestarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnestarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnestarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterOnestar(s)
	}
}

func (s *OnestarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitOnestar(s)
	}
}

func (p *Creole10Parser) Onestar() (localctx IOnestarContext) {
	localctx = NewOnestarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Creole10ParserRULE_onestar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(500)

		if !(p.GetInputStream().LA(2) != Creole10ParserSTAR) {
			panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(2)!=Creole10ParserSTAR", ""))
		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(501)
				p.Match(Creole10ParserSTAR)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IList_boldcontentpartContext is an interface to support dynamic dispatch.
type IList_boldcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_boldcontentpartContext differentiates from other interfaces.
	IsList_boldcontentpartContext()
}

type List_boldcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_boldcontentpartContext() *List_boldcontentpartContext {
	var p = new(List_boldcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_boldcontentpart
	return p
}

func (*List_boldcontentpartContext) IsList_boldcontentpartContext() {}

func NewList_boldcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_boldcontentpartContext {
	var p = new(List_boldcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_boldcontentpart

	return p
}

func (s *List_boldcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *List_boldcontentpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *List_boldcontentpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *List_boldcontentpartContext) List_bolditalcontent() IList_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_bolditalcontentContext)
}

func (s *List_boldcontentpartContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *List_boldcontentpartContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_boldcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_boldcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_boldcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_boldcontentpart(s)
	}
}

func (s *List_boldcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_boldcontentpart(s)
	}
}

func (p *Creole10Parser) List_boldcontentpart() (localctx IList_boldcontentpartContext) {
	localctx = NewList_boldcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Creole10ParserRULE_list_boldcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(517)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(507)
			p.Ital_markup()
		}
		{
			p.SetState(508)
			p.List_bolditalcontent()
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(509)
				p.Ital_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(512)
					p.Text_unformattedelement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(515)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_italcontentpartContext is an interface to support dynamic dispatch.
type IList_italcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_italcontentpartContext differentiates from other interfaces.
	IsList_italcontentpartContext()
}

type List_italcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_italcontentpartContext() *List_italcontentpartContext {
	var p = new(List_italcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_italcontentpart
	return p
}

func (*List_italcontentpartContext) IsList_italcontentpartContext() {}

func NewList_italcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_italcontentpartContext {
	var p = new(List_italcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_italcontentpart

	return p
}

func (s *List_italcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *List_italcontentpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *List_italcontentpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *List_italcontentpartContext) List_bolditalcontent() IList_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IList_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IList_bolditalcontentContext)
}

func (s *List_italcontentpartContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *List_italcontentpartContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_italcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_italcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_italcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_italcontentpart(s)
	}
}

func (s *List_italcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_italcontentpart(s)
	}
}

func (p *Creole10Parser) List_italcontentpart() (localctx IList_italcontentpartContext) {
	localctx = NewList_italcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Creole10ParserRULE_list_italcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(529)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.Bold_markup()
		}
		{
			p.SetState(520)
			p.List_bolditalcontent()
		}
		p.SetState(522)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(521)
				p.Bold_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(524)
					p.Text_unformattedelement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(527)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IList_bolditalcontentContext is an interface to support dynamic dispatch.
type IList_bolditalcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_bolditalcontentContext differentiates from other interfaces.
	IsList_bolditalcontentContext()
}

type List_bolditalcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_bolditalcontentContext() *List_bolditalcontentContext {
	var p = new(List_bolditalcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_bolditalcontent
	return p
}

func (*List_bolditalcontentContext) IsList_bolditalcontentContext() {}

func NewList_bolditalcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_bolditalcontentContext {
	var p = new(List_bolditalcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_bolditalcontent

	return p
}

func (s *List_bolditalcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *List_bolditalcontentContext) AllText_unformattedelement() []IText_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem())
	var tst = make([]IText_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IText_unformattedelementContext)
		}
	}

	return tst
}

func (s *List_bolditalcontentContext) Text_unformattedelement(i int) IText_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IText_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IText_unformattedelementContext)
}

func (s *List_bolditalcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_bolditalcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_bolditalcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_bolditalcontent(s)
	}
}

func (s *List_bolditalcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_bolditalcontent(s)
	}
}

func (p *Creole10Parser) List_bolditalcontent() (localctx IList_bolditalcontentContext) {
	localctx = NewList_bolditalcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Creole10ParserRULE_list_bolditalcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(532)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(531)
				p.Text_unformattedelement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(534)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}

	return localctx
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table
	return p
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) AllTable_row() []ITable_rowContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_rowContext)(nil)).Elem())
	var tst = make([]ITable_rowContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_rowContext)
		}
	}

	return tst
}

func (s *TableContext) Table_row(i int) ITable_rowContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_rowContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_rowContext)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *Creole10Parser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Creole10ParserRULE_table)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(536)
				p.Table_row()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// ITable_rowContext is an interface to support dynamic dispatch.
type ITable_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_rowContext differentiates from other interfaces.
	IsTable_rowContext()
}

type Table_rowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowContext() *Table_rowContext {
	var p = new(Table_rowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_row
	return p
}

func (*Table_rowContext) IsTable_rowContext() {}

func NewTable_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowContext {
	var p = new(Table_rowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_row

	return p
}

func (s *Table_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowContext) Table_rowseparator() ITable_rowseparatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_rowseparatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_rowseparatorContext)
}

func (s *Table_rowContext) AllTable_cell() []ITable_cellContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_cellContext)(nil)).Elem())
	var tst = make([]ITable_cellContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_cellContext)
		}
	}

	return tst
}

func (s *Table_rowContext) Table_cell(i int) ITable_cellContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_cellContext)
}

func (s *Table_rowContext) Table_cell_markup() ITable_cell_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cell_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cell_markupContext)
}

func (s *Table_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_row(s)
	}
}

func (s *Table_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_row(s)
	}
}

func (p *Creole10Parser) Table_row() (localctx ITable_rowContext) {
	localctx = NewTable_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Creole10ParserRULE_table_row)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(541)
				p.Table_cell()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserPIPE {
		{
			p.SetState(546)
			p.Table_cell_markup()
		}

	}
	{
		p.SetState(549)
		p.Table_rowseparator()
	}

	return localctx
}

// ITable_cellContext is an interface to support dynamic dispatch.
type ITable_cellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cellContext differentiates from other interfaces.
	IsTable_cellContext()
}

type Table_cellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cellContext() *Table_cellContext {
	var p = new(Table_cellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cell
	return p
}

func (*Table_cellContext) IsTable_cellContext() {}

func NewTable_cellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cellContext {
	var p = new(Table_cellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cell

	return p
}

func (s *Table_cellContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cellContext) Table_headercell() ITable_headercellContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_headercellContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_headercellContext)
}

func (s *Table_cellContext) Table_normalcell() ITable_normalcellContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_normalcellContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_normalcellContext)
}

func (s *Table_cellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cell(s)
	}
}

func (s *Table_cellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cell(s)
	}
}

func (p *Creole10Parser) Table_cell() (localctx ITable_cellContext) {
	localctx = NewTable_cellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Creole10ParserRULE_table_cell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(551)

		if !(p.GetInputStream().LA(2) == Creole10ParserEQUAL) {
			panic(antlr.NewFailedPredicateException(p, "p.GetInputStream().LA(2)==Creole10ParserEQUAL", ""))
		}
		{
			p.SetState(552)
			p.Table_headercell()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(553)
			p.Table_normalcell()
		}

	}

	return localctx
}

// ITable_headercellContext is an interface to support dynamic dispatch.
type ITable_headercellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_headercellContext differentiates from other interfaces.
	IsTable_headercellContext()
}

type Table_headercellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_headercellContext() *Table_headercellContext {
	var p = new(Table_headercellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_headercell
	return p
}

func (*Table_headercellContext) IsTable_headercellContext() {}

func NewTable_headercellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_headercellContext {
	var p = new(Table_headercellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_headercell

	return p
}

func (s *Table_headercellContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_headercellContext) Table_headercell_markup() ITable_headercell_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_headercell_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_headercell_markupContext)
}

func (s *Table_headercellContext) Table_cellcontent() ITable_cellcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cellcontentContext)
}

func (s *Table_headercellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_headercellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_headercellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_headercell(s)
	}
}

func (s *Table_headercellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_headercell(s)
	}
}

func (p *Creole10Parser) Table_headercell() (localctx ITable_headercellContext) {
	localctx = NewTable_headercellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Creole10ParserRULE_table_headercell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Table_headercell_markup()
	}
	{
		p.SetState(557)
		p.Table_cellcontent()
	}

	return localctx
}

// ITable_normalcellContext is an interface to support dynamic dispatch.
type ITable_normalcellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_normalcellContext differentiates from other interfaces.
	IsTable_normalcellContext()
}

type Table_normalcellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_normalcellContext() *Table_normalcellContext {
	var p = new(Table_normalcellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_normalcell
	return p
}

func (*Table_normalcellContext) IsTable_normalcellContext() {}

func NewTable_normalcellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_normalcellContext {
	var p = new(Table_normalcellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_normalcell

	return p
}

func (s *Table_normalcellContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_normalcellContext) Table_cell_markup() ITable_cell_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cell_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cell_markupContext)
}

func (s *Table_normalcellContext) Table_cellcontent() ITable_cellcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_cellcontentContext)
}

func (s *Table_normalcellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_normalcellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_normalcellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_normalcell(s)
	}
}

func (s *Table_normalcellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_normalcell(s)
	}
}

func (p *Creole10Parser) Table_normalcell() (localctx ITable_normalcellContext) {
	localctx = NewTable_normalcellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Creole10ParserRULE_table_normalcell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Table_cell_markup()
	}
	{
		p.SetState(560)
		p.Table_cellcontent()
	}

	return localctx
}

// ITable_cellcontentContext is an interface to support dynamic dispatch.
type ITable_cellcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cellcontentContext differentiates from other interfaces.
	IsTable_cellcontentContext()
}

type Table_cellcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cellcontentContext() *Table_cellcontentContext {
	var p = new(Table_cellcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cellcontent
	return p
}

func (*Table_cellcontentContext) IsTable_cellcontentContext() {}

func NewTable_cellcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cellcontentContext {
	var p = new(Table_cellcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cellcontent

	return p
}

func (s *Table_cellcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cellcontentContext) AllTable_cellcontentpart() []ITable_cellcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_cellcontentpartContext)(nil)).Elem())
	var tst = make([]ITable_cellcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_cellcontentpartContext)
		}
	}

	return tst
}

func (s *Table_cellcontentContext) Table_cellcontentpart(i int) ITable_cellcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_cellcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_cellcontentpartContext)
}

func (s *Table_cellcontentContext) STAR() antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, 0)
}

func (s *Table_cellcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cellcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cellcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cellcontent(s)
	}
}

func (s *Table_cellcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cellcontent(s)
	}
}

func (p *Creole10Parser) Table_cellcontent() (localctx ITable_cellcontentContext) {
	localctx = NewTable_cellcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Creole10ParserRULE_table_cellcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(562)
				p.Table_cellcontentpart()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(567)
			p.Match(Creole10ParserSTAR)
		}

	}

	return localctx
}

// ITable_cellcontentpartContext is an interface to support dynamic dispatch.
type ITable_cellcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cellcontentpartContext differentiates from other interfaces.
	IsTable_cellcontentpartContext()
}

type Table_cellcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cellcontentpartContext() *Table_cellcontentpartContext {
	var p = new(Table_cellcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cellcontentpart
	return p
}

func (*Table_cellcontentpartContext) IsTable_cellcontentpartContext() {}

func NewTable_cellcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cellcontentpartContext {
	var p = new(Table_cellcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cellcontentpart

	return p
}

func (s *Table_cellcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cellcontentpartContext) Table_formattedelement() ITable_formattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedelementContext)
}

func (s *Table_cellcontentpartContext) Onestar() IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Table_cellcontentpartContext) Table_unformattedelement() ITable_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_unformattedelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_unformattedelementContext)
}

func (s *Table_cellcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cellcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cellcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cellcontentpart(s)
	}
}

func (s *Table_cellcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cellcontentpart(s)
	}
}

func (p *Creole10Parser) Table_cellcontentpart() (localctx ITable_cellcontentpartContext) {
	localctx = NewTable_cellcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Creole10ParserRULE_table_cellcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(574)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(570)
			p.Table_formattedelement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(571)
			p.Onestar()
		}
		{
			p.SetState(572)
			p.Table_unformattedelement()
		}

	}

	return localctx
}

// ITable_formattedelementContext is an interface to support dynamic dispatch.
type ITable_formattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_formattedelementContext differentiates from other interfaces.
	IsTable_formattedelementContext()
}

type Table_formattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_formattedelementContext() *Table_formattedelementContext {
	var p = new(Table_formattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_formattedelement
	return p
}

func (*Table_formattedelementContext) IsTable_formattedelementContext() {}

func NewTable_formattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_formattedelementContext {
	var p = new(Table_formattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_formattedelement

	return p
}

func (s *Table_formattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_formattedelementContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Table_formattedelementContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Table_formattedelementContext) Table_italcontent() ITable_italcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_italcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_italcontentContext)
}

func (s *Table_formattedelementContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Table_formattedelementContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Table_formattedelementContext) Table_boldcontent() ITable_boldcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_boldcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_boldcontentContext)
}

func (s *Table_formattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_formattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_formattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_formattedelement(s)
	}
}

func (s *Table_formattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_formattedelement(s)
	}
}

func (p *Creole10Parser) Table_formattedelement() (localctx ITable_formattedelementContext) {
	localctx = NewTable_formattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Creole10ParserRULE_table_formattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(576)
			p.Ital_markup()
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(577)
				p.Table_italcontent()
			}

		}
		p.SetState(581)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(580)
				p.Ital_markup()
			}

		}

	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(583)
			p.Bold_markup()
		}
		p.SetState(585)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(584)
				p.Table_boldcontent()
			}

		}
		p.SetState(588)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(587)
				p.Bold_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_boldcontentContext is an interface to support dynamic dispatch.
type ITable_boldcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_boldcontentContext differentiates from other interfaces.
	IsTable_boldcontentContext()
}

type Table_boldcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_boldcontentContext() *Table_boldcontentContext {
	var p = new(Table_boldcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_boldcontent
	return p
}

func (*Table_boldcontentContext) IsTable_boldcontentContext() {}

func NewTable_boldcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_boldcontentContext {
	var p = new(Table_boldcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_boldcontent

	return p
}

func (s *Table_boldcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_boldcontentContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Table_boldcontentContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Table_boldcontentContext) AllTable_boldcontentpart() []ITable_boldcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_boldcontentpartContext)(nil)).Elem())
	var tst = make([]ITable_boldcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_boldcontentpartContext)
		}
	}

	return tst
}

func (s *Table_boldcontentContext) Table_boldcontentpart(i int) ITable_boldcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_boldcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_boldcontentpartContext)
}

func (s *Table_boldcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_boldcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_boldcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_boldcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_boldcontent(s)
	}
}

func (s *Table_boldcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_boldcontent(s)
	}
}

func (p *Creole10Parser) Table_boldcontent() (localctx ITable_boldcontentContext) {
	localctx = NewTable_boldcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Creole10ParserRULE_table_boldcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(592)
					p.Onestar()
				}
				{
					p.SetState(593)
					p.Table_boldcontentpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(597)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(599)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// ITable_italcontentContext is an interface to support dynamic dispatch.
type ITable_italcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_italcontentContext differentiates from other interfaces.
	IsTable_italcontentContext()
}

type Table_italcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_italcontentContext() *Table_italcontentContext {
	var p = new(Table_italcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_italcontent
	return p
}

func (*Table_italcontentContext) IsTable_italcontentContext() {}

func NewTable_italcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_italcontentContext {
	var p = new(Table_italcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_italcontent

	return p
}

func (s *Table_italcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_italcontentContext) AllTable_italcontentpart() []ITable_italcontentpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_italcontentpartContext)(nil)).Elem())
	var tst = make([]ITable_italcontentpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_italcontentpartContext)
		}
	}

	return tst
}

func (s *Table_italcontentContext) Table_italcontentpart(i int) ITable_italcontentpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_italcontentpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_italcontentpartContext)
}

func (s *Table_italcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_italcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_italcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_italcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_italcontent(s)
	}
}

func (s *Table_italcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_italcontent(s)
	}
}

func (p *Creole10Parser) Table_italcontent() (localctx ITable_italcontentContext) {
	localctx = NewTable_italcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Creole10ParserRULE_table_italcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(608)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(602)
					p.Table_italcontentpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(605)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext())
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(607)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_boldcontentpartContext is an interface to support dynamic dispatch.
type ITable_boldcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_boldcontentpartContext differentiates from other interfaces.
	IsTable_boldcontentpartContext()
}

type Table_boldcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_boldcontentpartContext() *Table_boldcontentpartContext {
	var p = new(Table_boldcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_boldcontentpart
	return p
}

func (*Table_boldcontentpartContext) IsTable_boldcontentpartContext() {}

func NewTable_boldcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_boldcontentpartContext {
	var p = new(Table_boldcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_boldcontentpart

	return p
}

func (s *Table_boldcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_boldcontentpartContext) Table_formattedcontent() ITable_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedcontentContext)
}

func (s *Table_boldcontentpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Table_boldcontentpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Table_boldcontentpartContext) Table_bolditalcontent() ITable_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_bolditalcontentContext)
}

func (s *Table_boldcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_boldcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_boldcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_boldcontentpart(s)
	}
}

func (s *Table_boldcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_boldcontentpart(s)
	}
}

func (p *Creole10Parser) Table_boldcontentpart() (localctx ITable_boldcontentpartContext) {
	localctx = NewTable_boldcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Creole10ParserRULE_table_boldcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(616)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.Table_formattedcontent()
		}

	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Ital_markup()
		}
		{
			p.SetState(612)
			p.Table_bolditalcontent()
		}
		p.SetState(614)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(613)
				p.Ital_markup()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_italcontentpartContext is an interface to support dynamic dispatch.
type ITable_italcontentpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_italcontentpartContext differentiates from other interfaces.
	IsTable_italcontentpartContext()
}

type Table_italcontentpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_italcontentpartContext() *Table_italcontentpartContext {
	var p = new(Table_italcontentpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_italcontentpart
	return p
}

func (*Table_italcontentpartContext) IsTable_italcontentpartContext() {}

func NewTable_italcontentpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_italcontentpartContext {
	var p = new(Table_italcontentpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_italcontentpart

	return p
}

func (s *Table_italcontentpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_italcontentpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Table_italcontentpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Table_italcontentpartContext) Table_bolditalcontent() ITable_bolditalcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_bolditalcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_bolditalcontentContext)
}

func (s *Table_italcontentpartContext) Table_formattedcontent() ITable_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedcontentContext)
}

func (s *Table_italcontentpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_italcontentpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_italcontentpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_italcontentpart(s)
	}
}

func (s *Table_italcontentpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_italcontentpart(s)
	}
}

func (p *Creole10Parser) Table_italcontentpart() (localctx ITable_italcontentpartContext) {
	localctx = NewTable_italcontentpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Creole10ParserRULE_table_italcontentpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(624)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(618)
			p.Bold_markup()
		}
		{
			p.SetState(619)
			p.Table_bolditalcontent()
		}
		p.SetState(621)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(620)
				p.Bold_markup()
			}

		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserEXTENSION, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(623)
			p.Table_formattedcontent()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_bolditalcontentContext is an interface to support dynamic dispatch.
type ITable_bolditalcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_bolditalcontentContext differentiates from other interfaces.
	IsTable_bolditalcontentContext()
}

type Table_bolditalcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_bolditalcontentContext() *Table_bolditalcontentContext {
	var p = new(Table_bolditalcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_bolditalcontent
	return p
}

func (*Table_bolditalcontentContext) IsTable_bolditalcontentContext() {}

func NewTable_bolditalcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_bolditalcontentContext {
	var p = new(Table_bolditalcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_bolditalcontent

	return p
}

func (s *Table_bolditalcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_bolditalcontentContext) Table_formattedcontent() ITable_formattedcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_formattedcontentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_formattedcontentContext)
}

func (s *Table_bolditalcontentContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_bolditalcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_bolditalcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_bolditalcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_bolditalcontent(s)
	}
}

func (s *Table_bolditalcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_bolditalcontent(s)
	}
}

func (p *Creole10Parser) Table_bolditalcontent() (localctx ITable_bolditalcontentContext) {
	localctx = NewTable_bolditalcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Creole10ParserRULE_table_bolditalcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(630)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(627)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(626)
				p.Table_formattedcontent()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(629)
			p.Match(Creole10ParserEOF)
		}

	}

	return localctx
}

// ITable_formattedcontentContext is an interface to support dynamic dispatch.
type ITable_formattedcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_formattedcontentContext differentiates from other interfaces.
	IsTable_formattedcontentContext()
}

type Table_formattedcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_formattedcontentContext() *Table_formattedcontentContext {
	var p = new(Table_formattedcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_formattedcontent
	return p
}

func (*Table_formattedcontentContext) IsTable_formattedcontentContext() {}

func NewTable_formattedcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_formattedcontentContext {
	var p = new(Table_formattedcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_formattedcontent

	return p
}

func (s *Table_formattedcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_formattedcontentContext) AllTable_unformattedelement() []ITable_unformattedelementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITable_unformattedelementContext)(nil)).Elem())
	var tst = make([]ITable_unformattedelementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITable_unformattedelementContext)
		}
	}

	return tst
}

func (s *Table_formattedcontentContext) Table_unformattedelement(i int) ITable_unformattedelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_unformattedelementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITable_unformattedelementContext)
}

func (s *Table_formattedcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_formattedcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_formattedcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_formattedcontent(s)
	}
}

func (s *Table_formattedcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_formattedcontent(s)
	}
}

func (p *Creole10Parser) Table_formattedcontent() (localctx ITable_formattedcontentContext) {
	localctx = NewTable_formattedcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Creole10ParserRULE_table_formattedcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(632)
				p.Table_unformattedelement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(635)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// ITable_inlineelementContext is an interface to support dynamic dispatch.
type ITable_inlineelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_inlineelementContext differentiates from other interfaces.
	IsTable_inlineelementContext()
}

type Table_inlineelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_inlineelementContext() *Table_inlineelementContext {
	var p = new(Table_inlineelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_inlineelement
	return p
}

func (*Table_inlineelementContext) IsTable_inlineelementContext() {}

func NewTable_inlineelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_inlineelementContext {
	var p = new(Table_inlineelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_inlineelement

	return p
}

func (s *Table_inlineelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_inlineelementContext) Link() ILinkContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILinkContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILinkContext)
}

func (s *Table_inlineelementContext) Image() IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *Table_inlineelementContext) Extension() IExtensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionContext)
}

func (s *Table_inlineelementContext) Nowiki_inline() INowiki_inlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_inlineContext)
}

func (s *Table_inlineelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_inlineelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_inlineelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_inlineelement(s)
	}
}

func (s *Table_inlineelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_inlineelement(s)
	}
}

func (p *Creole10Parser) Table_inlineelement() (localctx ITable_inlineelementContext) {
	localctx = NewTable_inlineelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Creole10ParserRULE_table_inlineelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(641)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserLINK_OPEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.Link()
		}

	case Creole10ParserIMAGE_OPEN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)
			p.Image()
		}

	case Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(639)
			p.Extension()
		}

	case Creole10ParserNOWIKI_OPEN:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(640)
			p.Nowiki_inline()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_unformattedelementContext is an interface to support dynamic dispatch.
type ITable_unformattedelementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_unformattedelementContext differentiates from other interfaces.
	IsTable_unformattedelementContext()
}

type Table_unformattedelementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_unformattedelementContext() *Table_unformattedelementContext {
	var p = new(Table_unformattedelementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_unformattedelement
	return p
}

func (*Table_unformattedelementContext) IsTable_unformattedelementContext() {}

func NewTable_unformattedelementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_unformattedelementContext {
	var p = new(Table_unformattedelementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_unformattedelement

	return p
}

func (s *Table_unformattedelementContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_unformattedelementContext) Table_unformatted() ITable_unformattedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_unformattedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_unformattedContext)
}

func (s *Table_unformattedelementContext) Table_inlineelement() ITable_inlineelementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITable_inlineelementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITable_inlineelementContext)
}

func (s *Table_unformattedelementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_unformattedelementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_unformattedelementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_unformattedelement(s)
	}
}

func (s *Table_unformattedelementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_unformattedelement(s)
	}
}

func (p *Creole10Parser) Table_unformattedelement() (localctx ITable_unformattedelementContext) {
	localctx = NewTable_unformattedelementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Creole10ParserRULE_table_unformattedelement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(645)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(643)
			p.Table_unformatted()
		}

	case Creole10ParserNOWIKI_OPEN, Creole10ParserLINK_OPEN, Creole10ParserIMAGE_OPEN, Creole10ParserEXTENSION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(644)
			p.Table_inlineelement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_unformattedContext is an interface to support dynamic dispatch.
type ITable_unformattedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_unformattedContext differentiates from other interfaces.
	IsTable_unformattedContext()
}

type Table_unformattedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_unformattedContext() *Table_unformattedContext {
	var p = new(Table_unformattedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_unformatted
	return p
}

func (*Table_unformattedContext) IsTable_unformattedContext() {}

func NewTable_unformattedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_unformattedContext {
	var p = new(Table_unformattedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_unformatted

	return p
}

func (s *Table_unformattedContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_unformattedContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Table_unformattedContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Table_unformattedContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Table_unformattedContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Table_unformattedContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Table_unformattedContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Table_unformattedContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Table_unformattedContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Table_unformattedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Table_unformattedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Table_unformattedContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Table_unformattedContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Table_unformattedContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Table_unformattedContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Table_unformattedContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Table_unformattedContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Table_unformattedContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Table_unformattedContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Table_unformattedContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Table_unformattedContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Table_unformattedContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Table_unformattedContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Table_unformattedContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Table_unformattedContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Table_unformattedContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Table_unformattedContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Table_unformattedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_unformattedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_unformattedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_unformatted(s)
	}
}

func (s *Table_unformattedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_unformatted(s)
	}
}

func (p *Creole10Parser) Table_unformatted() (localctx ITable_unformattedContext) {
	localctx = NewTable_unformattedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Creole10ParserRULE_table_unformatted)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(650)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserEQUAL, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(647)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserPIPE - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(648)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(649)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// INowiki_blockContext is an interface to support dynamic dispatch.
type INowiki_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_blockContext differentiates from other interfaces.
	IsNowiki_blockContext()
}

type Nowiki_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_blockContext() *Nowiki_blockContext {
	var p = new(Nowiki_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_block
	return p
}

func (*Nowiki_blockContext) IsNowiki_blockContext() {}

func NewNowiki_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_blockContext {
	var p = new(Nowiki_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_block

	return p
}

func (s *Nowiki_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_blockContext) Nowikiblock_open_markup() INowikiblock_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowikiblock_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowikiblock_open_markupContext)
}

func (s *Nowiki_blockContext) Nowikiblock_close_markup() INowikiblock_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowikiblock_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowikiblock_close_markupContext)
}

func (s *Nowiki_blockContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *Nowiki_blockContext) AllNOWIKI_BLOCK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_BLOCK_CLOSE)
}

func (s *Nowiki_blockContext) NOWIKI_BLOCK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_BLOCK_CLOSE, i)
}

func (s *Nowiki_blockContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Nowiki_blockContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Nowiki_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_block(s)
	}
}

func (s *Nowiki_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_block(s)
	}
}

func (p *Creole10Parser) Nowiki_block() (localctx INowiki_blockContext) {
	localctx = NewNowiki_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Creole10ParserRULE_nowiki_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)
		p.Nowikiblock_open_markup()
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNEWLINE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		p.SetState(655)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == Creole10ParserEOF || _la == Creole10ParserNOWIKI_BLOCK_CLOSE {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(661)
		p.Nowikiblock_close_markup()
	}
	{
		p.SetState(662)
		p.Paragraph_separator()
	}

	return localctx
}

// INowikiblock_open_markupContext is an interface to support dynamic dispatch.
type INowikiblock_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowikiblock_open_markupContext differentiates from other interfaces.
	IsNowikiblock_open_markupContext()
}

type Nowikiblock_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowikiblock_open_markupContext() *Nowikiblock_open_markupContext {
	var p = new(Nowikiblock_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowikiblock_open_markup
	return p
}

func (*Nowikiblock_open_markupContext) IsNowikiblock_open_markupContext() {}

func NewNowikiblock_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowikiblock_open_markupContext {
	var p = new(Nowikiblock_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowikiblock_open_markup

	return p
}

func (s *Nowikiblock_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowikiblock_open_markupContext) Nowiki_open_markup() INowiki_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_open_markupContext)
}

func (s *Nowikiblock_open_markupContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Nowikiblock_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowikiblock_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowikiblock_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowikiblock_open_markup(s)
	}
}

func (s *Nowikiblock_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowikiblock_open_markup(s)
	}
}

func (p *Creole10Parser) Nowikiblock_open_markup() (localctx INowikiblock_open_markupContext) {
	localctx = NewNowikiblock_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Creole10ParserRULE_nowikiblock_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Nowiki_open_markup()
	}
	{
		p.SetState(665)
		p.Newline()
	}

	return localctx
}

// INowikiblock_close_markupContext is an interface to support dynamic dispatch.
type INowikiblock_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowikiblock_close_markupContext differentiates from other interfaces.
	IsNowikiblock_close_markupContext()
}

type Nowikiblock_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowikiblock_close_markupContext() *Nowikiblock_close_markupContext {
	var p = new(Nowikiblock_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowikiblock_close_markup
	return p
}

func (*Nowikiblock_close_markupContext) IsNowikiblock_close_markupContext() {}

func NewNowikiblock_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowikiblock_close_markupContext {
	var p = new(Nowikiblock_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowikiblock_close_markup

	return p
}

func (s *Nowikiblock_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowikiblock_close_markupContext) NOWIKI_BLOCK_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_BLOCK_CLOSE, 0)
}

func (s *Nowikiblock_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowikiblock_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowikiblock_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowikiblock_close_markup(s)
	}
}

func (s *Nowikiblock_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowikiblock_close_markup(s)
	}
}

func (p *Creole10Parser) Nowikiblock_close_markup() (localctx INowikiblock_close_markupContext) {
	localctx = NewNowikiblock_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Creole10ParserRULE_nowikiblock_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(667)
		p.Match(Creole10ParserNOWIKI_BLOCK_CLOSE)
	}

	return localctx
}

// INowiki_inlineContext is an interface to support dynamic dispatch.
type INowiki_inlineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_inlineContext differentiates from other interfaces.
	IsNowiki_inlineContext()
}

type Nowiki_inlineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_inlineContext() *Nowiki_inlineContext {
	var p = new(Nowiki_inlineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_inline
	return p
}

func (*Nowiki_inlineContext) IsNowiki_inlineContext() {}

func NewNowiki_inlineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_inlineContext {
	var p = new(Nowiki_inlineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_inline

	return p
}

func (s *Nowiki_inlineContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_inlineContext) Nowiki_open_markup() INowiki_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_open_markupContext)
}

func (s *Nowiki_inlineContext) Nowiki_inline_content() INowiki_inline_contentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_inline_contentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_inline_contentContext)
}

func (s *Nowiki_inlineContext) Nowiki_close_markup() INowiki_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INowiki_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INowiki_close_markupContext)
}

func (s *Nowiki_inlineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_inlineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_inlineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_inline(s)
	}
}

func (s *Nowiki_inlineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_inline(s)
	}
}

func (p *Creole10Parser) Nowiki_inline() (localctx INowiki_inlineContext) {
	localctx = NewNowiki_inlineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Creole10ParserRULE_nowiki_inline)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Nowiki_open_markup()
	}
	{
		p.SetState(670)
		p.Nowiki_inline_content()
	}
	{
		p.SetState(671)
		p.Nowiki_close_markup()
	}

	return localctx
}

// INowiki_inline_contentContext is an interface to support dynamic dispatch.
type INowiki_inline_contentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_inline_contentContext differentiates from other interfaces.
	IsNowiki_inline_contentContext()
}

type Nowiki_inline_contentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_inline_contentContext() *Nowiki_inline_contentContext {
	var p = new(Nowiki_inline_contentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_inline_content
	return p
}

func (*Nowiki_inline_contentContext) IsNowiki_inline_contentContext() {}

func NewNowiki_inline_contentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_inline_contentContext {
	var p = new(Nowiki_inline_contentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_inline_content

	return p
}

func (s *Nowiki_inline_contentContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_inline_contentContext) AllNOWIKI_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_CLOSE)
}

func (s *Nowiki_inline_contentContext) NOWIKI_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_CLOSE, i)
}

func (s *Nowiki_inline_contentContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Nowiki_inline_contentContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Nowiki_inline_contentContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Nowiki_inline_contentContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Nowiki_inline_contentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_inline_contentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_inline_contentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_inline_content(s)
	}
}

func (s *Nowiki_inline_contentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_inline_content(s)
	}
}

func (p *Creole10Parser) Nowiki_inline_content() (localctx INowiki_inline_contentContext) {
	localctx = NewNowiki_inline_contentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Creole10ParserRULE_nowiki_inline_content)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		p.SetState(673)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserNOWIKI_CLOSE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(678)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IHorizontalruleContext is an interface to support dynamic dispatch.
type IHorizontalruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHorizontalruleContext differentiates from other interfaces.
	IsHorizontalruleContext()
}

type HorizontalruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHorizontalruleContext() *HorizontalruleContext {
	var p = new(HorizontalruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_horizontalrule
	return p
}

func (*HorizontalruleContext) IsHorizontalruleContext() {}

func NewHorizontalruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HorizontalruleContext {
	var p = new(HorizontalruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_horizontalrule

	return p
}

func (s *HorizontalruleContext) GetParser() antlr.Parser { return s.parser }

func (s *HorizontalruleContext) Horizontalrule_markup() IHorizontalrule_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHorizontalrule_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHorizontalrule_markupContext)
}

func (s *HorizontalruleContext) Paragraph_separator() IParagraph_separatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParagraph_separatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParagraph_separatorContext)
}

func (s *HorizontalruleContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *HorizontalruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HorizontalruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HorizontalruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHorizontalrule(s)
	}
}

func (s *HorizontalruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHorizontalrule(s)
	}
}

func (p *Creole10Parser) Horizontalrule() (localctx IHorizontalruleContext) {
	localctx = NewHorizontalruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Creole10ParserRULE_horizontalrule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.Horizontalrule_markup()
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserBLANKS {
		{
			p.SetState(680)
			p.Blanks()
		}

	}
	{
		p.SetState(683)
		p.Paragraph_separator()
	}

	return localctx
}

// ILinkContext is an interface to support dynamic dispatch.
type ILinkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkContext differentiates from other interfaces.
	IsLinkContext()
}

type LinkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkContext() *LinkContext {
	var p = new(LinkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link
	return p
}

func (*LinkContext) IsLinkContext() {}

func NewLinkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkContext {
	var p = new(LinkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link

	return p
}

func (s *LinkContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkContext) Link_open_markup() ILink_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_open_markupContext)
}

func (s *LinkContext) Link_address() ILink_addressContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_addressContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_addressContext)
}

func (s *LinkContext) Link_close_markup() ILink_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_close_markupContext)
}

func (s *LinkContext) Link_description_markup() ILink_description_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_description_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_description_markupContext)
}

func (s *LinkContext) Link_description() ILink_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptionContext)
}

func (s *LinkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink(s)
	}
}

func (s *LinkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink(s)
	}
}

func (p *Creole10Parser) Link() (localctx ILinkContext) {
	localctx = NewLinkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Creole10ParserRULE_link)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Link_open_markup()
	}
	{
		p.SetState(686)
		p.Link_address()
	}
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserPIPE {
		{
			p.SetState(687)
			p.Link_description_markup()
		}
		{
			p.SetState(688)
			p.Link_description()
		}

	}
	{
		p.SetState(692)
		p.Link_close_markup()
	}

	return localctx
}

// ILink_addressContext is an interface to support dynamic dispatch.
type ILink_addressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_addressContext differentiates from other interfaces.
	IsLink_addressContext()
}

type Link_addressContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_addressContext() *Link_addressContext {
	var p = new(Link_addressContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_address
	return p
}

func (*Link_addressContext) IsLink_addressContext() {}

func NewLink_addressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_addressContext {
	var p = new(Link_addressContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_address

	return p
}

func (s *Link_addressContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_addressContext) Link_interwiki_uri() ILink_interwiki_uriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_interwiki_uriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_interwiki_uriContext)
}

func (s *Link_addressContext) Link_interwiki_pagename() ILink_interwiki_pagenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_interwiki_pagenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_interwiki_pagenameContext)
}

func (s *Link_addressContext) Link_uri() ILink_uriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_uriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_uriContext)
}

func (s *Link_addressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_addressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_addressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_address(s)
	}
}

func (s *Link_addressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_address(s)
	}
}

func (p *Creole10Parser) Link_address() (localctx ILink_addressContext) {
	localctx = NewLink_addressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Creole10ParserRULE_link_address)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.Link_interwiki_uri()
		}
		{
			p.SetState(695)
			p.Match(Creole10ParserT__0)
		}
		{
			p.SetState(696)
			p.Link_interwiki_pagename()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(698)
			p.Link_uri()
		}

	}

	return localctx
}

// ILink_interwiki_uriContext is an interface to support dynamic dispatch.
type ILink_interwiki_uriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_interwiki_uriContext differentiates from other interfaces.
	IsLink_interwiki_uriContext()
}

type Link_interwiki_uriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_interwiki_uriContext() *Link_interwiki_uriContext {
	var p = new(Link_interwiki_uriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_interwiki_uri
	return p
}

func (*Link_interwiki_uriContext) IsLink_interwiki_uriContext() {}

func NewLink_interwiki_uriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_interwiki_uriContext {
	var p = new(Link_interwiki_uriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_interwiki_uri

	return p
}

func (s *Link_interwiki_uriContext) GetParser() antlr.Parser { return s.parser }
func (s *Link_interwiki_uriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_interwiki_uriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_interwiki_uriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_interwiki_uri(s)
	}
}

func (s *Link_interwiki_uriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_interwiki_uri(s)
	}
}

func (p *Creole10Parser) Link_interwiki_uri() (localctx ILink_interwiki_uriContext) {
	localctx = NewLink_interwiki_uriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Creole10ParserRULE_link_interwiki_uri)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.Match(Creole10ParserT__1)
	}
	{
		p.SetState(702)
		p.Match(Creole10ParserT__2)
	}

	return localctx
}

// ILink_interwiki_pagenameContext is an interface to support dynamic dispatch.
type ILink_interwiki_pagenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_interwiki_pagenameContext differentiates from other interfaces.
	IsLink_interwiki_pagenameContext()
}

type Link_interwiki_pagenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_interwiki_pagenameContext() *Link_interwiki_pagenameContext {
	var p = new(Link_interwiki_pagenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_interwiki_pagename
	return p
}

func (*Link_interwiki_pagenameContext) IsLink_interwiki_pagenameContext() {}

func NewLink_interwiki_pagenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_interwiki_pagenameContext {
	var p = new(Link_interwiki_pagenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_interwiki_pagename

	return p
}

func (s *Link_interwiki_pagenameContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_interwiki_pagenameContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Link_interwiki_pagenameContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Link_interwiki_pagenameContext) AllLINK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_CLOSE)
}

func (s *Link_interwiki_pagenameContext) LINK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, i)
}

func (s *Link_interwiki_pagenameContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Link_interwiki_pagenameContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Link_interwiki_pagenameContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Link_interwiki_pagenameContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Link_interwiki_pagenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_interwiki_pagenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_interwiki_pagenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_interwiki_pagename(s)
	}
}

func (s *Link_interwiki_pagenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_interwiki_pagename(s)
	}
}

func (p *Creole10Parser) Link_interwiki_pagename() (localctx ILink_interwiki_pagenameContext) {
	localctx = NewLink_interwiki_pagenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Creole10ParserRULE_link_interwiki_pagename)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(704)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserLINK_CLOSE - -1))|(1<<(Creole10ParserPIPE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(707)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILink_descriptionContext is an interface to support dynamic dispatch.
type ILink_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_descriptionContext differentiates from other interfaces.
	IsLink_descriptionContext()
}

type Link_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_descriptionContext() *Link_descriptionContext {
	var p = new(Link_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_description
	return p
}

func (*Link_descriptionContext) IsLink_descriptionContext() {}

func NewLink_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_descriptionContext {
	var p = new(Link_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_description

	return p
}

func (s *Link_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_descriptionContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Link_descriptionContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Link_descriptionContext) AllLink_descriptionpart() []ILink_descriptionpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_descriptionpartContext)(nil)).Elem())
	var tst = make([]ILink_descriptionpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_descriptionpartContext)
		}
	}

	return tst
}

func (s *Link_descriptionContext) Link_descriptionpart(i int) ILink_descriptionpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptionpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptionpartContext)
}

func (s *Link_descriptionContext) AllImage() []IImageContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImageContext)(nil)).Elem())
	var tst = make([]IImageContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImageContext)
		}
	}

	return tst
}

func (s *Link_descriptionContext) Image(i int) IImageContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImageContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImageContext)
}

func (s *Link_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_description(s)
	}
}

func (s *Link_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_description(s)
	}
}

func (p *Creole10Parser) Link_description() (localctx ILink_descriptionContext) {
	localctx = NewLink_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Creole10ParserRULE_link_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(713)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(709)
					p.Onestar()
				}
				{
					p.SetState(710)
					p.Link_descriptionpart()
				}

			case 2:
				{
					p.SetState(712)
					p.Image()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}

	return localctx
}

// ILink_descriptionpartContext is an interface to support dynamic dispatch.
type ILink_descriptionpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_descriptionpartContext differentiates from other interfaces.
	IsLink_descriptionpartContext()
}

type Link_descriptionpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_descriptionpartContext() *Link_descriptionpartContext {
	var p = new(Link_descriptionpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_descriptionpart
	return p
}

func (*Link_descriptionpartContext) IsLink_descriptionpartContext() {}

func NewLink_descriptionpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_descriptionpartContext {
	var p = new(Link_descriptionpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_descriptionpart

	return p
}

func (s *Link_descriptionpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_descriptionpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Link_descriptionpartContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Link_descriptionpartContext) AllLink_bold_descriptionpart() []ILink_bold_descriptionpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_bold_descriptionpartContext)(nil)).Elem())
	var tst = make([]ILink_bold_descriptionpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_bold_descriptionpartContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Link_bold_descriptionpart(i int) ILink_bold_descriptionpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_bold_descriptionpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_bold_descriptionpartContext)
}

func (s *Link_descriptionpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Link_descriptionpartContext) AllLink_ital_descriptionpart() []ILink_ital_descriptionpartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_ital_descriptionpartContext)(nil)).Elem())
	var tst = make([]ILink_ital_descriptionpartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_ital_descriptionpartContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Link_ital_descriptionpart(i int) ILink_ital_descriptionpartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_ital_descriptionpartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_ital_descriptionpartContext)
}

func (s *Link_descriptionpartContext) AllLink_descriptiontext() []ILink_descriptiontextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem())
	var tst = make([]ILink_descriptiontextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_descriptiontextContext)
		}
	}

	return tst
}

func (s *Link_descriptionpartContext) Link_descriptiontext(i int) ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_descriptionpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_descriptionpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_descriptionpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_descriptionpart(s)
	}
}

func (s *Link_descriptionpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_descriptionpart(s)
	}
}

func (p *Creole10Parser) Link_descriptionpart() (localctx ILink_descriptionpartContext) {
	localctx = NewLink_descriptionpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Creole10ParserRULE_link_descriptionpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(717)
			p.Bold_markup()
		}
		p.SetState(721)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(718)
					p.Onestar()
				}
				{
					p.SetState(719)
					p.Link_bold_descriptionpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(723)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())
		}
		{
			p.SetState(725)
			p.Bold_markup()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(727)
			p.Ital_markup()
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(728)
					p.Onestar()
				}
				{
					p.SetState(729)
					p.Link_ital_descriptionpart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(733)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext())
		}
		{
			p.SetState(735)
			p.Ital_markup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(737)
					p.Onestar()
				}
				{
					p.SetState(738)
					p.Link_descriptiontext()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(742)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
		}
		{
			p.SetState(744)
			p.Onestar()
		}

	}

	return localctx
}

// ILink_bold_descriptionpartContext is an interface to support dynamic dispatch.
type ILink_bold_descriptionpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_bold_descriptionpartContext differentiates from other interfaces.
	IsLink_bold_descriptionpartContext()
}

type Link_bold_descriptionpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_bold_descriptionpartContext() *Link_bold_descriptionpartContext {
	var p = new(Link_bold_descriptionpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_bold_descriptionpart
	return p
}

func (*Link_bold_descriptionpartContext) IsLink_bold_descriptionpartContext() {}

func NewLink_bold_descriptionpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_bold_descriptionpartContext {
	var p = new(Link_bold_descriptionpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_bold_descriptionpart

	return p
}

func (s *Link_bold_descriptionpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_bold_descriptionpartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Link_bold_descriptionpartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Link_bold_descriptionpartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Link_bold_descriptionpartContext) Link_descriptiontext() ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_bold_descriptionpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_bold_descriptionpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_bold_descriptionpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_bold_descriptionpart(s)
	}
}

func (s *Link_bold_descriptionpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_bold_descriptionpart(s)
	}
}

func (p *Creole10Parser) Link_bold_descriptionpart() (localctx ILink_bold_descriptionpartContext) {
	localctx = NewLink_bold_descriptionpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Creole10ParserRULE_link_bold_descriptionpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(748)
			p.Ital_markup()
		}
		{
			p.SetState(749)
			p.Link_boldital_description()
		}
		{
			p.SetState(750)
			p.Ital_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.Link_descriptiontext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILink_ital_descriptionpartContext is an interface to support dynamic dispatch.
type ILink_ital_descriptionpartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_ital_descriptionpartContext differentiates from other interfaces.
	IsLink_ital_descriptionpartContext()
}

type Link_ital_descriptionpartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_ital_descriptionpartContext() *Link_ital_descriptionpartContext {
	var p = new(Link_ital_descriptionpartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_ital_descriptionpart
	return p
}

func (*Link_ital_descriptionpartContext) IsLink_ital_descriptionpartContext() {}

func NewLink_ital_descriptionpartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_ital_descriptionpartContext {
	var p = new(Link_ital_descriptionpartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_ital_descriptionpart

	return p
}

func (s *Link_ital_descriptionpartContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_ital_descriptionpartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Link_ital_descriptionpartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Link_ital_descriptionpartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Link_ital_descriptionpartContext) Link_descriptiontext() ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_ital_descriptionpartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_ital_descriptionpartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_ital_descriptionpartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_ital_descriptionpart(s)
	}
}

func (s *Link_ital_descriptionpartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_ital_descriptionpart(s)
	}
}

func (p *Creole10Parser) Link_ital_descriptionpart() (localctx ILink_ital_descriptionpartContext) {
	localctx = NewLink_ital_descriptionpartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Creole10ParserRULE_link_ital_descriptionpart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(760)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Bold_markup()
		}
		{
			p.SetState(756)
			p.Link_boldital_description()
		}
		{
			p.SetState(757)
			p.Bold_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.Link_descriptiontext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILink_boldital_descriptionContext is an interface to support dynamic dispatch.
type ILink_boldital_descriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_boldital_descriptionContext differentiates from other interfaces.
	IsLink_boldital_descriptionContext()
}

type Link_boldital_descriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_boldital_descriptionContext() *Link_boldital_descriptionContext {
	var p = new(Link_boldital_descriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_boldital_description
	return p
}

func (*Link_boldital_descriptionContext) IsLink_boldital_descriptionContext() {}

func NewLink_boldital_descriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_boldital_descriptionContext {
	var p = new(Link_boldital_descriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_boldital_description

	return p
}

func (s *Link_boldital_descriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_boldital_descriptionContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Link_boldital_descriptionContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Link_boldital_descriptionContext) AllLink_descriptiontext() []ILink_descriptiontextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem())
	var tst = make([]ILink_descriptiontextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILink_descriptiontextContext)
		}
	}

	return tst
}

func (s *Link_boldital_descriptionContext) Link_descriptiontext(i int) ILink_descriptiontextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_descriptiontextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILink_descriptiontextContext)
}

func (s *Link_boldital_descriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_boldital_descriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_boldital_descriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_boldital_description(s)
	}
}

func (s *Link_boldital_descriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_boldital_description(s)
	}
}

func (p *Creole10Parser) Link_boldital_description() (localctx ILink_boldital_descriptionContext) {
	localctx = NewLink_boldital_descriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Creole10ParserRULE_link_boldital_description)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(762)
				p.Onestar()
			}
			{
				p.SetState(763)
				p.Link_descriptiontext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext())
	}
	{
		p.SetState(769)
		p.Onestar()
	}

	return localctx
}

// ILink_descriptiontextContext is an interface to support dynamic dispatch.
type ILink_descriptiontextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_descriptiontextContext differentiates from other interfaces.
	IsLink_descriptiontextContext()
}

type Link_descriptiontextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_descriptiontextContext() *Link_descriptiontextContext {
	var p = new(Link_descriptiontextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_descriptiontext
	return p
}

func (*Link_descriptiontextContext) IsLink_descriptiontextContext() {}

func NewLink_descriptiontextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_descriptiontextContext {
	var p = new(Link_descriptiontextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_descriptiontext

	return p
}

func (s *Link_descriptiontextContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_descriptiontextContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Link_descriptiontextContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Link_descriptiontextContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Link_descriptiontextContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Link_descriptiontextContext) AllLINK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_CLOSE)
}

func (s *Link_descriptiontextContext) LINK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, i)
}

func (s *Link_descriptiontextContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Link_descriptiontextContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Link_descriptiontextContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Link_descriptiontextContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Link_descriptiontextContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Link_descriptiontextContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Link_descriptiontextContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Link_descriptiontextContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Link_descriptiontextContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Link_descriptiontextContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Link_descriptiontextContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Link_descriptiontextContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Link_descriptiontextContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Link_descriptiontextContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Link_descriptiontextContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Link_descriptiontextContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Link_descriptiontextContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Link_descriptiontextContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Link_descriptiontextContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Link_descriptiontextContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Link_descriptiontextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_descriptiontextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_descriptiontextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_descriptiontext(s)
	}
}

func (s *Link_descriptiontextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_descriptiontext(s)
	}
}

func (p *Creole10Parser) Link_descriptiontext() (localctx ILink_descriptiontextContext) {
	localctx = NewLink_descriptiontextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Creole10ParserRULE_link_descriptiontext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(774)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserIMAGE_CLOSE, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(771)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserLINK_CLOSE - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(772)
					p.Forced_linebreak()
				}

			case Creole10ParserESCAPE:
				{
					p.SetState(773)
					p.Escaped()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}

	return localctx
}

// ILink_uriContext is an interface to support dynamic dispatch.
type ILink_uriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_uriContext differentiates from other interfaces.
	IsLink_uriContext()
}

type Link_uriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_uriContext() *Link_uriContext {
	var p = new(Link_uriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_uri
	return p
}

func (*Link_uriContext) IsLink_uriContext() {}

func NewLink_uriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_uriContext {
	var p = new(Link_uriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_uri

	return p
}

func (s *Link_uriContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_uriContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Link_uriContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Link_uriContext) AllLINK_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_CLOSE)
}

func (s *Link_uriContext) LINK_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, i)
}

func (s *Link_uriContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Link_uriContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Link_uriContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Link_uriContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Link_uriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_uriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_uriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_uri(s)
	}
}

func (s *Link_uriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_uri(s)
	}
}

func (p *Creole10Parser) Link_uri() (localctx ILink_uriContext) {
	localctx = NewLink_uriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Creole10ParserRULE_link_uri)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(778)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserLINK_CLOSE - -1))|(1<<(Creole10ParserPIPE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImageContext is an interface to support dynamic dispatch.
type IImageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImageContext differentiates from other interfaces.
	IsImageContext()
}

type ImageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImageContext() *ImageContext {
	var p = new(ImageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image
	return p
}

func (*ImageContext) IsImageContext() {}

func NewImageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImageContext {
	var p = new(ImageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image

	return p
}

func (s *ImageContext) GetParser() antlr.Parser { return s.parser }

func (s *ImageContext) Image_open_markup() IImage_open_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_open_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_open_markupContext)
}

func (s *ImageContext) Image_uri() IImage_uriContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_uriContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_uriContext)
}

func (s *ImageContext) Image_close_markup() IImage_close_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_close_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_close_markupContext)
}

func (s *ImageContext) Image_alternative() IImage_alternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativeContext)
}

func (s *ImageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage(s)
	}
}

func (s *ImageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage(s)
	}
}

func (p *Creole10Parser) Image() (localctx IImageContext) {
	localctx = NewImageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Creole10ParserRULE_image)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Image_open_markup()
	}
	{
		p.SetState(784)
		p.Image_uri()
	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Creole10ParserPIPE {
		{
			p.SetState(785)
			p.Image_alternative()
		}

	}
	{
		p.SetState(788)
		p.Image_close_markup()
	}

	return localctx
}

// IImage_uriContext is an interface to support dynamic dispatch.
type IImage_uriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_uriContext differentiates from other interfaces.
	IsImage_uriContext()
}

type Image_uriContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_uriContext() *Image_uriContext {
	var p = new(Image_uriContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_uri
	return p
}

func (*Image_uriContext) IsImage_uriContext() {}

func NewImage_uriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_uriContext {
	var p = new(Image_uriContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_uri

	return p
}

func (s *Image_uriContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_uriContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserPIPE)
}

func (s *Image_uriContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, i)
}

func (s *Image_uriContext) AllIMAGE_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_CLOSE)
}

func (s *Image_uriContext) IMAGE_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_CLOSE, i)
}

func (s *Image_uriContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Image_uriContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Image_uriContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Image_uriContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Image_uriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_uriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_uriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_uri(s)
	}
}

func (s *Image_uriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_uri(s)
	}
}

func (p *Creole10Parser) Image_uri() (localctx IImage_uriContext) {
	localctx = NewImage_uriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Creole10ParserRULE_image_uri)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserEXTENSION)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(790)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserIMAGE_CLOSE - -1))|(1<<(Creole10ParserPIPE - -1)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}

		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImage_alternativeContext is an interface to support dynamic dispatch.
type IImage_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternativeContext differentiates from other interfaces.
	IsImage_alternativeContext()
}

type Image_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternativeContext() *Image_alternativeContext {
	var p = new(Image_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternative
	return p
}

func (*Image_alternativeContext) IsImage_alternativeContext() {}

func NewImage_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternativeContext {
	var p = new(Image_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternative

	return p
}

func (s *Image_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternativeContext) Image_alternative_markup() IImage_alternative_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternative_markupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternative_markupContext)
}

func (s *Image_alternativeContext) AllImage_alternativepart() []IImage_alternativepartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_alternativepartContext)(nil)).Elem())
	var tst = make([]IImage_alternativepartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_alternativepartContext)
		}
	}

	return tst
}

func (s *Image_alternativeContext) Image_alternativepart(i int) IImage_alternativepartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativepartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativepartContext)
}

func (s *Image_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternative(s)
	}
}

func (s *Image_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternative(s)
	}
}

func (p *Creole10Parser) Image_alternative() (localctx IImage_alternativeContext) {
	localctx = NewImage_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Creole10ParserRULE_image_alternative)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(795)
		p.Image_alternative_markup()
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		{
			p.SetState(796)
			p.Image_alternativepart()
		}

		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IImage_alternativepartContext is an interface to support dynamic dispatch.
type IImage_alternativepartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternativepartContext differentiates from other interfaces.
	IsImage_alternativepartContext()
}

type Image_alternativepartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternativepartContext() *Image_alternativepartContext {
	var p = new(Image_alternativepartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternativepart
	return p
}

func (*Image_alternativepartContext) IsImage_alternativepartContext() {}

func NewImage_alternativepartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternativepartContext {
	var p = new(Image_alternativepartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternativepart

	return p
}

func (s *Image_alternativepartContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternativepartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Image_alternativepartContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Image_alternativepartContext) AllImage_bold_alternativepart() []IImage_bold_alternativepartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_bold_alternativepartContext)(nil)).Elem())
	var tst = make([]IImage_bold_alternativepartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_bold_alternativepartContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Image_bold_alternativepart(i int) IImage_bold_alternativepartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_bold_alternativepartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_bold_alternativepartContext)
}

func (s *Image_alternativepartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Image_alternativepartContext) AllImage_ital_alternativepart() []IImage_ital_alternativepartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_ital_alternativepartContext)(nil)).Elem())
	var tst = make([]IImage_ital_alternativepartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_ital_alternativepartContext)
		}
	}

	return tst
}

func (s *Image_alternativepartContext) Image_ital_alternativepart(i int) IImage_ital_alternativepartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_ital_alternativepartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_ital_alternativepartContext)
}

func (s *Image_alternativepartContext) Image_alternativetext() IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_alternativepartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternativepartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternativepartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternativepart(s)
	}
}

func (s *Image_alternativepartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternativepart(s)
	}
}

func (p *Creole10Parser) Image_alternativepart() (localctx IImage_alternativepartContext) {
	localctx = NewImage_alternativepartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Creole10ParserRULE_image_alternativepart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(822)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(801)
			p.Bold_markup()
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(802)
					p.Onestar()
				}
				{
					p.SetState(803)
					p.Image_bold_alternativepart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(807)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())
		}
		{
			p.SetState(809)
			p.Bold_markup()
		}

	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(811)
			p.Ital_markup()
		}
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(812)
					p.Onestar()
				}
				{
					p.SetState(813)
					p.Image_ital_alternativepart()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(817)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
		}
		{
			p.SetState(819)
			p.Ital_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(821)
			p.Image_alternativetext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImage_bold_alternativepartContext is an interface to support dynamic dispatch.
type IImage_bold_alternativepartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_bold_alternativepartContext differentiates from other interfaces.
	IsImage_bold_alternativepartContext()
}

type Image_bold_alternativepartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_bold_alternativepartContext() *Image_bold_alternativepartContext {
	var p = new(Image_bold_alternativepartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_bold_alternativepart
	return p
}

func (*Image_bold_alternativepartContext) IsImage_bold_alternativepartContext() {}

func NewImage_bold_alternativepartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_bold_alternativepartContext {
	var p = new(Image_bold_alternativepartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_bold_alternativepart

	return p
}

func (s *Image_bold_alternativepartContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_bold_alternativepartContext) AllItal_markup() []IItal_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IItal_markupContext)(nil)).Elem())
	var tst = make([]IItal_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IItal_markupContext)
		}
	}

	return tst
}

func (s *Image_bold_alternativepartContext) Ital_markup(i int) IItal_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItal_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IItal_markupContext)
}

func (s *Image_bold_alternativepartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Image_bold_alternativepartContext) Image_alternativetext() IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_bold_alternativepartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_bold_alternativepartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_bold_alternativepartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_bold_alternativepart(s)
	}
}

func (s *Image_bold_alternativepartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_bold_alternativepart(s)
	}
}

func (p *Creole10Parser) Image_bold_alternativepart() (localctx IImage_bold_alternativepartContext) {
	localctx = NewImage_bold_alternativepartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Creole10ParserRULE_image_bold_alternativepart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(829)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserITAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			p.Ital_markup()
		}
		{
			p.SetState(825)
			p.Link_boldital_description()
		}
		{
			p.SetState(826)
			p.Ital_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(828)
			p.Image_alternativetext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImage_ital_alternativepartContext is an interface to support dynamic dispatch.
type IImage_ital_alternativepartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_ital_alternativepartContext differentiates from other interfaces.
	IsImage_ital_alternativepartContext()
}

type Image_ital_alternativepartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_ital_alternativepartContext() *Image_ital_alternativepartContext {
	var p = new(Image_ital_alternativepartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_ital_alternativepart
	return p
}

func (*Image_ital_alternativepartContext) IsImage_ital_alternativepartContext() {}

func NewImage_ital_alternativepartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_ital_alternativepartContext {
	var p = new(Image_ital_alternativepartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_ital_alternativepart

	return p
}

func (s *Image_ital_alternativepartContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_ital_alternativepartContext) AllBold_markup() []IBold_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBold_markupContext)(nil)).Elem())
	var tst = make([]IBold_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBold_markupContext)
		}
	}

	return tst
}

func (s *Image_ital_alternativepartContext) Bold_markup(i int) IBold_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBold_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBold_markupContext)
}

func (s *Image_ital_alternativepartContext) Link_boldital_description() ILink_boldital_descriptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILink_boldital_descriptionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILink_boldital_descriptionContext)
}

func (s *Image_ital_alternativepartContext) Image_alternativetext() IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_ital_alternativepartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_ital_alternativepartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_ital_alternativepartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_ital_alternativepart(s)
	}
}

func (s *Image_ital_alternativepartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_ital_alternativepart(s)
	}
}

func (p *Creole10Parser) Image_ital_alternativepart() (localctx IImage_ital_alternativepartContext) {
	localctx = NewImage_ital_alternativepartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Creole10ParserRULE_image_ital_alternativepart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(836)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(831)
			p.Bold_markup()
		}
		{
			p.SetState(832)
			p.Link_boldital_description()
		}
		{
			p.SetState(833)
			p.Bold_markup()
		}

	case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(835)
			p.Image_alternativetext()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImage_boldital_alternativeContext is an interface to support dynamic dispatch.
type IImage_boldital_alternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_boldital_alternativeContext differentiates from other interfaces.
	IsImage_boldital_alternativeContext()
}

type Image_boldital_alternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_boldital_alternativeContext() *Image_boldital_alternativeContext {
	var p = new(Image_boldital_alternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_boldital_alternative
	return p
}

func (*Image_boldital_alternativeContext) IsImage_boldital_alternativeContext() {}

func NewImage_boldital_alternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_boldital_alternativeContext {
	var p = new(Image_boldital_alternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_boldital_alternative

	return p
}

func (s *Image_boldital_alternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_boldital_alternativeContext) AllOnestar() []IOnestarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOnestarContext)(nil)).Elem())
	var tst = make([]IOnestarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOnestarContext)
		}
	}

	return tst
}

func (s *Image_boldital_alternativeContext) Onestar(i int) IOnestarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOnestarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOnestarContext)
}

func (s *Image_boldital_alternativeContext) AllImage_alternativetext() []IImage_alternativetextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem())
	var tst = make([]IImage_alternativetextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImage_alternativetextContext)
		}
	}

	return tst
}

func (s *Image_boldital_alternativeContext) Image_alternativetext(i int) IImage_alternativetextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImage_alternativetextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImage_alternativetextContext)
}

func (s *Image_boldital_alternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_boldital_alternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_boldital_alternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_boldital_alternative(s)
	}
}

func (s *Image_boldital_alternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_boldital_alternative(s)
	}
}

func (p *Creole10Parser) Image_boldital_alternative() (localctx IImage_boldital_alternativeContext) {
	localctx = NewImage_boldital_alternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Creole10ParserRULE_image_boldital_alternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(838)
				p.Onestar()
			}
			{
				p.SetState(839)
				p.Image_alternativetext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext())
	}
	{
		p.SetState(845)
		p.Onestar()
	}

	return localctx
}

// IImage_alternativetextContext is an interface to support dynamic dispatch.
type IImage_alternativetextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternativetextContext differentiates from other interfaces.
	IsImage_alternativetextContext()
}

type Image_alternativetextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternativetextContext() *Image_alternativetextContext {
	var p = new(Image_alternativetextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternativetext
	return p
}

func (*Image_alternativetextContext) IsImage_alternativetextContext() {}

func NewImage_alternativetextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternativetextContext {
	var p = new(Image_alternativetextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternativetext

	return p
}

func (s *Image_alternativetextContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternativetextContext) AllForced_linebreak() []IForced_linebreakContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem())
	var tst = make([]IForced_linebreakContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IForced_linebreakContext)
		}
	}

	return tst
}

func (s *Image_alternativetextContext) Forced_linebreak(i int) IForced_linebreakContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForced_linebreakContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IForced_linebreakContext)
}

func (s *Image_alternativetextContext) AllIMAGE_CLOSE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_CLOSE)
}

func (s *Image_alternativetextContext) IMAGE_CLOSE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_CLOSE, i)
}

func (s *Image_alternativetextContext) AllITAL() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserITAL)
}

func (s *Image_alternativetextContext) ITAL(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, i)
}

func (s *Image_alternativetextContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Image_alternativetextContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Image_alternativetextContext) AllLINK_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserLINK_OPEN)
}

func (s *Image_alternativetextContext) LINK_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, i)
}

func (s *Image_alternativetextContext) AllIMAGE_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserIMAGE_OPEN)
}

func (s *Image_alternativetextContext) IMAGE_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, i)
}

func (s *Image_alternativetextContext) AllNOWIKI_OPEN() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNOWIKI_OPEN)
}

func (s *Image_alternativetextContext) NOWIKI_OPEN(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, i)
}

func (s *Image_alternativetextContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Image_alternativetextContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Image_alternativetextContext) AllFORCED_LINEBREAK() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserFORCED_LINEBREAK)
}

func (s *Image_alternativetextContext) FORCED_LINEBREAK(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, i)
}

func (s *Image_alternativetextContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Image_alternativetextContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Image_alternativetextContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Image_alternativetextContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Image_alternativetextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternativetextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternativetextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternativetext(s)
	}
}

func (s *Image_alternativetextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternativetext(s)
	}
}

func (p *Creole10Parser) Image_alternativetext() (localctx IImage_alternativetextContext) {
	localctx = NewImage_alternativetextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Creole10ParserRULE_image_alternativetext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(849)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserESCAPE, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_CLOSE, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
				p.SetState(847)
				_la = p.GetTokenStream().LA(1)

				if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserITAL - -1))|(1<<(Creole10ParserNOWIKI_OPEN - -1))|(1<<(Creole10ParserLINK_OPEN - -1))|(1<<(Creole10ParserIMAGE_OPEN - -1))|(1<<(Creole10ParserIMAGE_CLOSE - -1))|(1<<(Creole10ParserFORCED_LINEBREAK - -1))|(1<<(Creole10ParserSTAR - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}

			case Creole10ParserFORCED_LINEBREAK:
				{
					p.SetState(848)
					p.Forced_linebreak()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}

	return localctx
}

// IExtensionContext is an interface to support dynamic dispatch.
type IExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionContext differentiates from other interfaces.
	IsExtensionContext()
}

type ExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionContext() *ExtensionContext {
	var p = new(ExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension
	return p
}

func (*ExtensionContext) IsExtensionContext() {}

func NewExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionContext {
	var p = new(ExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension

	return p
}

func (s *ExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionContext) AllExtension_markup() []IExtension_markupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtension_markupContext)(nil)).Elem())
	var tst = make([]IExtension_markupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtension_markupContext)
		}
	}

	return tst
}

func (s *ExtensionContext) Extension_markup(i int) IExtension_markupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_markupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtension_markupContext)
}

func (s *ExtensionContext) Extension_handler() IExtension_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_handlerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtension_handlerContext)
}

func (s *ExtensionContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *ExtensionContext) Extension_statement() IExtension_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtension_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtension_statementContext)
}

func (s *ExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension(s)
	}
}

func (s *ExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension(s)
	}
}

func (p *Creole10Parser) Extension() (localctx IExtensionContext) {
	localctx = NewExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Creole10ParserRULE_extension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Extension_markup()
	}
	{
		p.SetState(854)
		p.Extension_handler()
	}
	{
		p.SetState(855)
		p.Blanks()
	}
	{
		p.SetState(856)
		p.Extension_statement()
	}
	{
		p.SetState(857)
		p.Extension_markup()
	}

	return localctx
}

// IExtension_handlerContext is an interface to support dynamic dispatch.
type IExtension_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_handlerContext differentiates from other interfaces.
	IsExtension_handlerContext()
}

type Extension_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_handlerContext() *Extension_handlerContext {
	var p = new(Extension_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension_handler
	return p
}

func (*Extension_handlerContext) IsExtension_handlerContext() {}

func NewExtension_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_handlerContext {
	var p = new(Extension_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension_handler

	return p
}

func (s *Extension_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_handlerContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Extension_handlerContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Extension_handlerContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Extension_handlerContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Extension_handlerContext) AllBLANKS() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserBLANKS)
}

func (s *Extension_handlerContext) BLANKS(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserBLANKS, i)
}

func (s *Extension_handlerContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Extension_handlerContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Extension_handlerContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserNEWLINE)
}

func (s *Extension_handlerContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, i)
}

func (s *Extension_handlerContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Extension_handlerContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Extension_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension_handler(s)
	}
}

func (s *Extension_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension_handler(s)
	}
}

func (p *Creole10Parser) Extension_handler() (localctx IExtension_handlerContext) {
	localctx = NewExtension_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Creole10ParserRULE_extension_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0) {
		p.SetState(861)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
			p.SetState(859)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserNEWLINE - -1))|(1<<(Creole10ParserBLANKS - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

		case Creole10ParserESCAPE:
			{
				p.SetState(860)
				p.Escaped()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExtension_statementContext is an interface to support dynamic dispatch.
type IExtension_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_statementContext differentiates from other interfaces.
	IsExtension_statementContext()
}

type Extension_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_statementContext() *Extension_statementContext {
	var p = new(Extension_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension_statement
	return p
}

func (*Extension_statementContext) IsExtension_statementContext() {}

func NewExtension_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_statementContext {
	var p = new(Extension_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension_statement

	return p
}

func (s *Extension_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_statementContext) AllEscaped() []IEscapedContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedContext)(nil)).Elem())
	var tst = make([]IEscapedContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedContext)
		}
	}

	return tst
}

func (s *Extension_statementContext) Escaped(i int) IEscapedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedContext)
}

func (s *Extension_statementContext) AllEXTENSION() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEXTENSION)
}

func (s *Extension_statementContext) EXTENSION(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, i)
}

func (s *Extension_statementContext) AllESCAPE() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserESCAPE)
}

func (s *Extension_statementContext) ESCAPE(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, i)
}

func (s *Extension_statementContext) AllEOF() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserEOF)
}

func (s *Extension_statementContext) EOF(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, i)
}

func (s *Extension_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension_statement(s)
	}
}

func (s *Extension_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension_statement(s)
	}
}

func (p *Creole10Parser) Extension_statement() (localctx IExtension_statementContext) {
	localctx = NewExtension_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Creole10ParserRULE_extension_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<Creole10ParserT__0)|(1<<Creole10ParserT__1)|(1<<Creole10ParserT__2)|(1<<Creole10ParserESCAPE)|(1<<Creole10ParserNOWIKI_BLOCK_CLOSE)|(1<<Creole10ParserNEWLINE)|(1<<Creole10ParserBLANKS)|(1<<Creole10ParserCOLON_SLASH)|(1<<Creole10ParserITAL)|(1<<Creole10ParserNOWIKI_OPEN)|(1<<Creole10ParserNOWIKI_CLOSE)|(1<<Creole10ParserLINK_OPEN)|(1<<Creole10ParserLINK_CLOSE)|(1<<Creole10ParserIMAGE_OPEN)|(1<<Creole10ParserIMAGE_CLOSE)|(1<<Creole10ParserFORCED_LINEBREAK)|(1<<Creole10ParserEQUAL)|(1<<Creole10ParserPIPE)|(1<<Creole10ParserPOUND)|(1<<Creole10ParserDASH)|(1<<Creole10ParserSTAR)|(1<<Creole10ParserSLASH)|(1<<Creole10ParserINSIGNIFICANT_CHAR))) != 0 {
		p.SetState(867)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Creole10ParserT__0, Creole10ParserT__1, Creole10ParserT__2, Creole10ParserNOWIKI_BLOCK_CLOSE, Creole10ParserNEWLINE, Creole10ParserBLANKS, Creole10ParserCOLON_SLASH, Creole10ParserITAL, Creole10ParserNOWIKI_OPEN, Creole10ParserNOWIKI_CLOSE, Creole10ParserLINK_OPEN, Creole10ParserLINK_CLOSE, Creole10ParserIMAGE_OPEN, Creole10ParserIMAGE_CLOSE, Creole10ParserFORCED_LINEBREAK, Creole10ParserEQUAL, Creole10ParserPIPE, Creole10ParserPOUND, Creole10ParserDASH, Creole10ParserSTAR, Creole10ParserSLASH, Creole10ParserINSIGNIFICANT_CHAR:
			p.SetState(865)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || (((_la - -1)&-(0x1f+1)) == 0 && ((1<<uint((_la - -1)))&((1<<(Creole10ParserEOF - -1))|(1<<(Creole10ParserESCAPE - -1))|(1<<(Creole10ParserEXTENSION - -1)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}

		case Creole10ParserESCAPE:
			{
				p.SetState(866)
				p.Escaped()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEscapedContext is an interface to support dynamic dispatch.
type IEscapedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscapedContext differentiates from other interfaces.
	IsEscapedContext()
}

type EscapedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedContext() *EscapedContext {
	var p = new(EscapedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_escaped
	return p
}

func (*EscapedContext) IsEscapedContext() {}

func NewEscapedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedContext {
	var p = new(EscapedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_escaped

	return p
}

func (s *EscapedContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserESCAPE, 0)
}

func (s *EscapedContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *EscapedContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *EscapedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterEscaped(s)
	}
}

func (s *EscapedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitEscaped(s)
	}
}

func (p *Creole10Parser) Escaped() (localctx IEscapedContext) {
	localctx = NewEscapedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Creole10ParserRULE_escaped)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Match(Creole10ParserESCAPE)
		}
		{
			p.SetState(873)
			p.Match(Creole10ParserSTAR)
		}
		{
			p.SetState(874)
			p.Match(Creole10ParserSTAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(875)
			p.Match(Creole10ParserESCAPE)
		}
		p.SetState(876)
		p.MatchWildcard()

	}

	return localctx
}

// IParagraph_separatorContext is an interface to support dynamic dispatch.
type IParagraph_separatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraph_separatorContext differentiates from other interfaces.
	IsParagraph_separatorContext()
}

type Paragraph_separatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraph_separatorContext() *Paragraph_separatorContext {
	var p = new(Paragraph_separatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_paragraph_separator
	return p
}

func (*Paragraph_separatorContext) IsParagraph_separatorContext() {}

func NewParagraph_separatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Paragraph_separatorContext {
	var p = new(Paragraph_separatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_paragraph_separator

	return p
}

func (s *Paragraph_separatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Paragraph_separatorContext) AllNewline() []INewlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INewlineContext)(nil)).Elem())
	var tst = make([]INewlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INewlineContext)
		}
	}

	return tst
}

func (s *Paragraph_separatorContext) Newline(i int) INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Paragraph_separatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Paragraph_separatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Paragraph_separatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Paragraph_separatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterParagraph_separator(s)
	}
}

func (s *Paragraph_separatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitParagraph_separator(s)
	}
}

func (p *Creole10Parser) Paragraph_separator() (localctx IParagraph_separatorContext) {
	localctx = NewParagraph_separatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Creole10ParserRULE_paragraph_separator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(885)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(879)
					p.Newline()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(882)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(884)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWhitespacesContext is an interface to support dynamic dispatch.
type IWhitespacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhitespacesContext differentiates from other interfaces.
	IsWhitespacesContext()
}

type WhitespacesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhitespacesContext() *WhitespacesContext {
	var p = new(WhitespacesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_whitespaces
	return p
}

func (*WhitespacesContext) IsWhitespacesContext() {}

func NewWhitespacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhitespacesContext {
	var p = new(WhitespacesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_whitespaces

	return p
}

func (s *WhitespacesContext) GetParser() antlr.Parser { return s.parser }

func (s *WhitespacesContext) AllBlanks() []IBlanksContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlanksContext)(nil)).Elem())
	var tst = make([]IBlanksContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlanksContext)
		}
	}

	return tst
}

func (s *WhitespacesContext) Blanks(i int) IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *WhitespacesContext) AllNewline() []INewlineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INewlineContext)(nil)).Elem())
	var tst = make([]INewlineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INewlineContext)
		}
	}

	return tst
}

func (s *WhitespacesContext) Newline(i int) INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *WhitespacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhitespacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhitespacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterWhitespaces(s)
	}
}

func (s *WhitespacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitWhitespaces(s)
	}
}

func (p *Creole10Parser) Whitespaces() (localctx IWhitespacesContext) {
	localctx = NewWhitespacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Creole10ParserRULE_whitespaces)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(889)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Creole10ParserBLANKS:
				{
					p.SetState(887)
					p.Blanks()
				}

			case Creole10ParserNEWLINE:
				{
					p.SetState(888)
					p.Newline()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
	}

	return localctx
}

// IBlanksContext is an interface to support dynamic dispatch.
type IBlanksContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlanksContext differentiates from other interfaces.
	IsBlanksContext()
}

type BlanksContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlanksContext() *BlanksContext {
	var p = new(BlanksContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_blanks
	return p
}

func (*BlanksContext) IsBlanksContext() {}

func NewBlanksContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlanksContext {
	var p = new(BlanksContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_blanks

	return p
}

func (s *BlanksContext) GetParser() antlr.Parser { return s.parser }

func (s *BlanksContext) BLANKS() antlr.TerminalNode {
	return s.GetToken(Creole10ParserBLANKS, 0)
}

func (s *BlanksContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlanksContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlanksContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterBlanks(s)
	}
}

func (s *BlanksContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitBlanks(s)
	}
}

func (p *Creole10Parser) Blanks() (localctx IBlanksContext) {
	localctx = NewBlanksContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Creole10ParserRULE_blanks)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)
		p.Match(Creole10ParserBLANKS)
	}

	return localctx
}

// IText_lineseparatorContext is an interface to support dynamic dispatch.
type IText_lineseparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsText_lineseparatorContext differentiates from other interfaces.
	IsText_lineseparatorContext()
}

type Text_lineseparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyText_lineseparatorContext() *Text_lineseparatorContext {
	var p = new(Text_lineseparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_text_lineseparator
	return p
}

func (*Text_lineseparatorContext) IsText_lineseparatorContext() {}

func NewText_lineseparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Text_lineseparatorContext {
	var p = new(Text_lineseparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_text_lineseparator

	return p
}

func (s *Text_lineseparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Text_lineseparatorContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Text_lineseparatorContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *Text_lineseparatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Text_lineseparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Text_lineseparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Text_lineseparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterText_lineseparator(s)
	}
}

func (s *Text_lineseparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitText_lineseparator(s)
	}
}

func (p *Creole10Parser) Text_lineseparator() (localctx IText_lineseparatorContext) {
	localctx = NewText_lineseparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Creole10ParserRULE_text_lineseparator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(900)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(895)
			p.Newline()
		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(896)
				p.Blanks()
			}

		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(899)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INewlineContext is an interface to support dynamic dispatch.
type INewlineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewlineContext differentiates from other interfaces.
	IsNewlineContext()
}

type NewlineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewlineContext() *NewlineContext {
	var p = new(NewlineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_newline
	return p
}

func (*NewlineContext) IsNewlineContext() {}

func NewNewlineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewlineContext {
	var p = new(NewlineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_newline

	return p
}

func (s *NewlineContext) GetParser() antlr.Parser { return s.parser }

func (s *NewlineContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNEWLINE, 0)
}

func (s *NewlineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewlineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewlineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNewline(s)
	}
}

func (s *NewlineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNewline(s)
	}
}

func (p *Creole10Parser) Newline() (localctx INewlineContext) {
	localctx = NewNewlineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Creole10ParserRULE_newline)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(Creole10ParserNEWLINE)
	}

	return localctx
}

// IBold_markupContext is an interface to support dynamic dispatch.
type IBold_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBold_markupContext differentiates from other interfaces.
	IsBold_markupContext()
}

type Bold_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBold_markupContext() *Bold_markupContext {
	var p = new(Bold_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_bold_markup
	return p
}

func (*Bold_markupContext) IsBold_markupContext() {}

func NewBold_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bold_markupContext {
	var p = new(Bold_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_bold_markup

	return p
}

func (s *Bold_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Bold_markupContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserSTAR)
}

func (s *Bold_markupContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, i)
}

func (s *Bold_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bold_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bold_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterBold_markup(s)
	}
}

func (s *Bold_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitBold_markup(s)
	}
}

func (p *Creole10Parser) Bold_markup() (localctx IBold_markupContext) {
	localctx = NewBold_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Creole10ParserRULE_bold_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(904)
		p.Match(Creole10ParserSTAR)
	}
	{
		p.SetState(905)
		p.Match(Creole10ParserSTAR)
	}

	return localctx
}

// IItal_markupContext is an interface to support dynamic dispatch.
type IItal_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsItal_markupContext differentiates from other interfaces.
	IsItal_markupContext()
}

type Ital_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItal_markupContext() *Ital_markupContext {
	var p = new(Ital_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_ital_markup
	return p
}

func (*Ital_markupContext) IsItal_markupContext() {}

func NewItal_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ital_markupContext {
	var p = new(Ital_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_ital_markup

	return p
}

func (s *Ital_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Ital_markupContext) ITAL() antlr.TerminalNode {
	return s.GetToken(Creole10ParserITAL, 0)
}

func (s *Ital_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ital_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ital_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterItal_markup(s)
	}
}

func (s *Ital_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitItal_markup(s)
	}
}

func (p *Creole10Parser) Ital_markup() (localctx IItal_markupContext) {
	localctx = NewItal_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Creole10ParserRULE_ital_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.Match(Creole10ParserITAL)
	}

	return localctx
}

// IHeading_markupContext is an interface to support dynamic dispatch.
type IHeading_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeading_markupContext differentiates from other interfaces.
	IsHeading_markupContext()
}

type Heading_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeading_markupContext() *Heading_markupContext {
	var p = new(Heading_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_heading_markup
	return p
}

func (*Heading_markupContext) IsHeading_markupContext() {}

func NewHeading_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Heading_markupContext {
	var p = new(Heading_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_heading_markup

	return p
}

func (s *Heading_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Heading_markupContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, 0)
}

func (s *Heading_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Heading_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Heading_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHeading_markup(s)
	}
}

func (s *Heading_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHeading_markup(s)
	}
}

func (p *Creole10Parser) Heading_markup() (localctx IHeading_markupContext) {
	localctx = NewHeading_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Creole10ParserRULE_heading_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(909)
		p.Match(Creole10ParserEQUAL)
	}

	return localctx
}

// IList_ordelem_markupContext is an interface to support dynamic dispatch.
type IList_ordelem_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_ordelem_markupContext differentiates from other interfaces.
	IsList_ordelem_markupContext()
}

type List_ordelem_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_ordelem_markupContext() *List_ordelem_markupContext {
	var p = new(List_ordelem_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_ordelem_markup
	return p
}

func (*List_ordelem_markupContext) IsList_ordelem_markupContext() {}

func NewList_ordelem_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_ordelem_markupContext {
	var p = new(List_ordelem_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_ordelem_markup

	return p
}

func (s *List_ordelem_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *List_ordelem_markupContext) POUND() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPOUND, 0)
}

func (s *List_ordelem_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_ordelem_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_ordelem_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_ordelem_markup(s)
	}
}

func (s *List_ordelem_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_ordelem_markup(s)
	}
}

func (p *Creole10Parser) List_ordelem_markup() (localctx IList_ordelem_markupContext) {
	localctx = NewList_ordelem_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Creole10ParserRULE_list_ordelem_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(Creole10ParserPOUND)
	}

	return localctx
}

// IList_unordelem_markupContext is an interface to support dynamic dispatch.
type IList_unordelem_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_unordelem_markupContext differentiates from other interfaces.
	IsList_unordelem_markupContext()
}

type List_unordelem_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_unordelem_markupContext() *List_unordelem_markupContext {
	var p = new(List_unordelem_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_unordelem_markup
	return p
}

func (*List_unordelem_markupContext) IsList_unordelem_markupContext() {}

func NewList_unordelem_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_unordelem_markupContext {
	var p = new(List_unordelem_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_unordelem_markup

	return p
}

func (s *List_unordelem_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *List_unordelem_markupContext) STAR() antlr.TerminalNode {
	return s.GetToken(Creole10ParserSTAR, 0)
}

func (s *List_unordelem_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_unordelem_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_unordelem_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_unordelem_markup(s)
	}
}

func (s *List_unordelem_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_unordelem_markup(s)
	}
}

func (p *Creole10Parser) List_unordelem_markup() (localctx IList_unordelem_markupContext) {
	localctx = NewList_unordelem_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Creole10ParserRULE_list_unordelem_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.Match(Creole10ParserSTAR)
	}

	return localctx
}

// IList_elemseparatorContext is an interface to support dynamic dispatch.
type IList_elemseparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsList_elemseparatorContext differentiates from other interfaces.
	IsList_elemseparatorContext()
}

type List_elemseparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyList_elemseparatorContext() *List_elemseparatorContext {
	var p = new(List_elemseparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_list_elemseparator
	return p
}

func (*List_elemseparatorContext) IsList_elemseparatorContext() {}

func NewList_elemseparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *List_elemseparatorContext {
	var p = new(List_elemseparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_list_elemseparator

	return p
}

func (s *List_elemseparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *List_elemseparatorContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *List_elemseparatorContext) Blanks() IBlanksContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlanksContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlanksContext)
}

func (s *List_elemseparatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *List_elemseparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *List_elemseparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *List_elemseparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterList_elemseparator(s)
	}
}

func (s *List_elemseparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitList_elemseparator(s)
	}
}

func (p *Creole10Parser) List_elemseparator() (localctx IList_elemseparatorContext) {
	localctx = NewList_elemseparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Creole10ParserRULE_list_elemseparator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(920)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.Newline()
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(916)
				p.Blanks()
			}

		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(919)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnd_of_listContext is an interface to support dynamic dispatch.
type IEnd_of_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnd_of_listContext differentiates from other interfaces.
	IsEnd_of_listContext()
}

type End_of_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_of_listContext() *End_of_listContext {
	var p = new(End_of_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_end_of_list
	return p
}

func (*End_of_listContext) IsEnd_of_listContext() {}

func NewEnd_of_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_of_listContext {
	var p = new(End_of_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_end_of_list

	return p
}

func (s *End_of_listContext) GetParser() antlr.Parser { return s.parser }

func (s *End_of_listContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *End_of_listContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *End_of_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_of_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_of_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterEnd_of_list(s)
	}
}

func (s *End_of_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitEnd_of_list(s)
	}
}

func (p *Creole10Parser) End_of_list() (localctx IEnd_of_listContext) {
	localctx = NewEnd_of_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Creole10ParserRULE_end_of_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(924)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(922)
			p.Newline()
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(923)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITable_cell_markupContext is an interface to support dynamic dispatch.
type ITable_cell_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_cell_markupContext differentiates from other interfaces.
	IsTable_cell_markupContext()
}

type Table_cell_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_cell_markupContext() *Table_cell_markupContext {
	var p = new(Table_cell_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_cell_markup
	return p
}

func (*Table_cell_markupContext) IsTable_cell_markupContext() {}

func NewTable_cell_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_cell_markupContext {
	var p = new(Table_cell_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_cell_markup

	return p
}

func (s *Table_cell_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_cell_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Table_cell_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_cell_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_cell_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_cell_markup(s)
	}
}

func (s *Table_cell_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_cell_markup(s)
	}
}

func (p *Creole10Parser) Table_cell_markup() (localctx ITable_cell_markupContext) {
	localctx = NewTable_cell_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Creole10ParserRULE_table_cell_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(926)
		p.Match(Creole10ParserPIPE)
	}

	return localctx
}

// ITable_headercell_markupContext is an interface to support dynamic dispatch.
type ITable_headercell_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_headercell_markupContext differentiates from other interfaces.
	IsTable_headercell_markupContext()
}

type Table_headercell_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_headercell_markupContext() *Table_headercell_markupContext {
	var p = new(Table_headercell_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_headercell_markup
	return p
}

func (*Table_headercell_markupContext) IsTable_headercell_markupContext() {}

func NewTable_headercell_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_headercell_markupContext {
	var p = new(Table_headercell_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_headercell_markup

	return p
}

func (s *Table_headercell_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_headercell_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Table_headercell_markupContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEQUAL, 0)
}

func (s *Table_headercell_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_headercell_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_headercell_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_headercell_markup(s)
	}
}

func (s *Table_headercell_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_headercell_markup(s)
	}
}

func (p *Creole10Parser) Table_headercell_markup() (localctx ITable_headercell_markupContext) {
	localctx = NewTable_headercell_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Creole10ParserRULE_table_headercell_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(Creole10ParserPIPE)
	}
	{
		p.SetState(929)
		p.Match(Creole10ParserEQUAL)
	}

	return localctx
}

// ITable_rowseparatorContext is an interface to support dynamic dispatch.
type ITable_rowseparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTable_rowseparatorContext differentiates from other interfaces.
	IsTable_rowseparatorContext()
}

type Table_rowseparatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowseparatorContext() *Table_rowseparatorContext {
	var p = new(Table_rowseparatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_table_rowseparator
	return p
}

func (*Table_rowseparatorContext) IsTable_rowseparatorContext() {}

func NewTable_rowseparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowseparatorContext {
	var p = new(Table_rowseparatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_table_rowseparator

	return p
}

func (s *Table_rowseparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowseparatorContext) Newline() INewlineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewlineContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewlineContext)
}

func (s *Table_rowseparatorContext) EOF() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEOF, 0)
}

func (s *Table_rowseparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowseparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_rowseparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterTable_rowseparator(s)
	}
}

func (s *Table_rowseparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitTable_rowseparator(s)
	}
}

func (p *Creole10Parser) Table_rowseparator() (localctx ITable_rowseparatorContext) {
	localctx = NewTable_rowseparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Creole10ParserRULE_table_rowseparator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(933)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Creole10ParserNEWLINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(931)
			p.Newline()
		}

	case Creole10ParserEOF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(932)
			p.Match(Creole10ParserEOF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INowiki_open_markupContext is an interface to support dynamic dispatch.
type INowiki_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_open_markupContext differentiates from other interfaces.
	IsNowiki_open_markupContext()
}

type Nowiki_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_open_markupContext() *Nowiki_open_markupContext {
	var p = new(Nowiki_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_open_markup
	return p
}

func (*Nowiki_open_markupContext) IsNowiki_open_markupContext() {}

func NewNowiki_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_open_markupContext {
	var p = new(Nowiki_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_open_markup

	return p
}

func (s *Nowiki_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_open_markupContext) NOWIKI_OPEN() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_OPEN, 0)
}

func (s *Nowiki_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_open_markup(s)
	}
}

func (s *Nowiki_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_open_markup(s)
	}
}

func (p *Creole10Parser) Nowiki_open_markup() (localctx INowiki_open_markupContext) {
	localctx = NewNowiki_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Creole10ParserRULE_nowiki_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.Match(Creole10ParserNOWIKI_OPEN)
	}

	return localctx
}

// INowiki_close_markupContext is an interface to support dynamic dispatch.
type INowiki_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNowiki_close_markupContext differentiates from other interfaces.
	IsNowiki_close_markupContext()
}

type Nowiki_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNowiki_close_markupContext() *Nowiki_close_markupContext {
	var p = new(Nowiki_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_nowiki_close_markup
	return p
}

func (*Nowiki_close_markupContext) IsNowiki_close_markupContext() {}

func NewNowiki_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Nowiki_close_markupContext {
	var p = new(Nowiki_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_nowiki_close_markup

	return p
}

func (s *Nowiki_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Nowiki_close_markupContext) NOWIKI_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserNOWIKI_CLOSE, 0)
}

func (s *Nowiki_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Nowiki_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Nowiki_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterNowiki_close_markup(s)
	}
}

func (s *Nowiki_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitNowiki_close_markup(s)
	}
}

func (p *Creole10Parser) Nowiki_close_markup() (localctx INowiki_close_markupContext) {
	localctx = NewNowiki_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Creole10ParserRULE_nowiki_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.Match(Creole10ParserNOWIKI_CLOSE)
	}

	return localctx
}

// IHorizontalrule_markupContext is an interface to support dynamic dispatch.
type IHorizontalrule_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHorizontalrule_markupContext differentiates from other interfaces.
	IsHorizontalrule_markupContext()
}

type Horizontalrule_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHorizontalrule_markupContext() *Horizontalrule_markupContext {
	var p = new(Horizontalrule_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_horizontalrule_markup
	return p
}

func (*Horizontalrule_markupContext) IsHorizontalrule_markupContext() {}

func NewHorizontalrule_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Horizontalrule_markupContext {
	var p = new(Horizontalrule_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_horizontalrule_markup

	return p
}

func (s *Horizontalrule_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Horizontalrule_markupContext) AllDASH() []antlr.TerminalNode {
	return s.GetTokens(Creole10ParserDASH)
}

func (s *Horizontalrule_markupContext) DASH(i int) antlr.TerminalNode {
	return s.GetToken(Creole10ParserDASH, i)
}

func (s *Horizontalrule_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Horizontalrule_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Horizontalrule_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterHorizontalrule_markup(s)
	}
}

func (s *Horizontalrule_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitHorizontalrule_markup(s)
	}
}

func (p *Creole10Parser) Horizontalrule_markup() (localctx IHorizontalrule_markupContext) {
	localctx = NewHorizontalrule_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Creole10ParserRULE_horizontalrule_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(939)
		p.Match(Creole10ParserDASH)
	}
	{
		p.SetState(940)
		p.Match(Creole10ParserDASH)
	}
	{
		p.SetState(941)
		p.Match(Creole10ParserDASH)
	}
	{
		p.SetState(942)
		p.Match(Creole10ParserDASH)
	}

	return localctx
}

// ILink_open_markupContext is an interface to support dynamic dispatch.
type ILink_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_open_markupContext differentiates from other interfaces.
	IsLink_open_markupContext()
}

type Link_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_open_markupContext() *Link_open_markupContext {
	var p = new(Link_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_open_markup
	return p
}

func (*Link_open_markupContext) IsLink_open_markupContext() {}

func NewLink_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_open_markupContext {
	var p = new(Link_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_open_markup

	return p
}

func (s *Link_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_open_markupContext) LINK_OPEN() antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_OPEN, 0)
}

func (s *Link_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_open_markup(s)
	}
}

func (s *Link_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_open_markup(s)
	}
}

func (p *Creole10Parser) Link_open_markup() (localctx ILink_open_markupContext) {
	localctx = NewLink_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Creole10ParserRULE_link_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(Creole10ParserLINK_OPEN)
	}

	return localctx
}

// ILink_close_markupContext is an interface to support dynamic dispatch.
type ILink_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_close_markupContext differentiates from other interfaces.
	IsLink_close_markupContext()
}

type Link_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_close_markupContext() *Link_close_markupContext {
	var p = new(Link_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_close_markup
	return p
}

func (*Link_close_markupContext) IsLink_close_markupContext() {}

func NewLink_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_close_markupContext {
	var p = new(Link_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_close_markup

	return p
}

func (s *Link_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_close_markupContext) LINK_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserLINK_CLOSE, 0)
}

func (s *Link_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_close_markup(s)
	}
}

func (s *Link_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_close_markup(s)
	}
}

func (p *Creole10Parser) Link_close_markup() (localctx ILink_close_markupContext) {
	localctx = NewLink_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Creole10ParserRULE_link_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Match(Creole10ParserLINK_CLOSE)
	}

	return localctx
}

// ILink_description_markupContext is an interface to support dynamic dispatch.
type ILink_description_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLink_description_markupContext differentiates from other interfaces.
	IsLink_description_markupContext()
}

type Link_description_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLink_description_markupContext() *Link_description_markupContext {
	var p = new(Link_description_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_link_description_markup
	return p
}

func (*Link_description_markupContext) IsLink_description_markupContext() {}

func NewLink_description_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Link_description_markupContext {
	var p = new(Link_description_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_link_description_markup

	return p
}

func (s *Link_description_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Link_description_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Link_description_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Link_description_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Link_description_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterLink_description_markup(s)
	}
}

func (s *Link_description_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitLink_description_markup(s)
	}
}

func (p *Creole10Parser) Link_description_markup() (localctx ILink_description_markupContext) {
	localctx = NewLink_description_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Creole10ParserRULE_link_description_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.Match(Creole10ParserPIPE)
	}

	return localctx
}

// IImage_open_markupContext is an interface to support dynamic dispatch.
type IImage_open_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_open_markupContext differentiates from other interfaces.
	IsImage_open_markupContext()
}

type Image_open_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_open_markupContext() *Image_open_markupContext {
	var p = new(Image_open_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_open_markup
	return p
}

func (*Image_open_markupContext) IsImage_open_markupContext() {}

func NewImage_open_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_open_markupContext {
	var p = new(Image_open_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_open_markup

	return p
}

func (s *Image_open_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_open_markupContext) IMAGE_OPEN() antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_OPEN, 0)
}

func (s *Image_open_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_open_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_open_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_open_markup(s)
	}
}

func (s *Image_open_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_open_markup(s)
	}
}

func (p *Creole10Parser) Image_open_markup() (localctx IImage_open_markupContext) {
	localctx = NewImage_open_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Creole10ParserRULE_image_open_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Match(Creole10ParserIMAGE_OPEN)
	}

	return localctx
}

// IImage_close_markupContext is an interface to support dynamic dispatch.
type IImage_close_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_close_markupContext differentiates from other interfaces.
	IsImage_close_markupContext()
}

type Image_close_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_close_markupContext() *Image_close_markupContext {
	var p = new(Image_close_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_close_markup
	return p
}

func (*Image_close_markupContext) IsImage_close_markupContext() {}

func NewImage_close_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_close_markupContext {
	var p = new(Image_close_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_close_markup

	return p
}

func (s *Image_close_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_close_markupContext) IMAGE_CLOSE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserIMAGE_CLOSE, 0)
}

func (s *Image_close_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_close_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_close_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_close_markup(s)
	}
}

func (s *Image_close_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_close_markup(s)
	}
}

func (p *Creole10Parser) Image_close_markup() (localctx IImage_close_markupContext) {
	localctx = NewImage_close_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Creole10ParserRULE_image_close_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.Match(Creole10ParserIMAGE_CLOSE)
	}

	return localctx
}

// IImage_alternative_markupContext is an interface to support dynamic dispatch.
type IImage_alternative_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImage_alternative_markupContext differentiates from other interfaces.
	IsImage_alternative_markupContext()
}

type Image_alternative_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImage_alternative_markupContext() *Image_alternative_markupContext {
	var p = new(Image_alternative_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_image_alternative_markup
	return p
}

func (*Image_alternative_markupContext) IsImage_alternative_markupContext() {}

func NewImage_alternative_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Image_alternative_markupContext {
	var p = new(Image_alternative_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_image_alternative_markup

	return p
}

func (s *Image_alternative_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Image_alternative_markupContext) PIPE() antlr.TerminalNode {
	return s.GetToken(Creole10ParserPIPE, 0)
}

func (s *Image_alternative_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Image_alternative_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Image_alternative_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterImage_alternative_markup(s)
	}
}

func (s *Image_alternative_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitImage_alternative_markup(s)
	}
}

func (p *Creole10Parser) Image_alternative_markup() (localctx IImage_alternative_markupContext) {
	localctx = NewImage_alternative_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Creole10ParserRULE_image_alternative_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.Match(Creole10ParserPIPE)
	}

	return localctx
}

// IExtension_markupContext is an interface to support dynamic dispatch.
type IExtension_markupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtension_markupContext differentiates from other interfaces.
	IsExtension_markupContext()
}

type Extension_markupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtension_markupContext() *Extension_markupContext {
	var p = new(Extension_markupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_extension_markup
	return p
}

func (*Extension_markupContext) IsExtension_markupContext() {}

func NewExtension_markupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Extension_markupContext {
	var p = new(Extension_markupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_extension_markup

	return p
}

func (s *Extension_markupContext) GetParser() antlr.Parser { return s.parser }

func (s *Extension_markupContext) EXTENSION() antlr.TerminalNode {
	return s.GetToken(Creole10ParserEXTENSION, 0)
}

func (s *Extension_markupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Extension_markupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Extension_markupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterExtension_markup(s)
	}
}

func (s *Extension_markupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitExtension_markup(s)
	}
}

func (p *Creole10Parser) Extension_markup() (localctx IExtension_markupContext) {
	localctx = NewExtension_markupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Creole10ParserRULE_extension_markup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Match(Creole10ParserEXTENSION)
	}

	return localctx
}

// IForced_linebreakContext is an interface to support dynamic dispatch.
type IForced_linebreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForced_linebreakContext differentiates from other interfaces.
	IsForced_linebreakContext()
}

type Forced_linebreakContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForced_linebreakContext() *Forced_linebreakContext {
	var p = new(Forced_linebreakContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Creole10ParserRULE_forced_linebreak
	return p
}

func (*Forced_linebreakContext) IsForced_linebreakContext() {}

func NewForced_linebreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forced_linebreakContext {
	var p = new(Forced_linebreakContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Creole10ParserRULE_forced_linebreak

	return p
}

func (s *Forced_linebreakContext) GetParser() antlr.Parser { return s.parser }

func (s *Forced_linebreakContext) FORCED_LINEBREAK() antlr.TerminalNode {
	return s.GetToken(Creole10ParserFORCED_LINEBREAK, 0)
}

func (s *Forced_linebreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forced_linebreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forced_linebreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.EnterForced_linebreak(s)
	}
}

func (s *Forced_linebreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Creole10Listener); ok {
		listenerT.ExitForced_linebreak(s)
	}
}

func (p *Creole10Parser) Forced_linebreak() (localctx IForced_linebreakContext) {
	localctx = NewForced_linebreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Creole10ParserRULE_forced_linebreak)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		p.Match(Creole10ParserFORCED_LINEBREAK)
	}

	return localctx
}

func (p *Creole10Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 3:
		var t *ParagraphContext = nil
		if localctx != nil {
			t = localctx.(*ParagraphContext)
		}
		return p.Paragraph_Sempred(t, predIndex)

	case 6:
		var t *Text_firstelementContext = nil
		if localctx != nil {
			t = localctx.(*Text_firstelementContext)
		}
		return p.Text_firstelement_Sempred(t, predIndex)

	case 16:
		var t *Text_lineseparator1Context = nil
		if localctx != nil {
			t = localctx.(*Text_lineseparator1Context)
		}
		return p.Text_lineseparator1_Sempred(t, predIndex)

	case 34:
		var t *OnestarContext = nil
		if localctx != nil {
			t = localctx.(*OnestarContext)
		}
		return p.Onestar_Sempred(t, predIndex)

	case 40:
		var t *Table_cellContext = nil
		if localctx != nil {
			t = localctx.(*Table_cellContext)
		}
		return p.Table_cell_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Creole10Parser) Paragraph_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.GetInputStream().LA(1) == Creole10ParserDASH &&
			p.GetInputStream().LA(2) == Creole10ParserDASH &&
			p.GetInputStream().LA(3) == Creole10ParserDASH &&
			p.GetInputStream().LA(4) == Creole10ParserDASH

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Text_firstelement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.GetInputStream().LA(1) != Creole10ParserSTAR ||
			(p.GetInputStream().LA(1) == Creole10ParserSTAR &&
				p.GetInputStream().LA(2) == Creole10ParserSTAR)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Text_lineseparator1_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.GetInputStream().LA(2) != Creole10ParserDASH &&
			p.GetInputStream().LA(2) != Creole10ParserPOUND &&
			p.GetInputStream().LA(2) != Creole10ParserEQUAL &&
			p.GetInputStream().LA(2) != Creole10ParserNEWLINE

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Onestar_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.GetInputStream().LA(2) != Creole10ParserSTAR

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Creole10Parser) Table_cell_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.GetInputStream().LA(2) == Creole10ParserEQUAL

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
